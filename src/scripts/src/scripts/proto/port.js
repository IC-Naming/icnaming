/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const ic_nns_governance = $root.ic_nns_governance = (() => {

    /**
     * Namespace ic_nns_governance.
     * @exports ic_nns_governance
     * @namespace
     */
    const ic_nns_governance = {};

    ic_nns_governance.pb = (function() {

        /**
         * Namespace pb.
         * @memberof ic_nns_governance
         * @namespace
         */
        const pb = {};

        pb.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof ic_nns_governance.pb
             * @namespace
             */
            const v1 = {};

            v1.NodeProvider = (function() {

                /**
                 * Properties of a NodeProvider.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface INodeProvider
                 * @property {ic_base_types.pb.v1.IPrincipalId|null} [id] NodeProvider id
                 * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [rewardAccount] NodeProvider rewardAccount
                 */

                /**
                 * Constructs a new NodeProvider.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a NodeProvider.
                 * @implements INodeProvider
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.INodeProvider=} [properties] Properties to set
                 */
                function NodeProvider(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NodeProvider id.
                 * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} id
                 * @memberof ic_nns_governance.pb.v1.NodeProvider
                 * @instance
                 */
                NodeProvider.prototype.id = null;

                /**
                 * NodeProvider rewardAccount.
                 * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} rewardAccount
                 * @memberof ic_nns_governance.pb.v1.NodeProvider
                 * @instance
                 */
                NodeProvider.prototype.rewardAccount = null;

                /**
                 * Creates a new NodeProvider instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.NodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.INodeProvider=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.NodeProvider} NodeProvider instance
                 */
                NodeProvider.create = function create(properties) {
                    return new NodeProvider(properties);
                };

                /**
                 * Encodes the specified NodeProvider message. Does not implicitly {@link ic_nns_governance.pb.v1.NodeProvider.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.NodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.INodeProvider} message NodeProvider message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeProvider.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        $root.ic_base_types.pb.v1.PrincipalId.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.rewardAccount != null && Object.hasOwnProperty.call(message, "rewardAccount"))
                        $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.rewardAccount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified NodeProvider message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.NodeProvider.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.NodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.INodeProvider} message NodeProvider message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeProvider.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NodeProvider message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.NodeProvider
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.NodeProvider} NodeProvider
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeProvider.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.NodeProvider();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.rewardAccount = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NodeProvider message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.NodeProvider
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.NodeProvider} NodeProvider
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeProvider.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NodeProvider message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.NodeProvider
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeProvider.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.rewardAccount != null && message.hasOwnProperty("rewardAccount")) {
                        let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.rewardAccount);
                        if (error)
                            return "rewardAccount." + error;
                    }
                    return null;
                };

                /**
                 * Creates a NodeProvider message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.NodeProvider
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.NodeProvider} NodeProvider
                 */
                NodeProvider.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.NodeProvider)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.NodeProvider();
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.NodeProvider.id: object expected");
                        message.id = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.id);
                    }
                    if (object.rewardAccount != null) {
                        if (typeof object.rewardAccount !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.NodeProvider.rewardAccount: object expected");
                        message.rewardAccount = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.rewardAccount);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a NodeProvider message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.NodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.NodeProvider} message NodeProvider
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NodeProvider.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.id = null;
                        object.rewardAccount = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.id, options);
                    if (message.rewardAccount != null && message.hasOwnProperty("rewardAccount"))
                        object.rewardAccount = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.rewardAccount, options);
                    return object;
                };

                /**
                 * Converts this NodeProvider to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.NodeProvider
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NodeProvider.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NodeProvider;
            })();

            v1.UpdateNodeProvider = (function() {

                /**
                 * Properties of an UpdateNodeProvider.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IUpdateNodeProvider
                 * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [rewardAccount] UpdateNodeProvider rewardAccount
                 */

                /**
                 * Constructs a new UpdateNodeProvider.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents an UpdateNodeProvider.
                 * @implements IUpdateNodeProvider
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IUpdateNodeProvider=} [properties] Properties to set
                 */
                function UpdateNodeProvider(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateNodeProvider rewardAccount.
                 * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} rewardAccount
                 * @memberof ic_nns_governance.pb.v1.UpdateNodeProvider
                 * @instance
                 */
                UpdateNodeProvider.prototype.rewardAccount = null;

                /**
                 * Creates a new UpdateNodeProvider instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.UpdateNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.IUpdateNodeProvider=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.UpdateNodeProvider} UpdateNodeProvider instance
                 */
                UpdateNodeProvider.create = function create(properties) {
                    return new UpdateNodeProvider(properties);
                };

                /**
                 * Encodes the specified UpdateNodeProvider message. Does not implicitly {@link ic_nns_governance.pb.v1.UpdateNodeProvider.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.UpdateNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.IUpdateNodeProvider} message UpdateNodeProvider message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateNodeProvider.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rewardAccount != null && Object.hasOwnProperty.call(message, "rewardAccount"))
                        $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.rewardAccount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified UpdateNodeProvider message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.UpdateNodeProvider.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.UpdateNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.IUpdateNodeProvider} message UpdateNodeProvider message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateNodeProvider.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UpdateNodeProvider message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.UpdateNodeProvider
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.UpdateNodeProvider} UpdateNodeProvider
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateNodeProvider.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.UpdateNodeProvider();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.rewardAccount = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UpdateNodeProvider message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.UpdateNodeProvider
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.UpdateNodeProvider} UpdateNodeProvider
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateNodeProvider.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UpdateNodeProvider message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.UpdateNodeProvider
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateNodeProvider.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.rewardAccount != null && message.hasOwnProperty("rewardAccount")) {
                        let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.rewardAccount);
                        if (error)
                            return "rewardAccount." + error;
                    }
                    return null;
                };

                /**
                 * Creates an UpdateNodeProvider message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.UpdateNodeProvider
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.UpdateNodeProvider} UpdateNodeProvider
                 */
                UpdateNodeProvider.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.UpdateNodeProvider)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.UpdateNodeProvider();
                    if (object.rewardAccount != null) {
                        if (typeof object.rewardAccount !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.UpdateNodeProvider.rewardAccount: object expected");
                        message.rewardAccount = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.rewardAccount);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateNodeProvider message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.UpdateNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.UpdateNodeProvider} message UpdateNodeProvider
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateNodeProvider.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.rewardAccount = null;
                    if (message.rewardAccount != null && message.hasOwnProperty("rewardAccount"))
                        object.rewardAccount = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.rewardAccount, options);
                    return object;
                };

                /**
                 * Converts this UpdateNodeProvider to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.UpdateNodeProvider
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateNodeProvider.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateNodeProvider;
            })();

            /**
             * Topic enum.
             * @name ic_nns_governance.pb.v1.Topic
             * @enum {number}
             * @property {number} TOPIC_UNSPECIFIED=0 TOPIC_UNSPECIFIED value
             * @property {number} TOPIC_NEURON_MANAGEMENT=1 TOPIC_NEURON_MANAGEMENT value
             * @property {number} TOPIC_EXCHANGE_RATE=2 TOPIC_EXCHANGE_RATE value
             * @property {number} TOPIC_NETWORK_ECONOMICS=3 TOPIC_NETWORK_ECONOMICS value
             * @property {number} TOPIC_GOVERNANCE=4 TOPIC_GOVERNANCE value
             * @property {number} TOPIC_NODE_ADMIN=5 TOPIC_NODE_ADMIN value
             * @property {number} TOPIC_PARTICIPANT_MANAGEMENT=6 TOPIC_PARTICIPANT_MANAGEMENT value
             * @property {number} TOPIC_SUBNET_MANAGEMENT=7 TOPIC_SUBNET_MANAGEMENT value
             * @property {number} TOPIC_NETWORK_CANISTER_MANAGEMENT=8 TOPIC_NETWORK_CANISTER_MANAGEMENT value
             * @property {number} TOPIC_KYC=9 TOPIC_KYC value
             * @property {number} TOPIC_NODE_PROVIDER_REWARDS=10 TOPIC_NODE_PROVIDER_REWARDS value
             */
            v1.Topic = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TOPIC_UNSPECIFIED"] = 0;
                values[valuesById[1] = "TOPIC_NEURON_MANAGEMENT"] = 1;
                values[valuesById[2] = "TOPIC_EXCHANGE_RATE"] = 2;
                values[valuesById[3] = "TOPIC_NETWORK_ECONOMICS"] = 3;
                values[valuesById[4] = "TOPIC_GOVERNANCE"] = 4;
                values[valuesById[5] = "TOPIC_NODE_ADMIN"] = 5;
                values[valuesById[6] = "TOPIC_PARTICIPANT_MANAGEMENT"] = 6;
                values[valuesById[7] = "TOPIC_SUBNET_MANAGEMENT"] = 7;
                values[valuesById[8] = "TOPIC_NETWORK_CANISTER_MANAGEMENT"] = 8;
                values[valuesById[9] = "TOPIC_KYC"] = 9;
                values[valuesById[10] = "TOPIC_NODE_PROVIDER_REWARDS"] = 10;
                return values;
            })();

            /**
             * NeuronState enum.
             * @name ic_nns_governance.pb.v1.NeuronState
             * @enum {number}
             * @property {number} NEURON_STATE_UNSPECIFIED=0 NEURON_STATE_UNSPECIFIED value
             * @property {number} NEURON_STATE_NOT_DISSOLVING=1 NEURON_STATE_NOT_DISSOLVING value
             * @property {number} NEURON_STATE_DISSOLVING=2 NEURON_STATE_DISSOLVING value
             * @property {number} NEURON_STATE_DISSOLVED=3 NEURON_STATE_DISSOLVED value
             */
            v1.NeuronState = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NEURON_STATE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "NEURON_STATE_NOT_DISSOLVING"] = 1;
                values[valuesById[2] = "NEURON_STATE_DISSOLVING"] = 2;
                values[valuesById[3] = "NEURON_STATE_DISSOLVED"] = 3;
                return values;
            })();

            v1.BallotInfo = (function() {

                /**
                 * Properties of a BallotInfo.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IBallotInfo
                 * @property {ic_nns_common.pb.v1.IProposalId|null} [proposalId] BallotInfo proposalId
                 * @property {ic_nns_governance.pb.v1.Vote|null} [vote] BallotInfo vote
                 */

                /**
                 * Constructs a new BallotInfo.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a BallotInfo.
                 * @implements IBallotInfo
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IBallotInfo=} [properties] Properties to set
                 */
                function BallotInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BallotInfo proposalId.
                 * @member {ic_nns_common.pb.v1.IProposalId|null|undefined} proposalId
                 * @memberof ic_nns_governance.pb.v1.BallotInfo
                 * @instance
                 */
                BallotInfo.prototype.proposalId = null;

                /**
                 * BallotInfo vote.
                 * @member {ic_nns_governance.pb.v1.Vote} vote
                 * @memberof ic_nns_governance.pb.v1.BallotInfo
                 * @instance
                 */
                BallotInfo.prototype.vote = 0;

                /**
                 * Creates a new BallotInfo instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.BallotInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.IBallotInfo=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.BallotInfo} BallotInfo instance
                 */
                BallotInfo.create = function create(properties) {
                    return new BallotInfo(properties);
                };

                /**
                 * Encodes the specified BallotInfo message. Does not implicitly {@link ic_nns_governance.pb.v1.BallotInfo.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.BallotInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.IBallotInfo} message BallotInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BallotInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.proposalId != null && Object.hasOwnProperty.call(message, "proposalId"))
                        $root.ic_nns_common.pb.v1.ProposalId.encode(message.proposalId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.vote != null && Object.hasOwnProperty.call(message, "vote"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.vote);
                    return writer;
                };

                /**
                 * Encodes the specified BallotInfo message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.BallotInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.BallotInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.IBallotInfo} message BallotInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BallotInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BallotInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.BallotInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.BallotInfo} BallotInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BallotInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.BallotInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.proposalId = $root.ic_nns_common.pb.v1.ProposalId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.vote = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BallotInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.BallotInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.BallotInfo} BallotInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BallotInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BallotInfo message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.BallotInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BallotInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.proposalId != null && message.hasOwnProperty("proposalId")) {
                        let error = $root.ic_nns_common.pb.v1.ProposalId.verify(message.proposalId);
                        if (error)
                            return "proposalId." + error;
                    }
                    if (message.vote != null && message.hasOwnProperty("vote"))
                        switch (message.vote) {
                        default:
                            return "vote: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a BallotInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.BallotInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.BallotInfo} BallotInfo
                 */
                BallotInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.BallotInfo)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.BallotInfo();
                    if (object.proposalId != null) {
                        if (typeof object.proposalId !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.BallotInfo.proposalId: object expected");
                        message.proposalId = $root.ic_nns_common.pb.v1.ProposalId.fromObject(object.proposalId);
                    }
                    switch (object.vote) {
                    case "VOTE_UNSPECIFIED":
                    case 0:
                        message.vote = 0;
                        break;
                    case "VOTE_YES":
                    case 1:
                        message.vote = 1;
                        break;
                    case "VOTE_NO":
                    case 2:
                        message.vote = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BallotInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.BallotInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.BallotInfo} message BallotInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BallotInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.proposalId = null;
                        object.vote = options.enums === String ? "VOTE_UNSPECIFIED" : 0;
                    }
                    if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                        object.proposalId = $root.ic_nns_common.pb.v1.ProposalId.toObject(message.proposalId, options);
                    if (message.vote != null && message.hasOwnProperty("vote"))
                        object.vote = options.enums === String ? $root.ic_nns_governance.pb.v1.Vote[message.vote] : message.vote;
                    return object;
                };

                /**
                 * Converts this BallotInfo to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.BallotInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BallotInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return BallotInfo;
            })();

            v1.NeuronInfo = (function() {

                /**
                 * Properties of a NeuronInfo.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface INeuronInfo
                 * @property {number|Long|null} [retrievedAtTimestampSeconds] NeuronInfo retrievedAtTimestampSeconds
                 * @property {ic_nns_governance.pb.v1.NeuronState|null} [state] NeuronInfo state
                 * @property {number|Long|null} [ageSeconds] NeuronInfo ageSeconds
                 * @property {number|Long|null} [dissolveDelaySeconds] NeuronInfo dissolveDelaySeconds
                 * @property {Array.<ic_nns_governance.pb.v1.IBallotInfo>|null} [recentBallots] NeuronInfo recentBallots
                 * @property {number|Long|null} [votingPower] NeuronInfo votingPower
                 * @property {number|Long|null} [createdTimestampSeconds] NeuronInfo createdTimestampSeconds
                 * @property {number|Long|null} [stakeE8s] NeuronInfo stakeE8s
                 * @property {number|Long|null} [joinedCommunityFundTimestampSeconds] NeuronInfo joinedCommunityFundTimestampSeconds
                 */

                /**
                 * Constructs a new NeuronInfo.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a NeuronInfo.
                 * @implements INeuronInfo
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.INeuronInfo=} [properties] Properties to set
                 */
                function NeuronInfo(properties) {
                    this.recentBallots = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NeuronInfo retrievedAtTimestampSeconds.
                 * @member {number|Long} retrievedAtTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @instance
                 */
                NeuronInfo.prototype.retrievedAtTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NeuronInfo state.
                 * @member {ic_nns_governance.pb.v1.NeuronState} state
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @instance
                 */
                NeuronInfo.prototype.state = 0;

                /**
                 * NeuronInfo ageSeconds.
                 * @member {number|Long} ageSeconds
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @instance
                 */
                NeuronInfo.prototype.ageSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NeuronInfo dissolveDelaySeconds.
                 * @member {number|Long} dissolveDelaySeconds
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @instance
                 */
                NeuronInfo.prototype.dissolveDelaySeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NeuronInfo recentBallots.
                 * @member {Array.<ic_nns_governance.pb.v1.IBallotInfo>} recentBallots
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @instance
                 */
                NeuronInfo.prototype.recentBallots = $util.emptyArray;

                /**
                 * NeuronInfo votingPower.
                 * @member {number|Long} votingPower
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @instance
                 */
                NeuronInfo.prototype.votingPower = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NeuronInfo createdTimestampSeconds.
                 * @member {number|Long} createdTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @instance
                 */
                NeuronInfo.prototype.createdTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NeuronInfo stakeE8s.
                 * @member {number|Long} stakeE8s
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @instance
                 */
                NeuronInfo.prototype.stakeE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NeuronInfo joinedCommunityFundTimestampSeconds.
                 * @member {number|Long|null|undefined} joinedCommunityFundTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @instance
                 */
                NeuronInfo.prototype.joinedCommunityFundTimestampSeconds = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * NeuronInfo _joinedCommunityFundTimestampSeconds.
                 * @member {"joinedCommunityFundTimestampSeconds"|undefined} _joinedCommunityFundTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @instance
                 */
                Object.defineProperty(NeuronInfo.prototype, "_joinedCommunityFundTimestampSeconds", {
                    get: $util.oneOfGetter($oneOfFields = ["joinedCommunityFundTimestampSeconds"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new NeuronInfo instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.INeuronInfo=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.NeuronInfo} NeuronInfo instance
                 */
                NeuronInfo.create = function create(properties) {
                    return new NeuronInfo(properties);
                };

                /**
                 * Encodes the specified NeuronInfo message. Does not implicitly {@link ic_nns_governance.pb.v1.NeuronInfo.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.INeuronInfo} message NeuronInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuronInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.retrievedAtTimestampSeconds != null && Object.hasOwnProperty.call(message, "retrievedAtTimestampSeconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.retrievedAtTimestampSeconds);
                    if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                    if (message.ageSeconds != null && Object.hasOwnProperty.call(message, "ageSeconds"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.ageSeconds);
                    if (message.dissolveDelaySeconds != null && Object.hasOwnProperty.call(message, "dissolveDelaySeconds"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.dissolveDelaySeconds);
                    if (message.recentBallots != null && message.recentBallots.length)
                        for (let i = 0; i < message.recentBallots.length; ++i)
                            $root.ic_nns_governance.pb.v1.BallotInfo.encode(message.recentBallots[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.votingPower != null && Object.hasOwnProperty.call(message, "votingPower"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.votingPower);
                    if (message.createdTimestampSeconds != null && Object.hasOwnProperty.call(message, "createdTimestampSeconds"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.createdTimestampSeconds);
                    if (message.stakeE8s != null && Object.hasOwnProperty.call(message, "stakeE8s"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.stakeE8s);
                    if (message.joinedCommunityFundTimestampSeconds != null && Object.hasOwnProperty.call(message, "joinedCommunityFundTimestampSeconds"))
                        writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.joinedCommunityFundTimestampSeconds);
                    return writer;
                };

                /**
                 * Encodes the specified NeuronInfo message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.NeuronInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.INeuronInfo} message NeuronInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuronInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NeuronInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.NeuronInfo} NeuronInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuronInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.NeuronInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.retrievedAtTimestampSeconds = reader.uint64();
                            break;
                        case 2:
                            message.state = reader.int32();
                            break;
                        case 3:
                            message.ageSeconds = reader.uint64();
                            break;
                        case 4:
                            message.dissolveDelaySeconds = reader.uint64();
                            break;
                        case 5:
                            if (!(message.recentBallots && message.recentBallots.length))
                                message.recentBallots = [];
                            message.recentBallots.push($root.ic_nns_governance.pb.v1.BallotInfo.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.votingPower = reader.uint64();
                            break;
                        case 7:
                            message.createdTimestampSeconds = reader.uint64();
                            break;
                        case 8:
                            message.stakeE8s = reader.uint64();
                            break;
                        case 9:
                            message.joinedCommunityFundTimestampSeconds = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NeuronInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.NeuronInfo} NeuronInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuronInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NeuronInfo message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NeuronInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.retrievedAtTimestampSeconds != null && message.hasOwnProperty("retrievedAtTimestampSeconds"))
                        if (!$util.isInteger(message.retrievedAtTimestampSeconds) && !(message.retrievedAtTimestampSeconds && $util.isInteger(message.retrievedAtTimestampSeconds.low) && $util.isInteger(message.retrievedAtTimestampSeconds.high)))
                            return "retrievedAtTimestampSeconds: integer|Long expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.ageSeconds != null && message.hasOwnProperty("ageSeconds"))
                        if (!$util.isInteger(message.ageSeconds) && !(message.ageSeconds && $util.isInteger(message.ageSeconds.low) && $util.isInteger(message.ageSeconds.high)))
                            return "ageSeconds: integer|Long expected";
                    if (message.dissolveDelaySeconds != null && message.hasOwnProperty("dissolveDelaySeconds"))
                        if (!$util.isInteger(message.dissolveDelaySeconds) && !(message.dissolveDelaySeconds && $util.isInteger(message.dissolveDelaySeconds.low) && $util.isInteger(message.dissolveDelaySeconds.high)))
                            return "dissolveDelaySeconds: integer|Long expected";
                    if (message.recentBallots != null && message.hasOwnProperty("recentBallots")) {
                        if (!Array.isArray(message.recentBallots))
                            return "recentBallots: array expected";
                        for (let i = 0; i < message.recentBallots.length; ++i) {
                            let error = $root.ic_nns_governance.pb.v1.BallotInfo.verify(message.recentBallots[i]);
                            if (error)
                                return "recentBallots." + error;
                        }
                    }
                    if (message.votingPower != null && message.hasOwnProperty("votingPower"))
                        if (!$util.isInteger(message.votingPower) && !(message.votingPower && $util.isInteger(message.votingPower.low) && $util.isInteger(message.votingPower.high)))
                            return "votingPower: integer|Long expected";
                    if (message.createdTimestampSeconds != null && message.hasOwnProperty("createdTimestampSeconds"))
                        if (!$util.isInteger(message.createdTimestampSeconds) && !(message.createdTimestampSeconds && $util.isInteger(message.createdTimestampSeconds.low) && $util.isInteger(message.createdTimestampSeconds.high)))
                            return "createdTimestampSeconds: integer|Long expected";
                    if (message.stakeE8s != null && message.hasOwnProperty("stakeE8s"))
                        if (!$util.isInteger(message.stakeE8s) && !(message.stakeE8s && $util.isInteger(message.stakeE8s.low) && $util.isInteger(message.stakeE8s.high)))
                            return "stakeE8s: integer|Long expected";
                    if (message.joinedCommunityFundTimestampSeconds != null && message.hasOwnProperty("joinedCommunityFundTimestampSeconds")) {
                        properties._joinedCommunityFundTimestampSeconds = 1;
                        if (!$util.isInteger(message.joinedCommunityFundTimestampSeconds) && !(message.joinedCommunityFundTimestampSeconds && $util.isInteger(message.joinedCommunityFundTimestampSeconds.low) && $util.isInteger(message.joinedCommunityFundTimestampSeconds.high)))
                            return "joinedCommunityFundTimestampSeconds: integer|Long expected";
                    }
                    return null;
                };

                /**
                 * Creates a NeuronInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.NeuronInfo} NeuronInfo
                 */
                NeuronInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.NeuronInfo)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.NeuronInfo();
                    if (object.retrievedAtTimestampSeconds != null)
                        if ($util.Long)
                            (message.retrievedAtTimestampSeconds = $util.Long.fromValue(object.retrievedAtTimestampSeconds)).unsigned = true;
                        else if (typeof object.retrievedAtTimestampSeconds === "string")
                            message.retrievedAtTimestampSeconds = parseInt(object.retrievedAtTimestampSeconds, 10);
                        else if (typeof object.retrievedAtTimestampSeconds === "number")
                            message.retrievedAtTimestampSeconds = object.retrievedAtTimestampSeconds;
                        else if (typeof object.retrievedAtTimestampSeconds === "object")
                            message.retrievedAtTimestampSeconds = new $util.LongBits(object.retrievedAtTimestampSeconds.low >>> 0, object.retrievedAtTimestampSeconds.high >>> 0).toNumber(true);
                    switch (object.state) {
                    case "NEURON_STATE_UNSPECIFIED":
                    case 0:
                        message.state = 0;
                        break;
                    case "NEURON_STATE_NOT_DISSOLVING":
                    case 1:
                        message.state = 1;
                        break;
                    case "NEURON_STATE_DISSOLVING":
                    case 2:
                        message.state = 2;
                        break;
                    case "NEURON_STATE_DISSOLVED":
                    case 3:
                        message.state = 3;
                        break;
                    }
                    if (object.ageSeconds != null)
                        if ($util.Long)
                            (message.ageSeconds = $util.Long.fromValue(object.ageSeconds)).unsigned = true;
                        else if (typeof object.ageSeconds === "string")
                            message.ageSeconds = parseInt(object.ageSeconds, 10);
                        else if (typeof object.ageSeconds === "number")
                            message.ageSeconds = object.ageSeconds;
                        else if (typeof object.ageSeconds === "object")
                            message.ageSeconds = new $util.LongBits(object.ageSeconds.low >>> 0, object.ageSeconds.high >>> 0).toNumber(true);
                    if (object.dissolveDelaySeconds != null)
                        if ($util.Long)
                            (message.dissolveDelaySeconds = $util.Long.fromValue(object.dissolveDelaySeconds)).unsigned = true;
                        else if (typeof object.dissolveDelaySeconds === "string")
                            message.dissolveDelaySeconds = parseInt(object.dissolveDelaySeconds, 10);
                        else if (typeof object.dissolveDelaySeconds === "number")
                            message.dissolveDelaySeconds = object.dissolveDelaySeconds;
                        else if (typeof object.dissolveDelaySeconds === "object")
                            message.dissolveDelaySeconds = new $util.LongBits(object.dissolveDelaySeconds.low >>> 0, object.dissolveDelaySeconds.high >>> 0).toNumber(true);
                    if (object.recentBallots) {
                        if (!Array.isArray(object.recentBallots))
                            throw TypeError(".ic_nns_governance.pb.v1.NeuronInfo.recentBallots: array expected");
                        message.recentBallots = [];
                        for (let i = 0; i < object.recentBallots.length; ++i) {
                            if (typeof object.recentBallots[i] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.NeuronInfo.recentBallots: object expected");
                            message.recentBallots[i] = $root.ic_nns_governance.pb.v1.BallotInfo.fromObject(object.recentBallots[i]);
                        }
                    }
                    if (object.votingPower != null)
                        if ($util.Long)
                            (message.votingPower = $util.Long.fromValue(object.votingPower)).unsigned = true;
                        else if (typeof object.votingPower === "string")
                            message.votingPower = parseInt(object.votingPower, 10);
                        else if (typeof object.votingPower === "number")
                            message.votingPower = object.votingPower;
                        else if (typeof object.votingPower === "object")
                            message.votingPower = new $util.LongBits(object.votingPower.low >>> 0, object.votingPower.high >>> 0).toNumber(true);
                    if (object.createdTimestampSeconds != null)
                        if ($util.Long)
                            (message.createdTimestampSeconds = $util.Long.fromValue(object.createdTimestampSeconds)).unsigned = true;
                        else if (typeof object.createdTimestampSeconds === "string")
                            message.createdTimestampSeconds = parseInt(object.createdTimestampSeconds, 10);
                        else if (typeof object.createdTimestampSeconds === "number")
                            message.createdTimestampSeconds = object.createdTimestampSeconds;
                        else if (typeof object.createdTimestampSeconds === "object")
                            message.createdTimestampSeconds = new $util.LongBits(object.createdTimestampSeconds.low >>> 0, object.createdTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.stakeE8s != null)
                        if ($util.Long)
                            (message.stakeE8s = $util.Long.fromValue(object.stakeE8s)).unsigned = true;
                        else if (typeof object.stakeE8s === "string")
                            message.stakeE8s = parseInt(object.stakeE8s, 10);
                        else if (typeof object.stakeE8s === "number")
                            message.stakeE8s = object.stakeE8s;
                        else if (typeof object.stakeE8s === "object")
                            message.stakeE8s = new $util.LongBits(object.stakeE8s.low >>> 0, object.stakeE8s.high >>> 0).toNumber(true);
                    if (object.joinedCommunityFundTimestampSeconds != null)
                        if ($util.Long)
                            (message.joinedCommunityFundTimestampSeconds = $util.Long.fromValue(object.joinedCommunityFundTimestampSeconds)).unsigned = true;
                        else if (typeof object.joinedCommunityFundTimestampSeconds === "string")
                            message.joinedCommunityFundTimestampSeconds = parseInt(object.joinedCommunityFundTimestampSeconds, 10);
                        else if (typeof object.joinedCommunityFundTimestampSeconds === "number")
                            message.joinedCommunityFundTimestampSeconds = object.joinedCommunityFundTimestampSeconds;
                        else if (typeof object.joinedCommunityFundTimestampSeconds === "object")
                            message.joinedCommunityFundTimestampSeconds = new $util.LongBits(object.joinedCommunityFundTimestampSeconds.low >>> 0, object.joinedCommunityFundTimestampSeconds.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a NeuronInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.NeuronInfo} message NeuronInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NeuronInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.recentBallots = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.retrievedAtTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.retrievedAtTimestampSeconds = options.longs === String ? "0" : 0;
                        object.state = options.enums === String ? "NEURON_STATE_UNSPECIFIED" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.ageSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.ageSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.dissolveDelaySeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.dissolveDelaySeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.votingPower = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.votingPower = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.createdTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.createdTimestampSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.stakeE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.stakeE8s = options.longs === String ? "0" : 0;
                    }
                    if (message.retrievedAtTimestampSeconds != null && message.hasOwnProperty("retrievedAtTimestampSeconds"))
                        if (typeof message.retrievedAtTimestampSeconds === "number")
                            object.retrievedAtTimestampSeconds = options.longs === String ? String(message.retrievedAtTimestampSeconds) : message.retrievedAtTimestampSeconds;
                        else
                            object.retrievedAtTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.retrievedAtTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.retrievedAtTimestampSeconds.low >>> 0, message.retrievedAtTimestampSeconds.high >>> 0).toNumber(true) : message.retrievedAtTimestampSeconds;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.ic_nns_governance.pb.v1.NeuronState[message.state] : message.state;
                    if (message.ageSeconds != null && message.hasOwnProperty("ageSeconds"))
                        if (typeof message.ageSeconds === "number")
                            object.ageSeconds = options.longs === String ? String(message.ageSeconds) : message.ageSeconds;
                        else
                            object.ageSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.ageSeconds) : options.longs === Number ? new $util.LongBits(message.ageSeconds.low >>> 0, message.ageSeconds.high >>> 0).toNumber(true) : message.ageSeconds;
                    if (message.dissolveDelaySeconds != null && message.hasOwnProperty("dissolveDelaySeconds"))
                        if (typeof message.dissolveDelaySeconds === "number")
                            object.dissolveDelaySeconds = options.longs === String ? String(message.dissolveDelaySeconds) : message.dissolveDelaySeconds;
                        else
                            object.dissolveDelaySeconds = options.longs === String ? $util.Long.prototype.toString.call(message.dissolveDelaySeconds) : options.longs === Number ? new $util.LongBits(message.dissolveDelaySeconds.low >>> 0, message.dissolveDelaySeconds.high >>> 0).toNumber(true) : message.dissolveDelaySeconds;
                    if (message.recentBallots && message.recentBallots.length) {
                        object.recentBallots = [];
                        for (let j = 0; j < message.recentBallots.length; ++j)
                            object.recentBallots[j] = $root.ic_nns_governance.pb.v1.BallotInfo.toObject(message.recentBallots[j], options);
                    }
                    if (message.votingPower != null && message.hasOwnProperty("votingPower"))
                        if (typeof message.votingPower === "number")
                            object.votingPower = options.longs === String ? String(message.votingPower) : message.votingPower;
                        else
                            object.votingPower = options.longs === String ? $util.Long.prototype.toString.call(message.votingPower) : options.longs === Number ? new $util.LongBits(message.votingPower.low >>> 0, message.votingPower.high >>> 0).toNumber(true) : message.votingPower;
                    if (message.createdTimestampSeconds != null && message.hasOwnProperty("createdTimestampSeconds"))
                        if (typeof message.createdTimestampSeconds === "number")
                            object.createdTimestampSeconds = options.longs === String ? String(message.createdTimestampSeconds) : message.createdTimestampSeconds;
                        else
                            object.createdTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.createdTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.createdTimestampSeconds.low >>> 0, message.createdTimestampSeconds.high >>> 0).toNumber(true) : message.createdTimestampSeconds;
                    if (message.stakeE8s != null && message.hasOwnProperty("stakeE8s"))
                        if (typeof message.stakeE8s === "number")
                            object.stakeE8s = options.longs === String ? String(message.stakeE8s) : message.stakeE8s;
                        else
                            object.stakeE8s = options.longs === String ? $util.Long.prototype.toString.call(message.stakeE8s) : options.longs === Number ? new $util.LongBits(message.stakeE8s.low >>> 0, message.stakeE8s.high >>> 0).toNumber(true) : message.stakeE8s;
                    if (message.joinedCommunityFundTimestampSeconds != null && message.hasOwnProperty("joinedCommunityFundTimestampSeconds")) {
                        if (typeof message.joinedCommunityFundTimestampSeconds === "number")
                            object.joinedCommunityFundTimestampSeconds = options.longs === String ? String(message.joinedCommunityFundTimestampSeconds) : message.joinedCommunityFundTimestampSeconds;
                        else
                            object.joinedCommunityFundTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.joinedCommunityFundTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.joinedCommunityFundTimestampSeconds.low >>> 0, message.joinedCommunityFundTimestampSeconds.high >>> 0).toNumber(true) : message.joinedCommunityFundTimestampSeconds;
                        if (options.oneofs)
                            object._joinedCommunityFundTimestampSeconds = "joinedCommunityFundTimestampSeconds";
                    }
                    return object;
                };

                /**
                 * Converts this NeuronInfo to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.NeuronInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NeuronInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NeuronInfo;
            })();

            v1.NeuronStakeTransfer = (function() {

                /**
                 * Properties of a NeuronStakeTransfer.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface INeuronStakeTransfer
                 * @property {number|Long|null} [transferTimestamp] NeuronStakeTransfer transferTimestamp
                 * @property {ic_base_types.pb.v1.IPrincipalId|null} [from] NeuronStakeTransfer from
                 * @property {Uint8Array|null} [fromSubaccount] NeuronStakeTransfer fromSubaccount
                 * @property {Uint8Array|null} [toSubaccount] NeuronStakeTransfer toSubaccount
                 * @property {number|Long|null} [neuronStakeE8s] NeuronStakeTransfer neuronStakeE8s
                 * @property {number|Long|null} [blockHeight] NeuronStakeTransfer blockHeight
                 * @property {number|Long|null} [memo] NeuronStakeTransfer memo
                 */

                /**
                 * Constructs a new NeuronStakeTransfer.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a NeuronStakeTransfer.
                 * @implements INeuronStakeTransfer
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.INeuronStakeTransfer=} [properties] Properties to set
                 */
                function NeuronStakeTransfer(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NeuronStakeTransfer transferTimestamp.
                 * @member {number|Long} transferTimestamp
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @instance
                 */
                NeuronStakeTransfer.prototype.transferTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NeuronStakeTransfer from.
                 * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} from
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @instance
                 */
                NeuronStakeTransfer.prototype.from = null;

                /**
                 * NeuronStakeTransfer fromSubaccount.
                 * @member {Uint8Array} fromSubaccount
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @instance
                 */
                NeuronStakeTransfer.prototype.fromSubaccount = $util.newBuffer([]);

                /**
                 * NeuronStakeTransfer toSubaccount.
                 * @member {Uint8Array} toSubaccount
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @instance
                 */
                NeuronStakeTransfer.prototype.toSubaccount = $util.newBuffer([]);

                /**
                 * NeuronStakeTransfer neuronStakeE8s.
                 * @member {number|Long} neuronStakeE8s
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @instance
                 */
                NeuronStakeTransfer.prototype.neuronStakeE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NeuronStakeTransfer blockHeight.
                 * @member {number|Long} blockHeight
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @instance
                 */
                NeuronStakeTransfer.prototype.blockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NeuronStakeTransfer memo.
                 * @member {number|Long} memo
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @instance
                 */
                NeuronStakeTransfer.prototype.memo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new NeuronStakeTransfer instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @static
                 * @param {ic_nns_governance.pb.v1.INeuronStakeTransfer=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.NeuronStakeTransfer} NeuronStakeTransfer instance
                 */
                NeuronStakeTransfer.create = function create(properties) {
                    return new NeuronStakeTransfer(properties);
                };

                /**
                 * Encodes the specified NeuronStakeTransfer message. Does not implicitly {@link ic_nns_governance.pb.v1.NeuronStakeTransfer.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @static
                 * @param {ic_nns_governance.pb.v1.INeuronStakeTransfer} message NeuronStakeTransfer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuronStakeTransfer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transferTimestamp != null && Object.hasOwnProperty.call(message, "transferTimestamp"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.transferTimestamp);
                    if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                        $root.ic_base_types.pb.v1.PrincipalId.encode(message.from, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.fromSubaccount != null && Object.hasOwnProperty.call(message, "fromSubaccount"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fromSubaccount);
                    if (message.toSubaccount != null && Object.hasOwnProperty.call(message, "toSubaccount"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.toSubaccount);
                    if (message.neuronStakeE8s != null && Object.hasOwnProperty.call(message, "neuronStakeE8s"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.neuronStakeE8s);
                    if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.blockHeight);
                    if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.memo);
                    return writer;
                };

                /**
                 * Encodes the specified NeuronStakeTransfer message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.NeuronStakeTransfer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @static
                 * @param {ic_nns_governance.pb.v1.INeuronStakeTransfer} message NeuronStakeTransfer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuronStakeTransfer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NeuronStakeTransfer message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.NeuronStakeTransfer} NeuronStakeTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuronStakeTransfer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.NeuronStakeTransfer();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.transferTimestamp = reader.uint64();
                            break;
                        case 2:
                            message.from = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.fromSubaccount = reader.bytes();
                            break;
                        case 4:
                            message.toSubaccount = reader.bytes();
                            break;
                        case 5:
                            message.neuronStakeE8s = reader.uint64();
                            break;
                        case 6:
                            message.blockHeight = reader.uint64();
                            break;
                        case 7:
                            message.memo = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NeuronStakeTransfer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.NeuronStakeTransfer} NeuronStakeTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuronStakeTransfer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NeuronStakeTransfer message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NeuronStakeTransfer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transferTimestamp != null && message.hasOwnProperty("transferTimestamp"))
                        if (!$util.isInteger(message.transferTimestamp) && !(message.transferTimestamp && $util.isInteger(message.transferTimestamp.low) && $util.isInteger(message.transferTimestamp.high)))
                            return "transferTimestamp: integer|Long expected";
                    if (message.from != null && message.hasOwnProperty("from")) {
                        let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.from);
                        if (error)
                            return "from." + error;
                    }
                    if (message.fromSubaccount != null && message.hasOwnProperty("fromSubaccount"))
                        if (!(message.fromSubaccount && typeof message.fromSubaccount.length === "number" || $util.isString(message.fromSubaccount)))
                            return "fromSubaccount: buffer expected";
                    if (message.toSubaccount != null && message.hasOwnProperty("toSubaccount"))
                        if (!(message.toSubaccount && typeof message.toSubaccount.length === "number" || $util.isString(message.toSubaccount)))
                            return "toSubaccount: buffer expected";
                    if (message.neuronStakeE8s != null && message.hasOwnProperty("neuronStakeE8s"))
                        if (!$util.isInteger(message.neuronStakeE8s) && !(message.neuronStakeE8s && $util.isInteger(message.neuronStakeE8s.low) && $util.isInteger(message.neuronStakeE8s.high)))
                            return "neuronStakeE8s: integer|Long expected";
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                        if (!$util.isInteger(message.blockHeight) && !(message.blockHeight && $util.isInteger(message.blockHeight.low) && $util.isInteger(message.blockHeight.high)))
                            return "blockHeight: integer|Long expected";
                    if (message.memo != null && message.hasOwnProperty("memo"))
                        if (!$util.isInteger(message.memo) && !(message.memo && $util.isInteger(message.memo.low) && $util.isInteger(message.memo.high)))
                            return "memo: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a NeuronStakeTransfer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.NeuronStakeTransfer} NeuronStakeTransfer
                 */
                NeuronStakeTransfer.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.NeuronStakeTransfer)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.NeuronStakeTransfer();
                    if (object.transferTimestamp != null)
                        if ($util.Long)
                            (message.transferTimestamp = $util.Long.fromValue(object.transferTimestamp)).unsigned = true;
                        else if (typeof object.transferTimestamp === "string")
                            message.transferTimestamp = parseInt(object.transferTimestamp, 10);
                        else if (typeof object.transferTimestamp === "number")
                            message.transferTimestamp = object.transferTimestamp;
                        else if (typeof object.transferTimestamp === "object")
                            message.transferTimestamp = new $util.LongBits(object.transferTimestamp.low >>> 0, object.transferTimestamp.high >>> 0).toNumber(true);
                    if (object.from != null) {
                        if (typeof object.from !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.NeuronStakeTransfer.from: object expected");
                        message.from = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.from);
                    }
                    if (object.fromSubaccount != null)
                        if (typeof object.fromSubaccount === "string")
                            $util.base64.decode(object.fromSubaccount, message.fromSubaccount = $util.newBuffer($util.base64.length(object.fromSubaccount)), 0);
                        else if (object.fromSubaccount.length)
                            message.fromSubaccount = object.fromSubaccount;
                    if (object.toSubaccount != null)
                        if (typeof object.toSubaccount === "string")
                            $util.base64.decode(object.toSubaccount, message.toSubaccount = $util.newBuffer($util.base64.length(object.toSubaccount)), 0);
                        else if (object.toSubaccount.length)
                            message.toSubaccount = object.toSubaccount;
                    if (object.neuronStakeE8s != null)
                        if ($util.Long)
                            (message.neuronStakeE8s = $util.Long.fromValue(object.neuronStakeE8s)).unsigned = true;
                        else if (typeof object.neuronStakeE8s === "string")
                            message.neuronStakeE8s = parseInt(object.neuronStakeE8s, 10);
                        else if (typeof object.neuronStakeE8s === "number")
                            message.neuronStakeE8s = object.neuronStakeE8s;
                        else if (typeof object.neuronStakeE8s === "object")
                            message.neuronStakeE8s = new $util.LongBits(object.neuronStakeE8s.low >>> 0, object.neuronStakeE8s.high >>> 0).toNumber(true);
                    if (object.blockHeight != null)
                        if ($util.Long)
                            (message.blockHeight = $util.Long.fromValue(object.blockHeight)).unsigned = true;
                        else if (typeof object.blockHeight === "string")
                            message.blockHeight = parseInt(object.blockHeight, 10);
                        else if (typeof object.blockHeight === "number")
                            message.blockHeight = object.blockHeight;
                        else if (typeof object.blockHeight === "object")
                            message.blockHeight = new $util.LongBits(object.blockHeight.low >>> 0, object.blockHeight.high >>> 0).toNumber(true);
                    if (object.memo != null)
                        if ($util.Long)
                            (message.memo = $util.Long.fromValue(object.memo)).unsigned = true;
                        else if (typeof object.memo === "string")
                            message.memo = parseInt(object.memo, 10);
                        else if (typeof object.memo === "number")
                            message.memo = object.memo;
                        else if (typeof object.memo === "object")
                            message.memo = new $util.LongBits(object.memo.low >>> 0, object.memo.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a NeuronStakeTransfer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @static
                 * @param {ic_nns_governance.pb.v1.NeuronStakeTransfer} message NeuronStakeTransfer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NeuronStakeTransfer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.transferTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.transferTimestamp = options.longs === String ? "0" : 0;
                        object.from = null;
                        if (options.bytes === String)
                            object.fromSubaccount = "";
                        else {
                            object.fromSubaccount = [];
                            if (options.bytes !== Array)
                                object.fromSubaccount = $util.newBuffer(object.fromSubaccount);
                        }
                        if (options.bytes === String)
                            object.toSubaccount = "";
                        else {
                            object.toSubaccount = [];
                            if (options.bytes !== Array)
                                object.toSubaccount = $util.newBuffer(object.toSubaccount);
                        }
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.neuronStakeE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.neuronStakeE8s = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.blockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.blockHeight = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.memo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.memo = options.longs === String ? "0" : 0;
                    }
                    if (message.transferTimestamp != null && message.hasOwnProperty("transferTimestamp"))
                        if (typeof message.transferTimestamp === "number")
                            object.transferTimestamp = options.longs === String ? String(message.transferTimestamp) : message.transferTimestamp;
                        else
                            object.transferTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.transferTimestamp) : options.longs === Number ? new $util.LongBits(message.transferTimestamp.low >>> 0, message.transferTimestamp.high >>> 0).toNumber(true) : message.transferTimestamp;
                    if (message.from != null && message.hasOwnProperty("from"))
                        object.from = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.from, options);
                    if (message.fromSubaccount != null && message.hasOwnProperty("fromSubaccount"))
                        object.fromSubaccount = options.bytes === String ? $util.base64.encode(message.fromSubaccount, 0, message.fromSubaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.fromSubaccount) : message.fromSubaccount;
                    if (message.toSubaccount != null && message.hasOwnProperty("toSubaccount"))
                        object.toSubaccount = options.bytes === String ? $util.base64.encode(message.toSubaccount, 0, message.toSubaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.toSubaccount) : message.toSubaccount;
                    if (message.neuronStakeE8s != null && message.hasOwnProperty("neuronStakeE8s"))
                        if (typeof message.neuronStakeE8s === "number")
                            object.neuronStakeE8s = options.longs === String ? String(message.neuronStakeE8s) : message.neuronStakeE8s;
                        else
                            object.neuronStakeE8s = options.longs === String ? $util.Long.prototype.toString.call(message.neuronStakeE8s) : options.longs === Number ? new $util.LongBits(message.neuronStakeE8s.low >>> 0, message.neuronStakeE8s.high >>> 0).toNumber(true) : message.neuronStakeE8s;
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                        if (typeof message.blockHeight === "number")
                            object.blockHeight = options.longs === String ? String(message.blockHeight) : message.blockHeight;
                        else
                            object.blockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.blockHeight) : options.longs === Number ? new $util.LongBits(message.blockHeight.low >>> 0, message.blockHeight.high >>> 0).toNumber(true) : message.blockHeight;
                    if (message.memo != null && message.hasOwnProperty("memo"))
                        if (typeof message.memo === "number")
                            object.memo = options.longs === String ? String(message.memo) : message.memo;
                        else
                            object.memo = options.longs === String ? $util.Long.prototype.toString.call(message.memo) : options.longs === Number ? new $util.LongBits(message.memo.low >>> 0, message.memo.high >>> 0).toNumber(true) : message.memo;
                    return object;
                };

                /**
                 * Converts this NeuronStakeTransfer to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.NeuronStakeTransfer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NeuronStakeTransfer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NeuronStakeTransfer;
            })();

            v1.Neuron = (function() {

                /**
                 * Properties of a Neuron.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface INeuron
                 * @property {ic_nns_common.pb.v1.INeuronId|null} [id] Neuron id
                 * @property {Uint8Array|null} [account] Neuron account
                 * @property {ic_base_types.pb.v1.IPrincipalId|null} [controller] Neuron controller
                 * @property {Array.<ic_base_types.pb.v1.IPrincipalId>|null} [hotKeys] Neuron hotKeys
                 * @property {number|Long|null} [cachedNeuronStakeE8s] Neuron cachedNeuronStakeE8s
                 * @property {number|Long|null} [neuronFeesE8s] Neuron neuronFeesE8s
                 * @property {number|Long|null} [createdTimestampSeconds] Neuron createdTimestampSeconds
                 * @property {number|Long|null} [agingSinceTimestampSeconds] Neuron agingSinceTimestampSeconds
                 * @property {number|Long|null} [whenDissolvedTimestampSeconds] Neuron whenDissolvedTimestampSeconds
                 * @property {number|Long|null} [dissolveDelaySeconds] Neuron dissolveDelaySeconds
                 * @property {Object.<string,ic_nns_governance.pb.v1.Neuron.IFollowees>|null} [followees] Neuron followees
                 * @property {Array.<ic_nns_governance.pb.v1.IBallotInfo>|null} [recentBallots] Neuron recentBallots
                 * @property {boolean|null} [kycVerified] Neuron kycVerified
                 * @property {ic_nns_governance.pb.v1.INeuronStakeTransfer|null} [transfer] Neuron transfer
                 * @property {number|Long|null} [maturityE8sEquivalent] Neuron maturityE8sEquivalent
                 * @property {boolean|null} [notForProfit] Neuron notForProfit
                 * @property {number|Long|null} [joinedCommunityFundTimestampSeconds] Neuron joinedCommunityFundTimestampSeconds
                 */

                /**
                 * Constructs a new Neuron.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a Neuron.
                 * @implements INeuron
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.INeuron=} [properties] Properties to set
                 */
                function Neuron(properties) {
                    this.hotKeys = [];
                    this.followees = {};
                    this.recentBallots = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Neuron id.
                 * @member {ic_nns_common.pb.v1.INeuronId|null|undefined} id
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.id = null;

                /**
                 * Neuron account.
                 * @member {Uint8Array} account
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.account = $util.newBuffer([]);

                /**
                 * Neuron controller.
                 * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} controller
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.controller = null;

                /**
                 * Neuron hotKeys.
                 * @member {Array.<ic_base_types.pb.v1.IPrincipalId>} hotKeys
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.hotKeys = $util.emptyArray;

                /**
                 * Neuron cachedNeuronStakeE8s.
                 * @member {number|Long} cachedNeuronStakeE8s
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.cachedNeuronStakeE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Neuron neuronFeesE8s.
                 * @member {number|Long} neuronFeesE8s
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.neuronFeesE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Neuron createdTimestampSeconds.
                 * @member {number|Long} createdTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.createdTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Neuron agingSinceTimestampSeconds.
                 * @member {number|Long} agingSinceTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.agingSinceTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Neuron whenDissolvedTimestampSeconds.
                 * @member {number|Long|null|undefined} whenDissolvedTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.whenDissolvedTimestampSeconds = null;

                /**
                 * Neuron dissolveDelaySeconds.
                 * @member {number|Long|null|undefined} dissolveDelaySeconds
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.dissolveDelaySeconds = null;

                /**
                 * Neuron followees.
                 * @member {Object.<string,ic_nns_governance.pb.v1.Neuron.IFollowees>} followees
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.followees = $util.emptyObject;

                /**
                 * Neuron recentBallots.
                 * @member {Array.<ic_nns_governance.pb.v1.IBallotInfo>} recentBallots
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.recentBallots = $util.emptyArray;

                /**
                 * Neuron kycVerified.
                 * @member {boolean} kycVerified
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.kycVerified = false;

                /**
                 * Neuron transfer.
                 * @member {ic_nns_governance.pb.v1.INeuronStakeTransfer|null|undefined} transfer
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.transfer = null;

                /**
                 * Neuron maturityE8sEquivalent.
                 * @member {number|Long} maturityE8sEquivalent
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.maturityE8sEquivalent = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Neuron notForProfit.
                 * @member {boolean} notForProfit
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.notForProfit = false;

                /**
                 * Neuron joinedCommunityFundTimestampSeconds.
                 * @member {number|Long|null|undefined} joinedCommunityFundTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Neuron.prototype.joinedCommunityFundTimestampSeconds = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Neuron dissolveState.
                 * @member {"whenDissolvedTimestampSeconds"|"dissolveDelaySeconds"|undefined} dissolveState
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Object.defineProperty(Neuron.prototype, "dissolveState", {
                    get: $util.oneOfGetter($oneOfFields = ["whenDissolvedTimestampSeconds", "dissolveDelaySeconds"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Neuron _joinedCommunityFundTimestampSeconds.
                 * @member {"joinedCommunityFundTimestampSeconds"|undefined} _joinedCommunityFundTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 */
                Object.defineProperty(Neuron.prototype, "_joinedCommunityFundTimestampSeconds", {
                    get: $util.oneOfGetter($oneOfFields = ["joinedCommunityFundTimestampSeconds"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Neuron instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @static
                 * @param {ic_nns_governance.pb.v1.INeuron=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.Neuron} Neuron instance
                 */
                Neuron.create = function create(properties) {
                    return new Neuron(properties);
                };

                /**
                 * Encodes the specified Neuron message. Does not implicitly {@link ic_nns_governance.pb.v1.Neuron.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @static
                 * @param {ic_nns_governance.pb.v1.INeuron} message Neuron message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Neuron.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        $root.ic_nns_common.pb.v1.NeuronId.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.account);
                    if (message.controller != null && Object.hasOwnProperty.call(message, "controller"))
                        $root.ic_base_types.pb.v1.PrincipalId.encode(message.controller, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.hotKeys != null && message.hotKeys.length)
                        for (let i = 0; i < message.hotKeys.length; ++i)
                            $root.ic_base_types.pb.v1.PrincipalId.encode(message.hotKeys[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.cachedNeuronStakeE8s != null && Object.hasOwnProperty.call(message, "cachedNeuronStakeE8s"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.cachedNeuronStakeE8s);
                    if (message.neuronFeesE8s != null && Object.hasOwnProperty.call(message, "neuronFeesE8s"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.neuronFeesE8s);
                    if (message.createdTimestampSeconds != null && Object.hasOwnProperty.call(message, "createdTimestampSeconds"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.createdTimestampSeconds);
                    if (message.agingSinceTimestampSeconds != null && Object.hasOwnProperty.call(message, "agingSinceTimestampSeconds"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.agingSinceTimestampSeconds);
                    if (message.whenDissolvedTimestampSeconds != null && Object.hasOwnProperty.call(message, "whenDissolvedTimestampSeconds"))
                        writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.whenDissolvedTimestampSeconds);
                    if (message.dissolveDelaySeconds != null && Object.hasOwnProperty.call(message, "dissolveDelaySeconds"))
                        writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.dissolveDelaySeconds);
                    if (message.followees != null && Object.hasOwnProperty.call(message, "followees"))
                        for (let keys = Object.keys(message.followees), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 11, wireType 2 =*/90).fork().uint32(/* id 1, wireType 0 =*/8).int32(keys[i]);
                            $root.ic_nns_governance.pb.v1.Neuron.Followees.encode(message.followees[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.recentBallots != null && message.recentBallots.length)
                        for (let i = 0; i < message.recentBallots.length; ++i)
                            $root.ic_nns_governance.pb.v1.BallotInfo.encode(message.recentBallots[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.kycVerified != null && Object.hasOwnProperty.call(message, "kycVerified"))
                        writer.uint32(/* id 13, wireType 0 =*/104).bool(message.kycVerified);
                    if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                        $root.ic_nns_governance.pb.v1.NeuronStakeTransfer.encode(message.transfer, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.maturityE8sEquivalent != null && Object.hasOwnProperty.call(message, "maturityE8sEquivalent"))
                        writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.maturityE8sEquivalent);
                    if (message.notForProfit != null && Object.hasOwnProperty.call(message, "notForProfit"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.notForProfit);
                    if (message.joinedCommunityFundTimestampSeconds != null && Object.hasOwnProperty.call(message, "joinedCommunityFundTimestampSeconds"))
                        writer.uint32(/* id 17, wireType 0 =*/136).uint64(message.joinedCommunityFundTimestampSeconds);
                    return writer;
                };

                /**
                 * Encodes the specified Neuron message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.Neuron.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @static
                 * @param {ic_nns_governance.pb.v1.INeuron} message Neuron message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Neuron.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Neuron message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.Neuron} Neuron
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Neuron.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.Neuron(), key, value;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.account = reader.bytes();
                            break;
                        case 3:
                            message.controller = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.hotKeys && message.hotKeys.length))
                                message.hotKeys = [];
                            message.hotKeys.push($root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            message.cachedNeuronStakeE8s = reader.uint64();
                            break;
                        case 6:
                            message.neuronFeesE8s = reader.uint64();
                            break;
                        case 7:
                            message.createdTimestampSeconds = reader.uint64();
                            break;
                        case 8:
                            message.agingSinceTimestampSeconds = reader.uint64();
                            break;
                        case 9:
                            message.whenDissolvedTimestampSeconds = reader.uint64();
                            break;
                        case 10:
                            message.dissolveDelaySeconds = reader.uint64();
                            break;
                        case 11:
                            if (message.followees === $util.emptyObject)
                                message.followees = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.int32();
                                    break;
                                case 2:
                                    value = $root.ic_nns_governance.pb.v1.Neuron.Followees.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.followees[key] = value;
                            break;
                        case 12:
                            if (!(message.recentBallots && message.recentBallots.length))
                                message.recentBallots = [];
                            message.recentBallots.push($root.ic_nns_governance.pb.v1.BallotInfo.decode(reader, reader.uint32()));
                            break;
                        case 13:
                            message.kycVerified = reader.bool();
                            break;
                        case 14:
                            message.transfer = $root.ic_nns_governance.pb.v1.NeuronStakeTransfer.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.maturityE8sEquivalent = reader.uint64();
                            break;
                        case 16:
                            message.notForProfit = reader.bool();
                            break;
                        case 17:
                            message.joinedCommunityFundTimestampSeconds = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Neuron message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.Neuron} Neuron
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Neuron.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Neuron message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Neuron.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.id != null && message.hasOwnProperty("id")) {
                        let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.account != null && message.hasOwnProperty("account"))
                        if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                            return "account: buffer expected";
                    if (message.controller != null && message.hasOwnProperty("controller")) {
                        let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.controller);
                        if (error)
                            return "controller." + error;
                    }
                    if (message.hotKeys != null && message.hasOwnProperty("hotKeys")) {
                        if (!Array.isArray(message.hotKeys))
                            return "hotKeys: array expected";
                        for (let i = 0; i < message.hotKeys.length; ++i) {
                            let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.hotKeys[i]);
                            if (error)
                                return "hotKeys." + error;
                        }
                    }
                    if (message.cachedNeuronStakeE8s != null && message.hasOwnProperty("cachedNeuronStakeE8s"))
                        if (!$util.isInteger(message.cachedNeuronStakeE8s) && !(message.cachedNeuronStakeE8s && $util.isInteger(message.cachedNeuronStakeE8s.low) && $util.isInteger(message.cachedNeuronStakeE8s.high)))
                            return "cachedNeuronStakeE8s: integer|Long expected";
                    if (message.neuronFeesE8s != null && message.hasOwnProperty("neuronFeesE8s"))
                        if (!$util.isInteger(message.neuronFeesE8s) && !(message.neuronFeesE8s && $util.isInteger(message.neuronFeesE8s.low) && $util.isInteger(message.neuronFeesE8s.high)))
                            return "neuronFeesE8s: integer|Long expected";
                    if (message.createdTimestampSeconds != null && message.hasOwnProperty("createdTimestampSeconds"))
                        if (!$util.isInteger(message.createdTimestampSeconds) && !(message.createdTimestampSeconds && $util.isInteger(message.createdTimestampSeconds.low) && $util.isInteger(message.createdTimestampSeconds.high)))
                            return "createdTimestampSeconds: integer|Long expected";
                    if (message.agingSinceTimestampSeconds != null && message.hasOwnProperty("agingSinceTimestampSeconds"))
                        if (!$util.isInteger(message.agingSinceTimestampSeconds) && !(message.agingSinceTimestampSeconds && $util.isInteger(message.agingSinceTimestampSeconds.low) && $util.isInteger(message.agingSinceTimestampSeconds.high)))
                            return "agingSinceTimestampSeconds: integer|Long expected";
                    if (message.whenDissolvedTimestampSeconds != null && message.hasOwnProperty("whenDissolvedTimestampSeconds")) {
                        properties.dissolveState = 1;
                        if (!$util.isInteger(message.whenDissolvedTimestampSeconds) && !(message.whenDissolvedTimestampSeconds && $util.isInteger(message.whenDissolvedTimestampSeconds.low) && $util.isInteger(message.whenDissolvedTimestampSeconds.high)))
                            return "whenDissolvedTimestampSeconds: integer|Long expected";
                    }
                    if (message.dissolveDelaySeconds != null && message.hasOwnProperty("dissolveDelaySeconds")) {
                        if (properties.dissolveState === 1)
                            return "dissolveState: multiple values";
                        properties.dissolveState = 1;
                        if (!$util.isInteger(message.dissolveDelaySeconds) && !(message.dissolveDelaySeconds && $util.isInteger(message.dissolveDelaySeconds.low) && $util.isInteger(message.dissolveDelaySeconds.high)))
                            return "dissolveDelaySeconds: integer|Long expected";
                    }
                    if (message.followees != null && message.hasOwnProperty("followees")) {
                        if (!$util.isObject(message.followees))
                            return "followees: object expected";
                        let key = Object.keys(message.followees);
                        for (let i = 0; i < key.length; ++i) {
                            if (!$util.key32Re.test(key[i]))
                                return "followees: integer key{k:int32} expected";
                            {
                                let error = $root.ic_nns_governance.pb.v1.Neuron.Followees.verify(message.followees[key[i]]);
                                if (error)
                                    return "followees." + error;
                            }
                        }
                    }
                    if (message.recentBallots != null && message.hasOwnProperty("recentBallots")) {
                        if (!Array.isArray(message.recentBallots))
                            return "recentBallots: array expected";
                        for (let i = 0; i < message.recentBallots.length; ++i) {
                            let error = $root.ic_nns_governance.pb.v1.BallotInfo.verify(message.recentBallots[i]);
                            if (error)
                                return "recentBallots." + error;
                        }
                    }
                    if (message.kycVerified != null && message.hasOwnProperty("kycVerified"))
                        if (typeof message.kycVerified !== "boolean")
                            return "kycVerified: boolean expected";
                    if (message.transfer != null && message.hasOwnProperty("transfer")) {
                        let error = $root.ic_nns_governance.pb.v1.NeuronStakeTransfer.verify(message.transfer);
                        if (error)
                            return "transfer." + error;
                    }
                    if (message.maturityE8sEquivalent != null && message.hasOwnProperty("maturityE8sEquivalent"))
                        if (!$util.isInteger(message.maturityE8sEquivalent) && !(message.maturityE8sEquivalent && $util.isInteger(message.maturityE8sEquivalent.low) && $util.isInteger(message.maturityE8sEquivalent.high)))
                            return "maturityE8sEquivalent: integer|Long expected";
                    if (message.notForProfit != null && message.hasOwnProperty("notForProfit"))
                        if (typeof message.notForProfit !== "boolean")
                            return "notForProfit: boolean expected";
                    if (message.joinedCommunityFundTimestampSeconds != null && message.hasOwnProperty("joinedCommunityFundTimestampSeconds")) {
                        properties._joinedCommunityFundTimestampSeconds = 1;
                        if (!$util.isInteger(message.joinedCommunityFundTimestampSeconds) && !(message.joinedCommunityFundTimestampSeconds && $util.isInteger(message.joinedCommunityFundTimestampSeconds.low) && $util.isInteger(message.joinedCommunityFundTimestampSeconds.high)))
                            return "joinedCommunityFundTimestampSeconds: integer|Long expected";
                    }
                    return null;
                };

                /**
                 * Creates a Neuron message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.Neuron} Neuron
                 */
                Neuron.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.Neuron)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.Neuron();
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Neuron.id: object expected");
                        message.id = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.id);
                    }
                    if (object.account != null)
                        if (typeof object.account === "string")
                            $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                        else if (object.account.length)
                            message.account = object.account;
                    if (object.controller != null) {
                        if (typeof object.controller !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Neuron.controller: object expected");
                        message.controller = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.controller);
                    }
                    if (object.hotKeys) {
                        if (!Array.isArray(object.hotKeys))
                            throw TypeError(".ic_nns_governance.pb.v1.Neuron.hotKeys: array expected");
                        message.hotKeys = [];
                        for (let i = 0; i < object.hotKeys.length; ++i) {
                            if (typeof object.hotKeys[i] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Neuron.hotKeys: object expected");
                            message.hotKeys[i] = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.hotKeys[i]);
                        }
                    }
                    if (object.cachedNeuronStakeE8s != null)
                        if ($util.Long)
                            (message.cachedNeuronStakeE8s = $util.Long.fromValue(object.cachedNeuronStakeE8s)).unsigned = true;
                        else if (typeof object.cachedNeuronStakeE8s === "string")
                            message.cachedNeuronStakeE8s = parseInt(object.cachedNeuronStakeE8s, 10);
                        else if (typeof object.cachedNeuronStakeE8s === "number")
                            message.cachedNeuronStakeE8s = object.cachedNeuronStakeE8s;
                        else if (typeof object.cachedNeuronStakeE8s === "object")
                            message.cachedNeuronStakeE8s = new $util.LongBits(object.cachedNeuronStakeE8s.low >>> 0, object.cachedNeuronStakeE8s.high >>> 0).toNumber(true);
                    if (object.neuronFeesE8s != null)
                        if ($util.Long)
                            (message.neuronFeesE8s = $util.Long.fromValue(object.neuronFeesE8s)).unsigned = true;
                        else if (typeof object.neuronFeesE8s === "string")
                            message.neuronFeesE8s = parseInt(object.neuronFeesE8s, 10);
                        else if (typeof object.neuronFeesE8s === "number")
                            message.neuronFeesE8s = object.neuronFeesE8s;
                        else if (typeof object.neuronFeesE8s === "object")
                            message.neuronFeesE8s = new $util.LongBits(object.neuronFeesE8s.low >>> 0, object.neuronFeesE8s.high >>> 0).toNumber(true);
                    if (object.createdTimestampSeconds != null)
                        if ($util.Long)
                            (message.createdTimestampSeconds = $util.Long.fromValue(object.createdTimestampSeconds)).unsigned = true;
                        else if (typeof object.createdTimestampSeconds === "string")
                            message.createdTimestampSeconds = parseInt(object.createdTimestampSeconds, 10);
                        else if (typeof object.createdTimestampSeconds === "number")
                            message.createdTimestampSeconds = object.createdTimestampSeconds;
                        else if (typeof object.createdTimestampSeconds === "object")
                            message.createdTimestampSeconds = new $util.LongBits(object.createdTimestampSeconds.low >>> 0, object.createdTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.agingSinceTimestampSeconds != null)
                        if ($util.Long)
                            (message.agingSinceTimestampSeconds = $util.Long.fromValue(object.agingSinceTimestampSeconds)).unsigned = true;
                        else if (typeof object.agingSinceTimestampSeconds === "string")
                            message.agingSinceTimestampSeconds = parseInt(object.agingSinceTimestampSeconds, 10);
                        else if (typeof object.agingSinceTimestampSeconds === "number")
                            message.agingSinceTimestampSeconds = object.agingSinceTimestampSeconds;
                        else if (typeof object.agingSinceTimestampSeconds === "object")
                            message.agingSinceTimestampSeconds = new $util.LongBits(object.agingSinceTimestampSeconds.low >>> 0, object.agingSinceTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.whenDissolvedTimestampSeconds != null)
                        if ($util.Long)
                            (message.whenDissolvedTimestampSeconds = $util.Long.fromValue(object.whenDissolvedTimestampSeconds)).unsigned = true;
                        else if (typeof object.whenDissolvedTimestampSeconds === "string")
                            message.whenDissolvedTimestampSeconds = parseInt(object.whenDissolvedTimestampSeconds, 10);
                        else if (typeof object.whenDissolvedTimestampSeconds === "number")
                            message.whenDissolvedTimestampSeconds = object.whenDissolvedTimestampSeconds;
                        else if (typeof object.whenDissolvedTimestampSeconds === "object")
                            message.whenDissolvedTimestampSeconds = new $util.LongBits(object.whenDissolvedTimestampSeconds.low >>> 0, object.whenDissolvedTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.dissolveDelaySeconds != null)
                        if ($util.Long)
                            (message.dissolveDelaySeconds = $util.Long.fromValue(object.dissolveDelaySeconds)).unsigned = true;
                        else if (typeof object.dissolveDelaySeconds === "string")
                            message.dissolveDelaySeconds = parseInt(object.dissolveDelaySeconds, 10);
                        else if (typeof object.dissolveDelaySeconds === "number")
                            message.dissolveDelaySeconds = object.dissolveDelaySeconds;
                        else if (typeof object.dissolveDelaySeconds === "object")
                            message.dissolveDelaySeconds = new $util.LongBits(object.dissolveDelaySeconds.low >>> 0, object.dissolveDelaySeconds.high >>> 0).toNumber(true);
                    if (object.followees) {
                        if (typeof object.followees !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Neuron.followees: object expected");
                        message.followees = {};
                        for (let keys = Object.keys(object.followees), i = 0; i < keys.length; ++i) {
                            if (typeof object.followees[keys[i]] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Neuron.followees: object expected");
                            message.followees[keys[i]] = $root.ic_nns_governance.pb.v1.Neuron.Followees.fromObject(object.followees[keys[i]]);
                        }
                    }
                    if (object.recentBallots) {
                        if (!Array.isArray(object.recentBallots))
                            throw TypeError(".ic_nns_governance.pb.v1.Neuron.recentBallots: array expected");
                        message.recentBallots = [];
                        for (let i = 0; i < object.recentBallots.length; ++i) {
                            if (typeof object.recentBallots[i] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Neuron.recentBallots: object expected");
                            message.recentBallots[i] = $root.ic_nns_governance.pb.v1.BallotInfo.fromObject(object.recentBallots[i]);
                        }
                    }
                    if (object.kycVerified != null)
                        message.kycVerified = Boolean(object.kycVerified);
                    if (object.transfer != null) {
                        if (typeof object.transfer !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Neuron.transfer: object expected");
                        message.transfer = $root.ic_nns_governance.pb.v1.NeuronStakeTransfer.fromObject(object.transfer);
                    }
                    if (object.maturityE8sEquivalent != null)
                        if ($util.Long)
                            (message.maturityE8sEquivalent = $util.Long.fromValue(object.maturityE8sEquivalent)).unsigned = true;
                        else if (typeof object.maturityE8sEquivalent === "string")
                            message.maturityE8sEquivalent = parseInt(object.maturityE8sEquivalent, 10);
                        else if (typeof object.maturityE8sEquivalent === "number")
                            message.maturityE8sEquivalent = object.maturityE8sEquivalent;
                        else if (typeof object.maturityE8sEquivalent === "object")
                            message.maturityE8sEquivalent = new $util.LongBits(object.maturityE8sEquivalent.low >>> 0, object.maturityE8sEquivalent.high >>> 0).toNumber(true);
                    if (object.notForProfit != null)
                        message.notForProfit = Boolean(object.notForProfit);
                    if (object.joinedCommunityFundTimestampSeconds != null)
                        if ($util.Long)
                            (message.joinedCommunityFundTimestampSeconds = $util.Long.fromValue(object.joinedCommunityFundTimestampSeconds)).unsigned = true;
                        else if (typeof object.joinedCommunityFundTimestampSeconds === "string")
                            message.joinedCommunityFundTimestampSeconds = parseInt(object.joinedCommunityFundTimestampSeconds, 10);
                        else if (typeof object.joinedCommunityFundTimestampSeconds === "number")
                            message.joinedCommunityFundTimestampSeconds = object.joinedCommunityFundTimestampSeconds;
                        else if (typeof object.joinedCommunityFundTimestampSeconds === "object")
                            message.joinedCommunityFundTimestampSeconds = new $util.LongBits(object.joinedCommunityFundTimestampSeconds.low >>> 0, object.joinedCommunityFundTimestampSeconds.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a Neuron message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @static
                 * @param {ic_nns_governance.pb.v1.Neuron} message Neuron
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Neuron.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.hotKeys = [];
                        object.recentBallots = [];
                    }
                    if (options.objects || options.defaults)
                        object.followees = {};
                    if (options.defaults) {
                        object.id = null;
                        if (options.bytes === String)
                            object.account = "";
                        else {
                            object.account = [];
                            if (options.bytes !== Array)
                                object.account = $util.newBuffer(object.account);
                        }
                        object.controller = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.cachedNeuronStakeE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.cachedNeuronStakeE8s = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.neuronFeesE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.neuronFeesE8s = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.createdTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.createdTimestampSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.agingSinceTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.agingSinceTimestampSeconds = options.longs === String ? "0" : 0;
                        object.kycVerified = false;
                        object.transfer = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.maturityE8sEquivalent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.maturityE8sEquivalent = options.longs === String ? "0" : 0;
                        object.notForProfit = false;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.id, options);
                    if (message.account != null && message.hasOwnProperty("account"))
                        object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
                    if (message.controller != null && message.hasOwnProperty("controller"))
                        object.controller = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.controller, options);
                    if (message.hotKeys && message.hotKeys.length) {
                        object.hotKeys = [];
                        for (let j = 0; j < message.hotKeys.length; ++j)
                            object.hotKeys[j] = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.hotKeys[j], options);
                    }
                    if (message.cachedNeuronStakeE8s != null && message.hasOwnProperty("cachedNeuronStakeE8s"))
                        if (typeof message.cachedNeuronStakeE8s === "number")
                            object.cachedNeuronStakeE8s = options.longs === String ? String(message.cachedNeuronStakeE8s) : message.cachedNeuronStakeE8s;
                        else
                            object.cachedNeuronStakeE8s = options.longs === String ? $util.Long.prototype.toString.call(message.cachedNeuronStakeE8s) : options.longs === Number ? new $util.LongBits(message.cachedNeuronStakeE8s.low >>> 0, message.cachedNeuronStakeE8s.high >>> 0).toNumber(true) : message.cachedNeuronStakeE8s;
                    if (message.neuronFeesE8s != null && message.hasOwnProperty("neuronFeesE8s"))
                        if (typeof message.neuronFeesE8s === "number")
                            object.neuronFeesE8s = options.longs === String ? String(message.neuronFeesE8s) : message.neuronFeesE8s;
                        else
                            object.neuronFeesE8s = options.longs === String ? $util.Long.prototype.toString.call(message.neuronFeesE8s) : options.longs === Number ? new $util.LongBits(message.neuronFeesE8s.low >>> 0, message.neuronFeesE8s.high >>> 0).toNumber(true) : message.neuronFeesE8s;
                    if (message.createdTimestampSeconds != null && message.hasOwnProperty("createdTimestampSeconds"))
                        if (typeof message.createdTimestampSeconds === "number")
                            object.createdTimestampSeconds = options.longs === String ? String(message.createdTimestampSeconds) : message.createdTimestampSeconds;
                        else
                            object.createdTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.createdTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.createdTimestampSeconds.low >>> 0, message.createdTimestampSeconds.high >>> 0).toNumber(true) : message.createdTimestampSeconds;
                    if (message.agingSinceTimestampSeconds != null && message.hasOwnProperty("agingSinceTimestampSeconds"))
                        if (typeof message.agingSinceTimestampSeconds === "number")
                            object.agingSinceTimestampSeconds = options.longs === String ? String(message.agingSinceTimestampSeconds) : message.agingSinceTimestampSeconds;
                        else
                            object.agingSinceTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.agingSinceTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.agingSinceTimestampSeconds.low >>> 0, message.agingSinceTimestampSeconds.high >>> 0).toNumber(true) : message.agingSinceTimestampSeconds;
                    if (message.whenDissolvedTimestampSeconds != null && message.hasOwnProperty("whenDissolvedTimestampSeconds")) {
                        if (typeof message.whenDissolvedTimestampSeconds === "number")
                            object.whenDissolvedTimestampSeconds = options.longs === String ? String(message.whenDissolvedTimestampSeconds) : message.whenDissolvedTimestampSeconds;
                        else
                            object.whenDissolvedTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.whenDissolvedTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.whenDissolvedTimestampSeconds.low >>> 0, message.whenDissolvedTimestampSeconds.high >>> 0).toNumber(true) : message.whenDissolvedTimestampSeconds;
                        if (options.oneofs)
                            object.dissolveState = "whenDissolvedTimestampSeconds";
                    }
                    if (message.dissolveDelaySeconds != null && message.hasOwnProperty("dissolveDelaySeconds")) {
                        if (typeof message.dissolveDelaySeconds === "number")
                            object.dissolveDelaySeconds = options.longs === String ? String(message.dissolveDelaySeconds) : message.dissolveDelaySeconds;
                        else
                            object.dissolveDelaySeconds = options.longs === String ? $util.Long.prototype.toString.call(message.dissolveDelaySeconds) : options.longs === Number ? new $util.LongBits(message.dissolveDelaySeconds.low >>> 0, message.dissolveDelaySeconds.high >>> 0).toNumber(true) : message.dissolveDelaySeconds;
                        if (options.oneofs)
                            object.dissolveState = "dissolveDelaySeconds";
                    }
                    let keys2;
                    if (message.followees && (keys2 = Object.keys(message.followees)).length) {
                        object.followees = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.followees[keys2[j]] = $root.ic_nns_governance.pb.v1.Neuron.Followees.toObject(message.followees[keys2[j]], options);
                    }
                    if (message.recentBallots && message.recentBallots.length) {
                        object.recentBallots = [];
                        for (let j = 0; j < message.recentBallots.length; ++j)
                            object.recentBallots[j] = $root.ic_nns_governance.pb.v1.BallotInfo.toObject(message.recentBallots[j], options);
                    }
                    if (message.kycVerified != null && message.hasOwnProperty("kycVerified"))
                        object.kycVerified = message.kycVerified;
                    if (message.transfer != null && message.hasOwnProperty("transfer"))
                        object.transfer = $root.ic_nns_governance.pb.v1.NeuronStakeTransfer.toObject(message.transfer, options);
                    if (message.maturityE8sEquivalent != null && message.hasOwnProperty("maturityE8sEquivalent"))
                        if (typeof message.maturityE8sEquivalent === "number")
                            object.maturityE8sEquivalent = options.longs === String ? String(message.maturityE8sEquivalent) : message.maturityE8sEquivalent;
                        else
                            object.maturityE8sEquivalent = options.longs === String ? $util.Long.prototype.toString.call(message.maturityE8sEquivalent) : options.longs === Number ? new $util.LongBits(message.maturityE8sEquivalent.low >>> 0, message.maturityE8sEquivalent.high >>> 0).toNumber(true) : message.maturityE8sEquivalent;
                    if (message.notForProfit != null && message.hasOwnProperty("notForProfit"))
                        object.notForProfit = message.notForProfit;
                    if (message.joinedCommunityFundTimestampSeconds != null && message.hasOwnProperty("joinedCommunityFundTimestampSeconds")) {
                        if (typeof message.joinedCommunityFundTimestampSeconds === "number")
                            object.joinedCommunityFundTimestampSeconds = options.longs === String ? String(message.joinedCommunityFundTimestampSeconds) : message.joinedCommunityFundTimestampSeconds;
                        else
                            object.joinedCommunityFundTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.joinedCommunityFundTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.joinedCommunityFundTimestampSeconds.low >>> 0, message.joinedCommunityFundTimestampSeconds.high >>> 0).toNumber(true) : message.joinedCommunityFundTimestampSeconds;
                        if (options.oneofs)
                            object._joinedCommunityFundTimestampSeconds = "joinedCommunityFundTimestampSeconds";
                    }
                    return object;
                };

                /**
                 * Converts this Neuron to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.Neuron
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Neuron.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Neuron.Followees = (function() {

                    /**
                     * Properties of a Followees.
                     * @memberof ic_nns_governance.pb.v1.Neuron
                     * @interface IFollowees
                     * @property {Array.<ic_nns_common.pb.v1.INeuronId>|null} [followees] Followees followees
                     */

                    /**
                     * Constructs a new Followees.
                     * @memberof ic_nns_governance.pb.v1.Neuron
                     * @classdesc Represents a Followees.
                     * @implements IFollowees
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.Neuron.IFollowees=} [properties] Properties to set
                     */
                    function Followees(properties) {
                        this.followees = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Followees followees.
                     * @member {Array.<ic_nns_common.pb.v1.INeuronId>} followees
                     * @memberof ic_nns_governance.pb.v1.Neuron.Followees
                     * @instance
                     */
                    Followees.prototype.followees = $util.emptyArray;

                    /**
                     * Creates a new Followees instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.Neuron.Followees
                     * @static
                     * @param {ic_nns_governance.pb.v1.Neuron.IFollowees=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.Neuron.Followees} Followees instance
                     */
                    Followees.create = function create(properties) {
                        return new Followees(properties);
                    };

                    /**
                     * Encodes the specified Followees message. Does not implicitly {@link ic_nns_governance.pb.v1.Neuron.Followees.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.Neuron.Followees
                     * @static
                     * @param {ic_nns_governance.pb.v1.Neuron.IFollowees} message Followees message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Followees.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.followees != null && message.followees.length)
                            for (let i = 0; i < message.followees.length; ++i)
                                $root.ic_nns_common.pb.v1.NeuronId.encode(message.followees[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Followees message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.Neuron.Followees.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.Neuron.Followees
                     * @static
                     * @param {ic_nns_governance.pb.v1.Neuron.IFollowees} message Followees message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Followees.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Followees message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.Neuron.Followees
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.Neuron.Followees} Followees
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Followees.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.Neuron.Followees();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.followees && message.followees.length))
                                    message.followees = [];
                                message.followees.push($root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Followees message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.Neuron.Followees
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.Neuron.Followees} Followees
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Followees.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Followees message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.Neuron.Followees
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Followees.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.followees != null && message.hasOwnProperty("followees")) {
                            if (!Array.isArray(message.followees))
                                return "followees: array expected";
                            for (let i = 0; i < message.followees.length; ++i) {
                                let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.followees[i]);
                                if (error)
                                    return "followees." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Followees message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.Neuron.Followees
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.Neuron.Followees} Followees
                     */
                    Followees.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.Neuron.Followees)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.Neuron.Followees();
                        if (object.followees) {
                            if (!Array.isArray(object.followees))
                                throw TypeError(".ic_nns_governance.pb.v1.Neuron.Followees.followees: array expected");
                            message.followees = [];
                            for (let i = 0; i < object.followees.length; ++i) {
                                if (typeof object.followees[i] !== "object")
                                    throw TypeError(".ic_nns_governance.pb.v1.Neuron.Followees.followees: object expected");
                                message.followees[i] = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.followees[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Followees message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.Neuron.Followees
                     * @static
                     * @param {ic_nns_governance.pb.v1.Neuron.Followees} message Followees
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Followees.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.followees = [];
                        if (message.followees && message.followees.length) {
                            object.followees = [];
                            for (let j = 0; j < message.followees.length; ++j)
                                object.followees[j] = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.followees[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Followees to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.Neuron.Followees
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Followees.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Followees;
                })();

                return Neuron;
            })();

            /**
             * Vote enum.
             * @name ic_nns_governance.pb.v1.Vote
             * @enum {number}
             * @property {number} VOTE_UNSPECIFIED=0 VOTE_UNSPECIFIED value
             * @property {number} VOTE_YES=1 VOTE_YES value
             * @property {number} VOTE_NO=2 VOTE_NO value
             */
            v1.Vote = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "VOTE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "VOTE_YES"] = 1;
                values[valuesById[2] = "VOTE_NO"] = 2;
                return values;
            })();

            /**
             * NnsFunction enum.
             * @name ic_nns_governance.pb.v1.NnsFunction
             * @enum {number}
             * @property {number} NNS_FUNCTION_UNSPECIFIED=0 NNS_FUNCTION_UNSPECIFIED value
             * @property {number} NNS_FUNCTION_CREATE_SUBNET=1 NNS_FUNCTION_CREATE_SUBNET value
             * @property {number} NNS_FUNCTION_ADD_NODE_TO_SUBNET=2 NNS_FUNCTION_ADD_NODE_TO_SUBNET value
             * @property {number} NNS_FUNCTION_NNS_CANISTER_INSTALL=3 NNS_FUNCTION_NNS_CANISTER_INSTALL value
             * @property {number} NNS_FUNCTION_NNS_CANISTER_UPGRADE=4 NNS_FUNCTION_NNS_CANISTER_UPGRADE value
             * @property {number} NNS_FUNCTION_BLESS_REPLICA_VERSION=5 NNS_FUNCTION_BLESS_REPLICA_VERSION value
             * @property {number} NNS_FUNCTION_RECOVER_SUBNET=6 NNS_FUNCTION_RECOVER_SUBNET value
             * @property {number} NNS_FUNCTION_UPDATE_CONFIG_OF_SUBNET=7 NNS_FUNCTION_UPDATE_CONFIG_OF_SUBNET value
             * @property {number} NNS_FUNCTION_ASSIGN_NOID=8 NNS_FUNCTION_ASSIGN_NOID value
             * @property {number} NNS_FUNCTION_NNS_ROOT_UPGRADE=9 NNS_FUNCTION_NNS_ROOT_UPGRADE value
             * @property {number} NNS_FUNCTION_ICP_XDR_CONVERSION_RATE=10 NNS_FUNCTION_ICP_XDR_CONVERSION_RATE value
             * @property {number} NNS_FUNCTION_UPDATE_SUBNET_REPLICA_VERSION=11 NNS_FUNCTION_UPDATE_SUBNET_REPLICA_VERSION value
             * @property {number} NNS_FUNCTION_CLEAR_PROVISIONAL_WHITELIST=12 The proposal changes the provisional whitelist to the empty list.
             * @property {number} NNS_FUNCTION_REMOVE_NODES_FROM_SUBNET=13 NNS_FUNCTION_REMOVE_NODES_FROM_SUBNET value
             * @property {number} NNS_FUNCTION_SET_AUTHORIZED_SUBNETWORKS=14 NNS_FUNCTION_SET_AUTHORIZED_SUBNETWORKS value
             * @property {number} NNS_FUNCTION_SET_FIREWALL_CONFIG=15 NNS_FUNCTION_SET_FIREWALL_CONFIG value
             * @property {number} NNS_FUNCTION_UPDATE_NODE_OPERATOR_CONFIG=16 NNS_FUNCTION_UPDATE_NODE_OPERATOR_CONFIG value
             * @property {number} NNS_FUNCTION_STOP_OR_START_NNS_CANISTER=17 NNS_FUNCTION_STOP_OR_START_NNS_CANISTER value
             * @property {number} NNS_FUNCTION_REMOVE_NODES=18 NNS_FUNCTION_REMOVE_NODES value
             * @property {number} NNS_FUNCTION_UNINSTALL_CODE=19 NNS_FUNCTION_UNINSTALL_CODE value
             * @property {number} NNS_FUNCTION_UPDATE_NODE_REWARDS_TABLE=20 NNS_FUNCTION_UPDATE_NODE_REWARDS_TABLE value
             * @property {number} NNS_FUNCTION_ADD_OR_REMOVE_DATA_CENTERS=21 NNS_FUNCTION_ADD_OR_REMOVE_DATA_CENTERS value
             */
            v1.NnsFunction = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NNS_FUNCTION_UNSPECIFIED"] = 0;
                values[valuesById[1] = "NNS_FUNCTION_CREATE_SUBNET"] = 1;
                values[valuesById[2] = "NNS_FUNCTION_ADD_NODE_TO_SUBNET"] = 2;
                values[valuesById[3] = "NNS_FUNCTION_NNS_CANISTER_INSTALL"] = 3;
                values[valuesById[4] = "NNS_FUNCTION_NNS_CANISTER_UPGRADE"] = 4;
                values[valuesById[5] = "NNS_FUNCTION_BLESS_REPLICA_VERSION"] = 5;
                values[valuesById[6] = "NNS_FUNCTION_RECOVER_SUBNET"] = 6;
                values[valuesById[7] = "NNS_FUNCTION_UPDATE_CONFIG_OF_SUBNET"] = 7;
                values[valuesById[8] = "NNS_FUNCTION_ASSIGN_NOID"] = 8;
                values[valuesById[9] = "NNS_FUNCTION_NNS_ROOT_UPGRADE"] = 9;
                values[valuesById[10] = "NNS_FUNCTION_ICP_XDR_CONVERSION_RATE"] = 10;
                values[valuesById[11] = "NNS_FUNCTION_UPDATE_SUBNET_REPLICA_VERSION"] = 11;
                values[valuesById[12] = "NNS_FUNCTION_CLEAR_PROVISIONAL_WHITELIST"] = 12;
                values[valuesById[13] = "NNS_FUNCTION_REMOVE_NODES_FROM_SUBNET"] = 13;
                values[valuesById[14] = "NNS_FUNCTION_SET_AUTHORIZED_SUBNETWORKS"] = 14;
                values[valuesById[15] = "NNS_FUNCTION_SET_FIREWALL_CONFIG"] = 15;
                values[valuesById[16] = "NNS_FUNCTION_UPDATE_NODE_OPERATOR_CONFIG"] = 16;
                values[valuesById[17] = "NNS_FUNCTION_STOP_OR_START_NNS_CANISTER"] = 17;
                values[valuesById[18] = "NNS_FUNCTION_REMOVE_NODES"] = 18;
                values[valuesById[19] = "NNS_FUNCTION_UNINSTALL_CODE"] = 19;
                values[valuesById[20] = "NNS_FUNCTION_UPDATE_NODE_REWARDS_TABLE"] = 20;
                values[valuesById[21] = "NNS_FUNCTION_ADD_OR_REMOVE_DATA_CENTERS"] = 21;
                return values;
            })();

            v1.ExecuteNnsFunction = (function() {

                /**
                 * Properties of an ExecuteNnsFunction.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IExecuteNnsFunction
                 * @property {ic_nns_governance.pb.v1.NnsFunction|null} [nnsFunction] ExecuteNnsFunction nnsFunction
                 * @property {Uint8Array|null} [payload] ExecuteNnsFunction payload
                 */

                /**
                 * Constructs a new ExecuteNnsFunction.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents an ExecuteNnsFunction.
                 * @implements IExecuteNnsFunction
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IExecuteNnsFunction=} [properties] Properties to set
                 */
                function ExecuteNnsFunction(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExecuteNnsFunction nnsFunction.
                 * @member {ic_nns_governance.pb.v1.NnsFunction} nnsFunction
                 * @memberof ic_nns_governance.pb.v1.ExecuteNnsFunction
                 * @instance
                 */
                ExecuteNnsFunction.prototype.nnsFunction = 0;

                /**
                 * ExecuteNnsFunction payload.
                 * @member {Uint8Array} payload
                 * @memberof ic_nns_governance.pb.v1.ExecuteNnsFunction
                 * @instance
                 */
                ExecuteNnsFunction.prototype.payload = $util.newBuffer([]);

                /**
                 * Creates a new ExecuteNnsFunction instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ExecuteNnsFunction
                 * @static
                 * @param {ic_nns_governance.pb.v1.IExecuteNnsFunction=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ExecuteNnsFunction} ExecuteNnsFunction instance
                 */
                ExecuteNnsFunction.create = function create(properties) {
                    return new ExecuteNnsFunction(properties);
                };

                /**
                 * Encodes the specified ExecuteNnsFunction message. Does not implicitly {@link ic_nns_governance.pb.v1.ExecuteNnsFunction.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ExecuteNnsFunction
                 * @static
                 * @param {ic_nns_governance.pb.v1.IExecuteNnsFunction} message ExecuteNnsFunction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecuteNnsFunction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nnsFunction != null && Object.hasOwnProperty.call(message, "nnsFunction"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nnsFunction);
                    if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                    return writer;
                };

                /**
                 * Encodes the specified ExecuteNnsFunction message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ExecuteNnsFunction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ExecuteNnsFunction
                 * @static
                 * @param {ic_nns_governance.pb.v1.IExecuteNnsFunction} message ExecuteNnsFunction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExecuteNnsFunction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExecuteNnsFunction message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ExecuteNnsFunction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ExecuteNnsFunction} ExecuteNnsFunction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecuteNnsFunction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ExecuteNnsFunction();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nnsFunction = reader.int32();
                            break;
                        case 2:
                            message.payload = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExecuteNnsFunction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ExecuteNnsFunction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ExecuteNnsFunction} ExecuteNnsFunction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExecuteNnsFunction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExecuteNnsFunction message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ExecuteNnsFunction
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExecuteNnsFunction.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nnsFunction != null && message.hasOwnProperty("nnsFunction"))
                        switch (message.nnsFunction) {
                        default:
                            return "nnsFunction: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                        case 20:
                        case 21:
                            break;
                        }
                    if (message.payload != null && message.hasOwnProperty("payload"))
                        if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                            return "payload: buffer expected";
                    return null;
                };

                /**
                 * Creates an ExecuteNnsFunction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ExecuteNnsFunction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ExecuteNnsFunction} ExecuteNnsFunction
                 */
                ExecuteNnsFunction.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ExecuteNnsFunction)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ExecuteNnsFunction();
                    switch (object.nnsFunction) {
                    case "NNS_FUNCTION_UNSPECIFIED":
                    case 0:
                        message.nnsFunction = 0;
                        break;
                    case "NNS_FUNCTION_CREATE_SUBNET":
                    case 1:
                        message.nnsFunction = 1;
                        break;
                    case "NNS_FUNCTION_ADD_NODE_TO_SUBNET":
                    case 2:
                        message.nnsFunction = 2;
                        break;
                    case "NNS_FUNCTION_NNS_CANISTER_INSTALL":
                    case 3:
                        message.nnsFunction = 3;
                        break;
                    case "NNS_FUNCTION_NNS_CANISTER_UPGRADE":
                    case 4:
                        message.nnsFunction = 4;
                        break;
                    case "NNS_FUNCTION_BLESS_REPLICA_VERSION":
                    case 5:
                        message.nnsFunction = 5;
                        break;
                    case "NNS_FUNCTION_RECOVER_SUBNET":
                    case 6:
                        message.nnsFunction = 6;
                        break;
                    case "NNS_FUNCTION_UPDATE_CONFIG_OF_SUBNET":
                    case 7:
                        message.nnsFunction = 7;
                        break;
                    case "NNS_FUNCTION_ASSIGN_NOID":
                    case 8:
                        message.nnsFunction = 8;
                        break;
                    case "NNS_FUNCTION_NNS_ROOT_UPGRADE":
                    case 9:
                        message.nnsFunction = 9;
                        break;
                    case "NNS_FUNCTION_ICP_XDR_CONVERSION_RATE":
                    case 10:
                        message.nnsFunction = 10;
                        break;
                    case "NNS_FUNCTION_UPDATE_SUBNET_REPLICA_VERSION":
                    case 11:
                        message.nnsFunction = 11;
                        break;
                    case "NNS_FUNCTION_CLEAR_PROVISIONAL_WHITELIST":
                    case 12:
                        message.nnsFunction = 12;
                        break;
                    case "NNS_FUNCTION_REMOVE_NODES_FROM_SUBNET":
                    case 13:
                        message.nnsFunction = 13;
                        break;
                    case "NNS_FUNCTION_SET_AUTHORIZED_SUBNETWORKS":
                    case 14:
                        message.nnsFunction = 14;
                        break;
                    case "NNS_FUNCTION_SET_FIREWALL_CONFIG":
                    case 15:
                        message.nnsFunction = 15;
                        break;
                    case "NNS_FUNCTION_UPDATE_NODE_OPERATOR_CONFIG":
                    case 16:
                        message.nnsFunction = 16;
                        break;
                    case "NNS_FUNCTION_STOP_OR_START_NNS_CANISTER":
                    case 17:
                        message.nnsFunction = 17;
                        break;
                    case "NNS_FUNCTION_REMOVE_NODES":
                    case 18:
                        message.nnsFunction = 18;
                        break;
                    case "NNS_FUNCTION_UNINSTALL_CODE":
                    case 19:
                        message.nnsFunction = 19;
                        break;
                    case "NNS_FUNCTION_UPDATE_NODE_REWARDS_TABLE":
                    case 20:
                        message.nnsFunction = 20;
                        break;
                    case "NNS_FUNCTION_ADD_OR_REMOVE_DATA_CENTERS":
                    case 21:
                        message.nnsFunction = 21;
                        break;
                    }
                    if (object.payload != null)
                        if (typeof object.payload === "string")
                            $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                        else if (object.payload.length)
                            message.payload = object.payload;
                    return message;
                };

                /**
                 * Creates a plain object from an ExecuteNnsFunction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ExecuteNnsFunction
                 * @static
                 * @param {ic_nns_governance.pb.v1.ExecuteNnsFunction} message ExecuteNnsFunction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExecuteNnsFunction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.nnsFunction = options.enums === String ? "NNS_FUNCTION_UNSPECIFIED" : 0;
                        if (options.bytes === String)
                            object.payload = "";
                        else {
                            object.payload = [];
                            if (options.bytes !== Array)
                                object.payload = $util.newBuffer(object.payload);
                        }
                    }
                    if (message.nnsFunction != null && message.hasOwnProperty("nnsFunction"))
                        object.nnsFunction = options.enums === String ? $root.ic_nns_governance.pb.v1.NnsFunction[message.nnsFunction] : message.nnsFunction;
                    if (message.payload != null && message.hasOwnProperty("payload"))
                        object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                    return object;
                };

                /**
                 * Converts this ExecuteNnsFunction to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ExecuteNnsFunction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExecuteNnsFunction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExecuteNnsFunction;
            })();

            v1.Motion = (function() {

                /**
                 * Properties of a Motion.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IMotion
                 * @property {string|null} [motionText] Motion motionText
                 */

                /**
                 * Constructs a new Motion.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a Motion.
                 * @implements IMotion
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IMotion=} [properties] Properties to set
                 */
                function Motion(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Motion motionText.
                 * @member {string} motionText
                 * @memberof ic_nns_governance.pb.v1.Motion
                 * @instance
                 */
                Motion.prototype.motionText = "";

                /**
                 * Creates a new Motion instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.Motion
                 * @static
                 * @param {ic_nns_governance.pb.v1.IMotion=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.Motion} Motion instance
                 */
                Motion.create = function create(properties) {
                    return new Motion(properties);
                };

                /**
                 * Encodes the specified Motion message. Does not implicitly {@link ic_nns_governance.pb.v1.Motion.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.Motion
                 * @static
                 * @param {ic_nns_governance.pb.v1.IMotion} message Motion message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Motion.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.motionText != null && Object.hasOwnProperty.call(message, "motionText"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.motionText);
                    return writer;
                };

                /**
                 * Encodes the specified Motion message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.Motion.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Motion
                 * @static
                 * @param {ic_nns_governance.pb.v1.IMotion} message Motion message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Motion.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Motion message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.Motion
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.Motion} Motion
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Motion.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.Motion();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.motionText = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Motion message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Motion
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.Motion} Motion
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Motion.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Motion message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.Motion
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Motion.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.motionText != null && message.hasOwnProperty("motionText"))
                        if (!$util.isString(message.motionText))
                            return "motionText: string expected";
                    return null;
                };

                /**
                 * Creates a Motion message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.Motion
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.Motion} Motion
                 */
                Motion.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.Motion)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.Motion();
                    if (object.motionText != null)
                        message.motionText = String(object.motionText);
                    return message;
                };

                /**
                 * Creates a plain object from a Motion message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.Motion
                 * @static
                 * @param {ic_nns_governance.pb.v1.Motion} message Motion
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Motion.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.motionText = "";
                    if (message.motionText != null && message.hasOwnProperty("motionText"))
                        object.motionText = message.motionText;
                    return object;
                };

                /**
                 * Converts this Motion to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.Motion
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Motion.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Motion;
            })();

            v1.ApproveGenesisKYC = (function() {

                /**
                 * Properties of an ApproveGenesisKYC.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IApproveGenesisKYC
                 * @property {Array.<ic_base_types.pb.v1.IPrincipalId>|null} [principals] ApproveGenesisKYC principals
                 */

                /**
                 * Constructs a new ApproveGenesisKYC.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents an ApproveGenesisKYC.
                 * @implements IApproveGenesisKYC
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IApproveGenesisKYC=} [properties] Properties to set
                 */
                function ApproveGenesisKYC(properties) {
                    this.principals = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ApproveGenesisKYC principals.
                 * @member {Array.<ic_base_types.pb.v1.IPrincipalId>} principals
                 * @memberof ic_nns_governance.pb.v1.ApproveGenesisKYC
                 * @instance
                 */
                ApproveGenesisKYC.prototype.principals = $util.emptyArray;

                /**
                 * Creates a new ApproveGenesisKYC instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ApproveGenesisKYC
                 * @static
                 * @param {ic_nns_governance.pb.v1.IApproveGenesisKYC=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ApproveGenesisKYC} ApproveGenesisKYC instance
                 */
                ApproveGenesisKYC.create = function create(properties) {
                    return new ApproveGenesisKYC(properties);
                };

                /**
                 * Encodes the specified ApproveGenesisKYC message. Does not implicitly {@link ic_nns_governance.pb.v1.ApproveGenesisKYC.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ApproveGenesisKYC
                 * @static
                 * @param {ic_nns_governance.pb.v1.IApproveGenesisKYC} message ApproveGenesisKYC message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ApproveGenesisKYC.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.principals != null && message.principals.length)
                        for (let i = 0; i < message.principals.length; ++i)
                            $root.ic_base_types.pb.v1.PrincipalId.encode(message.principals[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ApproveGenesisKYC message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ApproveGenesisKYC.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ApproveGenesisKYC
                 * @static
                 * @param {ic_nns_governance.pb.v1.IApproveGenesisKYC} message ApproveGenesisKYC message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ApproveGenesisKYC.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ApproveGenesisKYC message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ApproveGenesisKYC
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ApproveGenesisKYC} ApproveGenesisKYC
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ApproveGenesisKYC.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ApproveGenesisKYC();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.principals && message.principals.length))
                                message.principals = [];
                            message.principals.push($root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ApproveGenesisKYC message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ApproveGenesisKYC
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ApproveGenesisKYC} ApproveGenesisKYC
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ApproveGenesisKYC.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ApproveGenesisKYC message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ApproveGenesisKYC
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ApproveGenesisKYC.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.principals != null && message.hasOwnProperty("principals")) {
                        if (!Array.isArray(message.principals))
                            return "principals: array expected";
                        for (let i = 0; i < message.principals.length; ++i) {
                            let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.principals[i]);
                            if (error)
                                return "principals." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an ApproveGenesisKYC message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ApproveGenesisKYC
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ApproveGenesisKYC} ApproveGenesisKYC
                 */
                ApproveGenesisKYC.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ApproveGenesisKYC)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ApproveGenesisKYC();
                    if (object.principals) {
                        if (!Array.isArray(object.principals))
                            throw TypeError(".ic_nns_governance.pb.v1.ApproveGenesisKYC.principals: array expected");
                        message.principals = [];
                        for (let i = 0; i < object.principals.length; ++i) {
                            if (typeof object.principals[i] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ApproveGenesisKYC.principals: object expected");
                            message.principals[i] = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.principals[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ApproveGenesisKYC message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ApproveGenesisKYC
                 * @static
                 * @param {ic_nns_governance.pb.v1.ApproveGenesisKYC} message ApproveGenesisKYC
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ApproveGenesisKYC.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.principals = [];
                    if (message.principals && message.principals.length) {
                        object.principals = [];
                        for (let j = 0; j < message.principals.length; ++j)
                            object.principals[j] = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.principals[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ApproveGenesisKYC to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ApproveGenesisKYC
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ApproveGenesisKYC.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ApproveGenesisKYC;
            })();

            v1.AddOrRemoveNodeProvider = (function() {

                /**
                 * Properties of an AddOrRemoveNodeProvider.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IAddOrRemoveNodeProvider
                 * @property {ic_nns_governance.pb.v1.INodeProvider|null} [toAdd] AddOrRemoveNodeProvider toAdd
                 * @property {ic_nns_governance.pb.v1.INodeProvider|null} [toRemove] AddOrRemoveNodeProvider toRemove
                 */

                /**
                 * Constructs a new AddOrRemoveNodeProvider.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents an AddOrRemoveNodeProvider.
                 * @implements IAddOrRemoveNodeProvider
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IAddOrRemoveNodeProvider=} [properties] Properties to set
                 */
                function AddOrRemoveNodeProvider(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AddOrRemoveNodeProvider toAdd.
                 * @member {ic_nns_governance.pb.v1.INodeProvider|null|undefined} toAdd
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @instance
                 */
                AddOrRemoveNodeProvider.prototype.toAdd = null;

                /**
                 * AddOrRemoveNodeProvider toRemove.
                 * @member {ic_nns_governance.pb.v1.INodeProvider|null|undefined} toRemove
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @instance
                 */
                AddOrRemoveNodeProvider.prototype.toRemove = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * AddOrRemoveNodeProvider change.
                 * @member {"toAdd"|"toRemove"|undefined} change
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @instance
                 */
                Object.defineProperty(AddOrRemoveNodeProvider.prototype, "change", {
                    get: $util.oneOfGetter($oneOfFields = ["toAdd", "toRemove"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new AddOrRemoveNodeProvider instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.IAddOrRemoveNodeProvider=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.AddOrRemoveNodeProvider} AddOrRemoveNodeProvider instance
                 */
                AddOrRemoveNodeProvider.create = function create(properties) {
                    return new AddOrRemoveNodeProvider(properties);
                };

                /**
                 * Encodes the specified AddOrRemoveNodeProvider message. Does not implicitly {@link ic_nns_governance.pb.v1.AddOrRemoveNodeProvider.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.IAddOrRemoveNodeProvider} message AddOrRemoveNodeProvider message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddOrRemoveNodeProvider.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.toAdd != null && Object.hasOwnProperty.call(message, "toAdd"))
                        $root.ic_nns_governance.pb.v1.NodeProvider.encode(message.toAdd, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.toRemove != null && Object.hasOwnProperty.call(message, "toRemove"))
                        $root.ic_nns_governance.pb.v1.NodeProvider.encode(message.toRemove, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified AddOrRemoveNodeProvider message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.AddOrRemoveNodeProvider.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.IAddOrRemoveNodeProvider} message AddOrRemoveNodeProvider message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddOrRemoveNodeProvider.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AddOrRemoveNodeProvider message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.AddOrRemoveNodeProvider} AddOrRemoveNodeProvider
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddOrRemoveNodeProvider.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.AddOrRemoveNodeProvider();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.toAdd = $root.ic_nns_governance.pb.v1.NodeProvider.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.toRemove = $root.ic_nns_governance.pb.v1.NodeProvider.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AddOrRemoveNodeProvider message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.AddOrRemoveNodeProvider} AddOrRemoveNodeProvider
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddOrRemoveNodeProvider.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AddOrRemoveNodeProvider message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AddOrRemoveNodeProvider.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.toAdd != null && message.hasOwnProperty("toAdd")) {
                        properties.change = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.NodeProvider.verify(message.toAdd);
                            if (error)
                                return "toAdd." + error;
                        }
                    }
                    if (message.toRemove != null && message.hasOwnProperty("toRemove")) {
                        if (properties.change === 1)
                            return "change: multiple values";
                        properties.change = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.NodeProvider.verify(message.toRemove);
                            if (error)
                                return "toRemove." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an AddOrRemoveNodeProvider message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.AddOrRemoveNodeProvider} AddOrRemoveNodeProvider
                 */
                AddOrRemoveNodeProvider.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.AddOrRemoveNodeProvider)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.AddOrRemoveNodeProvider();
                    if (object.toAdd != null) {
                        if (typeof object.toAdd !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.AddOrRemoveNodeProvider.toAdd: object expected");
                        message.toAdd = $root.ic_nns_governance.pb.v1.NodeProvider.fromObject(object.toAdd);
                    }
                    if (object.toRemove != null) {
                        if (typeof object.toRemove !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.AddOrRemoveNodeProvider.toRemove: object expected");
                        message.toRemove = $root.ic_nns_governance.pb.v1.NodeProvider.fromObject(object.toRemove);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an AddOrRemoveNodeProvider message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.AddOrRemoveNodeProvider} message AddOrRemoveNodeProvider
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AddOrRemoveNodeProvider.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.toAdd != null && message.hasOwnProperty("toAdd")) {
                        object.toAdd = $root.ic_nns_governance.pb.v1.NodeProvider.toObject(message.toAdd, options);
                        if (options.oneofs)
                            object.change = "toAdd";
                    }
                    if (message.toRemove != null && message.hasOwnProperty("toRemove")) {
                        object.toRemove = $root.ic_nns_governance.pb.v1.NodeProvider.toObject(message.toRemove, options);
                        if (options.oneofs)
                            object.change = "toRemove";
                    }
                    return object;
                };

                /**
                 * Converts this AddOrRemoveNodeProvider to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.AddOrRemoveNodeProvider
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AddOrRemoveNodeProvider.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AddOrRemoveNodeProvider;
            })();

            v1.RewardNodeProvider = (function() {

                /**
                 * Properties of a RewardNodeProvider.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IRewardNodeProvider
                 * @property {ic_nns_governance.pb.v1.INodeProvider|null} [nodeProvider] RewardNodeProvider nodeProvider
                 * @property {number|Long|null} [amountE8s] RewardNodeProvider amountE8s
                 * @property {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToNeuron|null} [rewardToNeuron] RewardNodeProvider rewardToNeuron
                 * @property {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToAccount|null} [rewardToAccount] RewardNodeProvider rewardToAccount
                 */

                /**
                 * Constructs a new RewardNodeProvider.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a RewardNodeProvider.
                 * @implements IRewardNodeProvider
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IRewardNodeProvider=} [properties] Properties to set
                 */
                function RewardNodeProvider(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RewardNodeProvider nodeProvider.
                 * @member {ic_nns_governance.pb.v1.INodeProvider|null|undefined} nodeProvider
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @instance
                 */
                RewardNodeProvider.prototype.nodeProvider = null;

                /**
                 * RewardNodeProvider amountE8s.
                 * @member {number|Long} amountE8s
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @instance
                 */
                RewardNodeProvider.prototype.amountE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * RewardNodeProvider rewardToNeuron.
                 * @member {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToNeuron|null|undefined} rewardToNeuron
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @instance
                 */
                RewardNodeProvider.prototype.rewardToNeuron = null;

                /**
                 * RewardNodeProvider rewardToAccount.
                 * @member {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToAccount|null|undefined} rewardToAccount
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @instance
                 */
                RewardNodeProvider.prototype.rewardToAccount = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * RewardNodeProvider rewardMode.
                 * @member {"rewardToNeuron"|"rewardToAccount"|undefined} rewardMode
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @instance
                 */
                Object.defineProperty(RewardNodeProvider.prototype, "rewardMode", {
                    get: $util.oneOfGetter($oneOfFields = ["rewardToNeuron", "rewardToAccount"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new RewardNodeProvider instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.IRewardNodeProvider=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.RewardNodeProvider} RewardNodeProvider instance
                 */
                RewardNodeProvider.create = function create(properties) {
                    return new RewardNodeProvider(properties);
                };

                /**
                 * Encodes the specified RewardNodeProvider message. Does not implicitly {@link ic_nns_governance.pb.v1.RewardNodeProvider.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.IRewardNodeProvider} message RewardNodeProvider message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardNodeProvider.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodeProvider != null && Object.hasOwnProperty.call(message, "nodeProvider"))
                        $root.ic_nns_governance.pb.v1.NodeProvider.encode(message.nodeProvider, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.amountE8s != null && Object.hasOwnProperty.call(message, "amountE8s"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amountE8s);
                    if (message.rewardToNeuron != null && Object.hasOwnProperty.call(message, "rewardToNeuron"))
                        $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron.encode(message.rewardToNeuron, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.rewardToAccount != null && Object.hasOwnProperty.call(message, "rewardToAccount"))
                        $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount.encode(message.rewardToAccount, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RewardNodeProvider message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.RewardNodeProvider.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.IRewardNodeProvider} message RewardNodeProvider message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardNodeProvider.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RewardNodeProvider message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.RewardNodeProvider} RewardNodeProvider
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardNodeProvider.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.RewardNodeProvider();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nodeProvider = $root.ic_nns_governance.pb.v1.NodeProvider.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.amountE8s = reader.uint64();
                            break;
                        case 4:
                            message.rewardToNeuron = $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.rewardToAccount = $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RewardNodeProvider message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.RewardNodeProvider} RewardNodeProvider
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardNodeProvider.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RewardNodeProvider message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RewardNodeProvider.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.nodeProvider != null && message.hasOwnProperty("nodeProvider")) {
                        let error = $root.ic_nns_governance.pb.v1.NodeProvider.verify(message.nodeProvider);
                        if (error)
                            return "nodeProvider." + error;
                    }
                    if (message.amountE8s != null && message.hasOwnProperty("amountE8s"))
                        if (!$util.isInteger(message.amountE8s) && !(message.amountE8s && $util.isInteger(message.amountE8s.low) && $util.isInteger(message.amountE8s.high)))
                            return "amountE8s: integer|Long expected";
                    if (message.rewardToNeuron != null && message.hasOwnProperty("rewardToNeuron")) {
                        properties.rewardMode = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron.verify(message.rewardToNeuron);
                            if (error)
                                return "rewardToNeuron." + error;
                        }
                    }
                    if (message.rewardToAccount != null && message.hasOwnProperty("rewardToAccount")) {
                        if (properties.rewardMode === 1)
                            return "rewardMode: multiple values";
                        properties.rewardMode = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount.verify(message.rewardToAccount);
                            if (error)
                                return "rewardToAccount." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a RewardNodeProvider message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.RewardNodeProvider} RewardNodeProvider
                 */
                RewardNodeProvider.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.RewardNodeProvider)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.RewardNodeProvider();
                    if (object.nodeProvider != null) {
                        if (typeof object.nodeProvider !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.RewardNodeProvider.nodeProvider: object expected");
                        message.nodeProvider = $root.ic_nns_governance.pb.v1.NodeProvider.fromObject(object.nodeProvider);
                    }
                    if (object.amountE8s != null)
                        if ($util.Long)
                            (message.amountE8s = $util.Long.fromValue(object.amountE8s)).unsigned = true;
                        else if (typeof object.amountE8s === "string")
                            message.amountE8s = parseInt(object.amountE8s, 10);
                        else if (typeof object.amountE8s === "number")
                            message.amountE8s = object.amountE8s;
                        else if (typeof object.amountE8s === "object")
                            message.amountE8s = new $util.LongBits(object.amountE8s.low >>> 0, object.amountE8s.high >>> 0).toNumber(true);
                    if (object.rewardToNeuron != null) {
                        if (typeof object.rewardToNeuron !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.RewardNodeProvider.rewardToNeuron: object expected");
                        message.rewardToNeuron = $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron.fromObject(object.rewardToNeuron);
                    }
                    if (object.rewardToAccount != null) {
                        if (typeof object.rewardToAccount !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.RewardNodeProvider.rewardToAccount: object expected");
                        message.rewardToAccount = $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount.fromObject(object.rewardToAccount);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RewardNodeProvider message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @static
                 * @param {ic_nns_governance.pb.v1.RewardNodeProvider} message RewardNodeProvider
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RewardNodeProvider.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.nodeProvider = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.amountE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.amountE8s = options.longs === String ? "0" : 0;
                    }
                    if (message.nodeProvider != null && message.hasOwnProperty("nodeProvider"))
                        object.nodeProvider = $root.ic_nns_governance.pb.v1.NodeProvider.toObject(message.nodeProvider, options);
                    if (message.amountE8s != null && message.hasOwnProperty("amountE8s"))
                        if (typeof message.amountE8s === "number")
                            object.amountE8s = options.longs === String ? String(message.amountE8s) : message.amountE8s;
                        else
                            object.amountE8s = options.longs === String ? $util.Long.prototype.toString.call(message.amountE8s) : options.longs === Number ? new $util.LongBits(message.amountE8s.low >>> 0, message.amountE8s.high >>> 0).toNumber(true) : message.amountE8s;
                    if (message.rewardToNeuron != null && message.hasOwnProperty("rewardToNeuron")) {
                        object.rewardToNeuron = $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron.toObject(message.rewardToNeuron, options);
                        if (options.oneofs)
                            object.rewardMode = "rewardToNeuron";
                    }
                    if (message.rewardToAccount != null && message.hasOwnProperty("rewardToAccount")) {
                        object.rewardToAccount = $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount.toObject(message.rewardToAccount, options);
                        if (options.oneofs)
                            object.rewardMode = "rewardToAccount";
                    }
                    return object;
                };

                /**
                 * Converts this RewardNodeProvider to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RewardNodeProvider.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                RewardNodeProvider.RewardToNeuron = (function() {

                    /**
                     * Properties of a RewardToNeuron.
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                     * @interface IRewardToNeuron
                     * @property {number|Long|null} [dissolveDelaySeconds] RewardToNeuron dissolveDelaySeconds
                     */

                    /**
                     * Constructs a new RewardToNeuron.
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                     * @classdesc Represents a RewardToNeuron.
                     * @implements IRewardToNeuron
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToNeuron=} [properties] Properties to set
                     */
                    function RewardToNeuron(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * RewardToNeuron dissolveDelaySeconds.
                     * @member {number|Long} dissolveDelaySeconds
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron
                     * @instance
                     */
                    RewardToNeuron.prototype.dissolveDelaySeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new RewardToNeuron instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron
                     * @static
                     * @param {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToNeuron=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron} RewardToNeuron instance
                     */
                    RewardToNeuron.create = function create(properties) {
                        return new RewardToNeuron(properties);
                    };

                    /**
                     * Encodes the specified RewardToNeuron message. Does not implicitly {@link ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron
                     * @static
                     * @param {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToNeuron} message RewardToNeuron message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RewardToNeuron.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.dissolveDelaySeconds != null && Object.hasOwnProperty.call(message, "dissolveDelaySeconds"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.dissolveDelaySeconds);
                        return writer;
                    };

                    /**
                     * Encodes the specified RewardToNeuron message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron
                     * @static
                     * @param {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToNeuron} message RewardToNeuron message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RewardToNeuron.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a RewardToNeuron message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron} RewardToNeuron
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RewardToNeuron.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.dissolveDelaySeconds = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a RewardToNeuron message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron} RewardToNeuron
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RewardToNeuron.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a RewardToNeuron message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RewardToNeuron.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.dissolveDelaySeconds != null && message.hasOwnProperty("dissolveDelaySeconds"))
                            if (!$util.isInteger(message.dissolveDelaySeconds) && !(message.dissolveDelaySeconds && $util.isInteger(message.dissolveDelaySeconds.low) && $util.isInteger(message.dissolveDelaySeconds.high)))
                                return "dissolveDelaySeconds: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a RewardToNeuron message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron} RewardToNeuron
                     */
                    RewardToNeuron.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron();
                        if (object.dissolveDelaySeconds != null)
                            if ($util.Long)
                                (message.dissolveDelaySeconds = $util.Long.fromValue(object.dissolveDelaySeconds)).unsigned = true;
                            else if (typeof object.dissolveDelaySeconds === "string")
                                message.dissolveDelaySeconds = parseInt(object.dissolveDelaySeconds, 10);
                            else if (typeof object.dissolveDelaySeconds === "number")
                                message.dissolveDelaySeconds = object.dissolveDelaySeconds;
                            else if (typeof object.dissolveDelaySeconds === "object")
                                message.dissolveDelaySeconds = new $util.LongBits(object.dissolveDelaySeconds.low >>> 0, object.dissolveDelaySeconds.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a RewardToNeuron message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron
                     * @static
                     * @param {ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron} message RewardToNeuron
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RewardToNeuron.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.dissolveDelaySeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.dissolveDelaySeconds = options.longs === String ? "0" : 0;
                        if (message.dissolveDelaySeconds != null && message.hasOwnProperty("dissolveDelaySeconds"))
                            if (typeof message.dissolveDelaySeconds === "number")
                                object.dissolveDelaySeconds = options.longs === String ? String(message.dissolveDelaySeconds) : message.dissolveDelaySeconds;
                            else
                                object.dissolveDelaySeconds = options.longs === String ? $util.Long.prototype.toString.call(message.dissolveDelaySeconds) : options.longs === Number ? new $util.LongBits(message.dissolveDelaySeconds.low >>> 0, message.dissolveDelaySeconds.high >>> 0).toNumber(true) : message.dissolveDelaySeconds;
                        return object;
                    };

                    /**
                     * Converts this RewardToNeuron to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToNeuron
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RewardToNeuron.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return RewardToNeuron;
                })();

                RewardNodeProvider.RewardToAccount = (function() {

                    /**
                     * Properties of a RewardToAccount.
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                     * @interface IRewardToAccount
                     * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [toAccount] RewardToAccount toAccount
                     */

                    /**
                     * Constructs a new RewardToAccount.
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider
                     * @classdesc Represents a RewardToAccount.
                     * @implements IRewardToAccount
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToAccount=} [properties] Properties to set
                     */
                    function RewardToAccount(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * RewardToAccount toAccount.
                     * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} toAccount
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount
                     * @instance
                     */
                    RewardToAccount.prototype.toAccount = null;

                    /**
                     * Creates a new RewardToAccount instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount
                     * @static
                     * @param {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToAccount=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount} RewardToAccount instance
                     */
                    RewardToAccount.create = function create(properties) {
                        return new RewardToAccount(properties);
                    };

                    /**
                     * Encodes the specified RewardToAccount message. Does not implicitly {@link ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount
                     * @static
                     * @param {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToAccount} message RewardToAccount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RewardToAccount.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.toAccount != null && Object.hasOwnProperty.call(message, "toAccount"))
                            $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.toAccount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified RewardToAccount message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount
                     * @static
                     * @param {ic_nns_governance.pb.v1.RewardNodeProvider.IRewardToAccount} message RewardToAccount message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RewardToAccount.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a RewardToAccount message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount} RewardToAccount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RewardToAccount.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.toAccount = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a RewardToAccount message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount} RewardToAccount
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RewardToAccount.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a RewardToAccount message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RewardToAccount.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.toAccount != null && message.hasOwnProperty("toAccount")) {
                            let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.toAccount);
                            if (error)
                                return "toAccount." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a RewardToAccount message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount} RewardToAccount
                     */
                    RewardToAccount.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount();
                        if (object.toAccount != null) {
                            if (typeof object.toAccount !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount.toAccount: object expected");
                            message.toAccount = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.toAccount);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a RewardToAccount message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount
                     * @static
                     * @param {ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount} message RewardToAccount
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RewardToAccount.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.toAccount = null;
                        if (message.toAccount != null && message.hasOwnProperty("toAccount"))
                            object.toAccount = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.toAccount, options);
                        return object;
                    };

                    /**
                     * Converts this RewardToAccount to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.RewardNodeProvider.RewardToAccount
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RewardToAccount.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return RewardToAccount;
                })();

                return RewardNodeProvider;
            })();

            v1.RewardNodeProviders = (function() {

                /**
                 * Properties of a RewardNodeProviders.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IRewardNodeProviders
                 * @property {Array.<ic_nns_governance.pb.v1.IRewardNodeProvider>|null} [rewards] RewardNodeProviders rewards
                 */

                /**
                 * Constructs a new RewardNodeProviders.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a RewardNodeProviders.
                 * @implements IRewardNodeProviders
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IRewardNodeProviders=} [properties] Properties to set
                 */
                function RewardNodeProviders(properties) {
                    this.rewards = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RewardNodeProviders rewards.
                 * @member {Array.<ic_nns_governance.pb.v1.IRewardNodeProvider>} rewards
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProviders
                 * @instance
                 */
                RewardNodeProviders.prototype.rewards = $util.emptyArray;

                /**
                 * Creates a new RewardNodeProviders instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProviders
                 * @static
                 * @param {ic_nns_governance.pb.v1.IRewardNodeProviders=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.RewardNodeProviders} RewardNodeProviders instance
                 */
                RewardNodeProviders.create = function create(properties) {
                    return new RewardNodeProviders(properties);
                };

                /**
                 * Encodes the specified RewardNodeProviders message. Does not implicitly {@link ic_nns_governance.pb.v1.RewardNodeProviders.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProviders
                 * @static
                 * @param {ic_nns_governance.pb.v1.IRewardNodeProviders} message RewardNodeProviders message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardNodeProviders.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rewards != null && message.rewards.length)
                        for (let i = 0; i < message.rewards.length; ++i)
                            $root.ic_nns_governance.pb.v1.RewardNodeProvider.encode(message.rewards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RewardNodeProviders message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.RewardNodeProviders.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProviders
                 * @static
                 * @param {ic_nns_governance.pb.v1.IRewardNodeProviders} message RewardNodeProviders message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardNodeProviders.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RewardNodeProviders message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProviders
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.RewardNodeProviders} RewardNodeProviders
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardNodeProviders.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.RewardNodeProviders();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.rewards && message.rewards.length))
                                message.rewards = [];
                            message.rewards.push($root.ic_nns_governance.pb.v1.RewardNodeProvider.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RewardNodeProviders message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProviders
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.RewardNodeProviders} RewardNodeProviders
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardNodeProviders.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RewardNodeProviders message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProviders
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RewardNodeProviders.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.rewards != null && message.hasOwnProperty("rewards")) {
                        if (!Array.isArray(message.rewards))
                            return "rewards: array expected";
                        for (let i = 0; i < message.rewards.length; ++i) {
                            let error = $root.ic_nns_governance.pb.v1.RewardNodeProvider.verify(message.rewards[i]);
                            if (error)
                                return "rewards." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a RewardNodeProviders message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProviders
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.RewardNodeProviders} RewardNodeProviders
                 */
                RewardNodeProviders.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.RewardNodeProviders)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.RewardNodeProviders();
                    if (object.rewards) {
                        if (!Array.isArray(object.rewards))
                            throw TypeError(".ic_nns_governance.pb.v1.RewardNodeProviders.rewards: array expected");
                        message.rewards = [];
                        for (let i = 0; i < object.rewards.length; ++i) {
                            if (typeof object.rewards[i] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.RewardNodeProviders.rewards: object expected");
                            message.rewards[i] = $root.ic_nns_governance.pb.v1.RewardNodeProvider.fromObject(object.rewards[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RewardNodeProviders message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProviders
                 * @static
                 * @param {ic_nns_governance.pb.v1.RewardNodeProviders} message RewardNodeProviders
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RewardNodeProviders.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.rewards = [];
                    if (message.rewards && message.rewards.length) {
                        object.rewards = [];
                        for (let j = 0; j < message.rewards.length; ++j)
                            object.rewards[j] = $root.ic_nns_governance.pb.v1.RewardNodeProvider.toObject(message.rewards[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this RewardNodeProviders to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.RewardNodeProviders
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RewardNodeProviders.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RewardNodeProviders;
            })();

            v1.SetDefaultFollowees = (function() {

                /**
                 * Properties of a SetDefaultFollowees.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface ISetDefaultFollowees
                 * @property {Object.<string,ic_nns_governance.pb.v1.Neuron.IFollowees>|null} [defaultFollowees] SetDefaultFollowees defaultFollowees
                 */

                /**
                 * Constructs a new SetDefaultFollowees.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a SetDefaultFollowees.
                 * @implements ISetDefaultFollowees
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.ISetDefaultFollowees=} [properties] Properties to set
                 */
                function SetDefaultFollowees(properties) {
                    this.defaultFollowees = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SetDefaultFollowees defaultFollowees.
                 * @member {Object.<string,ic_nns_governance.pb.v1.Neuron.IFollowees>} defaultFollowees
                 * @memberof ic_nns_governance.pb.v1.SetDefaultFollowees
                 * @instance
                 */
                SetDefaultFollowees.prototype.defaultFollowees = $util.emptyObject;

                /**
                 * Creates a new SetDefaultFollowees instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.SetDefaultFollowees
                 * @static
                 * @param {ic_nns_governance.pb.v1.ISetDefaultFollowees=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.SetDefaultFollowees} SetDefaultFollowees instance
                 */
                SetDefaultFollowees.create = function create(properties) {
                    return new SetDefaultFollowees(properties);
                };

                /**
                 * Encodes the specified SetDefaultFollowees message. Does not implicitly {@link ic_nns_governance.pb.v1.SetDefaultFollowees.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.SetDefaultFollowees
                 * @static
                 * @param {ic_nns_governance.pb.v1.ISetDefaultFollowees} message SetDefaultFollowees message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetDefaultFollowees.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.defaultFollowees != null && Object.hasOwnProperty.call(message, "defaultFollowees"))
                        for (let keys = Object.keys(message.defaultFollowees), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).int32(keys[i]);
                            $root.ic_nns_governance.pb.v1.Neuron.Followees.encode(message.defaultFollowees[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };

                /**
                 * Encodes the specified SetDefaultFollowees message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.SetDefaultFollowees.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.SetDefaultFollowees
                 * @static
                 * @param {ic_nns_governance.pb.v1.ISetDefaultFollowees} message SetDefaultFollowees message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetDefaultFollowees.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SetDefaultFollowees message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.SetDefaultFollowees
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.SetDefaultFollowees} SetDefaultFollowees
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetDefaultFollowees.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.SetDefaultFollowees(), key, value;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (message.defaultFollowees === $util.emptyObject)
                                message.defaultFollowees = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.int32();
                                    break;
                                case 2:
                                    value = $root.ic_nns_governance.pb.v1.Neuron.Followees.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.defaultFollowees[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SetDefaultFollowees message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.SetDefaultFollowees
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.SetDefaultFollowees} SetDefaultFollowees
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetDefaultFollowees.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SetDefaultFollowees message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.SetDefaultFollowees
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SetDefaultFollowees.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.defaultFollowees != null && message.hasOwnProperty("defaultFollowees")) {
                        if (!$util.isObject(message.defaultFollowees))
                            return "defaultFollowees: object expected";
                        let key = Object.keys(message.defaultFollowees);
                        for (let i = 0; i < key.length; ++i) {
                            if (!$util.key32Re.test(key[i]))
                                return "defaultFollowees: integer key{k:int32} expected";
                            {
                                let error = $root.ic_nns_governance.pb.v1.Neuron.Followees.verify(message.defaultFollowees[key[i]]);
                                if (error)
                                    return "defaultFollowees." + error;
                            }
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SetDefaultFollowees message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.SetDefaultFollowees
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.SetDefaultFollowees} SetDefaultFollowees
                 */
                SetDefaultFollowees.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.SetDefaultFollowees)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.SetDefaultFollowees();
                    if (object.defaultFollowees) {
                        if (typeof object.defaultFollowees !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.SetDefaultFollowees.defaultFollowees: object expected");
                        message.defaultFollowees = {};
                        for (let keys = Object.keys(object.defaultFollowees), i = 0; i < keys.length; ++i) {
                            if (typeof object.defaultFollowees[keys[i]] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.SetDefaultFollowees.defaultFollowees: object expected");
                            message.defaultFollowees[keys[i]] = $root.ic_nns_governance.pb.v1.Neuron.Followees.fromObject(object.defaultFollowees[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SetDefaultFollowees message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.SetDefaultFollowees
                 * @static
                 * @param {ic_nns_governance.pb.v1.SetDefaultFollowees} message SetDefaultFollowees
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SetDefaultFollowees.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.defaultFollowees = {};
                    let keys2;
                    if (message.defaultFollowees && (keys2 = Object.keys(message.defaultFollowees)).length) {
                        object.defaultFollowees = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.defaultFollowees[keys2[j]] = $root.ic_nns_governance.pb.v1.Neuron.Followees.toObject(message.defaultFollowees[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this SetDefaultFollowees to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.SetDefaultFollowees
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SetDefaultFollowees.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SetDefaultFollowees;
            })();

            v1.Proposal = (function() {

                /**
                 * Properties of a Proposal.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IProposal
                 * @property {string|null} [title] Proposal title
                 * @property {string|null} [summary] Proposal summary
                 * @property {string|null} [url] Proposal url
                 * @property {ic_nns_governance.pb.v1.IManageNeuron|null} [manageNeuron] Proposal manageNeuron
                 * @property {ic_nns_governance.pb.v1.INetworkEconomics|null} [manageNetworkEconomics] Proposal manageNetworkEconomics
                 * @property {ic_nns_governance.pb.v1.IMotion|null} [motion] Proposal motion
                 * @property {ic_nns_governance.pb.v1.IExecuteNnsFunction|null} [executeNnsFunction] Proposal executeNnsFunction
                 * @property {ic_nns_governance.pb.v1.IApproveGenesisKYC|null} [approveGenesisKyc] Proposal approveGenesisKyc
                 * @property {ic_nns_governance.pb.v1.IAddOrRemoveNodeProvider|null} [addOrRemoveNodeProvider] Proposal addOrRemoveNodeProvider
                 * @property {ic_nns_governance.pb.v1.IRewardNodeProvider|null} [rewardNodeProvider] Proposal rewardNodeProvider
                 * @property {ic_nns_governance.pb.v1.ISetDefaultFollowees|null} [setDefaultFollowees] Proposal setDefaultFollowees
                 * @property {ic_nns_governance.pb.v1.IRewardNodeProviders|null} [rewardNodeProviders] Proposal rewardNodeProviders
                 */

                /**
                 * Constructs a new Proposal.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a Proposal.
                 * @implements IProposal
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IProposal=} [properties] Properties to set
                 */
                function Proposal(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Proposal title.
                 * @member {string|null|undefined} title
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.title = null;

                /**
                 * Proposal summary.
                 * @member {string} summary
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.summary = "";

                /**
                 * Proposal url.
                 * @member {string} url
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.url = "";

                /**
                 * Proposal manageNeuron.
                 * @member {ic_nns_governance.pb.v1.IManageNeuron|null|undefined} manageNeuron
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.manageNeuron = null;

                /**
                 * Proposal manageNetworkEconomics.
                 * @member {ic_nns_governance.pb.v1.INetworkEconomics|null|undefined} manageNetworkEconomics
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.manageNetworkEconomics = null;

                /**
                 * Proposal motion.
                 * @member {ic_nns_governance.pb.v1.IMotion|null|undefined} motion
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.motion = null;

                /**
                 * Proposal executeNnsFunction.
                 * @member {ic_nns_governance.pb.v1.IExecuteNnsFunction|null|undefined} executeNnsFunction
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.executeNnsFunction = null;

                /**
                 * Proposal approveGenesisKyc.
                 * @member {ic_nns_governance.pb.v1.IApproveGenesisKYC|null|undefined} approveGenesisKyc
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.approveGenesisKyc = null;

                /**
                 * Proposal addOrRemoveNodeProvider.
                 * @member {ic_nns_governance.pb.v1.IAddOrRemoveNodeProvider|null|undefined} addOrRemoveNodeProvider
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.addOrRemoveNodeProvider = null;

                /**
                 * Proposal rewardNodeProvider.
                 * @member {ic_nns_governance.pb.v1.IRewardNodeProvider|null|undefined} rewardNodeProvider
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.rewardNodeProvider = null;

                /**
                 * Proposal setDefaultFollowees.
                 * @member {ic_nns_governance.pb.v1.ISetDefaultFollowees|null|undefined} setDefaultFollowees
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.setDefaultFollowees = null;

                /**
                 * Proposal rewardNodeProviders.
                 * @member {ic_nns_governance.pb.v1.IRewardNodeProviders|null|undefined} rewardNodeProviders
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Proposal.prototype.rewardNodeProviders = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Proposal _title.
                 * @member {"title"|undefined} _title
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Object.defineProperty(Proposal.prototype, "_title", {
                    get: $util.oneOfGetter($oneOfFields = ["title"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Proposal action.
                 * @member {"manageNeuron"|"manageNetworkEconomics"|"motion"|"executeNnsFunction"|"approveGenesisKyc"|"addOrRemoveNodeProvider"|"rewardNodeProvider"|"setDefaultFollowees"|"rewardNodeProviders"|undefined} action
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 */
                Object.defineProperty(Proposal.prototype, "action", {
                    get: $util.oneOfGetter($oneOfFields = ["manageNeuron", "manageNetworkEconomics", "motion", "executeNnsFunction", "approveGenesisKyc", "addOrRemoveNodeProvider", "rewardNodeProvider", "setDefaultFollowees", "rewardNodeProviders"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Proposal instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @static
                 * @param {ic_nns_governance.pb.v1.IProposal=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.Proposal} Proposal instance
                 */
                Proposal.create = function create(properties) {
                    return new Proposal(properties);
                };

                /**
                 * Encodes the specified Proposal message. Does not implicitly {@link ic_nns_governance.pb.v1.Proposal.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @static
                 * @param {ic_nns_governance.pb.v1.IProposal} message Proposal message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Proposal.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.summary != null && Object.hasOwnProperty.call(message, "summary"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.summary);
                    if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                    if (message.manageNeuron != null && Object.hasOwnProperty.call(message, "manageNeuron"))
                        $root.ic_nns_governance.pb.v1.ManageNeuron.encode(message.manageNeuron, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.manageNetworkEconomics != null && Object.hasOwnProperty.call(message, "manageNetworkEconomics"))
                        $root.ic_nns_governance.pb.v1.NetworkEconomics.encode(message.manageNetworkEconomics, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.motion != null && Object.hasOwnProperty.call(message, "motion"))
                        $root.ic_nns_governance.pb.v1.Motion.encode(message.motion, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.executeNnsFunction != null && Object.hasOwnProperty.call(message, "executeNnsFunction"))
                        $root.ic_nns_governance.pb.v1.ExecuteNnsFunction.encode(message.executeNnsFunction, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.approveGenesisKyc != null && Object.hasOwnProperty.call(message, "approveGenesisKyc"))
                        $root.ic_nns_governance.pb.v1.ApproveGenesisKYC.encode(message.approveGenesisKyc, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.addOrRemoveNodeProvider != null && Object.hasOwnProperty.call(message, "addOrRemoveNodeProvider"))
                        $root.ic_nns_governance.pb.v1.AddOrRemoveNodeProvider.encode(message.addOrRemoveNodeProvider, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.rewardNodeProvider != null && Object.hasOwnProperty.call(message, "rewardNodeProvider"))
                        $root.ic_nns_governance.pb.v1.RewardNodeProvider.encode(message.rewardNodeProvider, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.setDefaultFollowees != null && Object.hasOwnProperty.call(message, "setDefaultFollowees"))
                        $root.ic_nns_governance.pb.v1.SetDefaultFollowees.encode(message.setDefaultFollowees, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    if (message.rewardNodeProviders != null && Object.hasOwnProperty.call(message, "rewardNodeProviders"))
                        $root.ic_nns_governance.pb.v1.RewardNodeProviders.encode(message.rewardNodeProviders, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                    if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                        writer.uint32(/* id 20, wireType 2 =*/162).string(message.title);
                    return writer;
                };

                /**
                 * Encodes the specified Proposal message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.Proposal.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @static
                 * @param {ic_nns_governance.pb.v1.IProposal} message Proposal message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Proposal.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Proposal message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.Proposal} Proposal
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Proposal.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.Proposal();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 20:
                            message.title = reader.string();
                            break;
                        case 1:
                            message.summary = reader.string();
                            break;
                        case 2:
                            message.url = reader.string();
                            break;
                        case 10:
                            message.manageNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.manageNetworkEconomics = $root.ic_nns_governance.pb.v1.NetworkEconomics.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.motion = $root.ic_nns_governance.pb.v1.Motion.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.executeNnsFunction = $root.ic_nns_governance.pb.v1.ExecuteNnsFunction.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.approveGenesisKyc = $root.ic_nns_governance.pb.v1.ApproveGenesisKYC.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.addOrRemoveNodeProvider = $root.ic_nns_governance.pb.v1.AddOrRemoveNodeProvider.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.rewardNodeProvider = $root.ic_nns_governance.pb.v1.RewardNodeProvider.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.setDefaultFollowees = $root.ic_nns_governance.pb.v1.SetDefaultFollowees.decode(reader, reader.uint32());
                            break;
                        case 19:
                            message.rewardNodeProviders = $root.ic_nns_governance.pb.v1.RewardNodeProviders.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Proposal message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.Proposal} Proposal
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Proposal.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Proposal message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Proposal.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.title != null && message.hasOwnProperty("title")) {
                        properties._title = 1;
                        if (!$util.isString(message.title))
                            return "title: string expected";
                    }
                    if (message.summary != null && message.hasOwnProperty("summary"))
                        if (!$util.isString(message.summary))
                            return "summary: string expected";
                    if (message.url != null && message.hasOwnProperty("url"))
                        if (!$util.isString(message.url))
                            return "url: string expected";
                    if (message.manageNeuron != null && message.hasOwnProperty("manageNeuron")) {
                        properties.action = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuron.verify(message.manageNeuron);
                            if (error)
                                return "manageNeuron." + error;
                        }
                    }
                    if (message.manageNetworkEconomics != null && message.hasOwnProperty("manageNetworkEconomics")) {
                        if (properties.action === 1)
                            return "action: multiple values";
                        properties.action = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.NetworkEconomics.verify(message.manageNetworkEconomics);
                            if (error)
                                return "manageNetworkEconomics." + error;
                        }
                    }
                    if (message.motion != null && message.hasOwnProperty("motion")) {
                        if (properties.action === 1)
                            return "action: multiple values";
                        properties.action = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.Motion.verify(message.motion);
                            if (error)
                                return "motion." + error;
                        }
                    }
                    if (message.executeNnsFunction != null && message.hasOwnProperty("executeNnsFunction")) {
                        if (properties.action === 1)
                            return "action: multiple values";
                        properties.action = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ExecuteNnsFunction.verify(message.executeNnsFunction);
                            if (error)
                                return "executeNnsFunction." + error;
                        }
                    }
                    if (message.approveGenesisKyc != null && message.hasOwnProperty("approveGenesisKyc")) {
                        if (properties.action === 1)
                            return "action: multiple values";
                        properties.action = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ApproveGenesisKYC.verify(message.approveGenesisKyc);
                            if (error)
                                return "approveGenesisKyc." + error;
                        }
                    }
                    if (message.addOrRemoveNodeProvider != null && message.hasOwnProperty("addOrRemoveNodeProvider")) {
                        if (properties.action === 1)
                            return "action: multiple values";
                        properties.action = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.AddOrRemoveNodeProvider.verify(message.addOrRemoveNodeProvider);
                            if (error)
                                return "addOrRemoveNodeProvider." + error;
                        }
                    }
                    if (message.rewardNodeProvider != null && message.hasOwnProperty("rewardNodeProvider")) {
                        if (properties.action === 1)
                            return "action: multiple values";
                        properties.action = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.RewardNodeProvider.verify(message.rewardNodeProvider);
                            if (error)
                                return "rewardNodeProvider." + error;
                        }
                    }
                    if (message.setDefaultFollowees != null && message.hasOwnProperty("setDefaultFollowees")) {
                        if (properties.action === 1)
                            return "action: multiple values";
                        properties.action = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.SetDefaultFollowees.verify(message.setDefaultFollowees);
                            if (error)
                                return "setDefaultFollowees." + error;
                        }
                    }
                    if (message.rewardNodeProviders != null && message.hasOwnProperty("rewardNodeProviders")) {
                        if (properties.action === 1)
                            return "action: multiple values";
                        properties.action = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.RewardNodeProviders.verify(message.rewardNodeProviders);
                            if (error)
                                return "rewardNodeProviders." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Proposal message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.Proposal} Proposal
                 */
                Proposal.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.Proposal)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.Proposal();
                    if (object.title != null)
                        message.title = String(object.title);
                    if (object.summary != null)
                        message.summary = String(object.summary);
                    if (object.url != null)
                        message.url = String(object.url);
                    if (object.manageNeuron != null) {
                        if (typeof object.manageNeuron !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Proposal.manageNeuron: object expected");
                        message.manageNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.fromObject(object.manageNeuron);
                    }
                    if (object.manageNetworkEconomics != null) {
                        if (typeof object.manageNetworkEconomics !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Proposal.manageNetworkEconomics: object expected");
                        message.manageNetworkEconomics = $root.ic_nns_governance.pb.v1.NetworkEconomics.fromObject(object.manageNetworkEconomics);
                    }
                    if (object.motion != null) {
                        if (typeof object.motion !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Proposal.motion: object expected");
                        message.motion = $root.ic_nns_governance.pb.v1.Motion.fromObject(object.motion);
                    }
                    if (object.executeNnsFunction != null) {
                        if (typeof object.executeNnsFunction !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Proposal.executeNnsFunction: object expected");
                        message.executeNnsFunction = $root.ic_nns_governance.pb.v1.ExecuteNnsFunction.fromObject(object.executeNnsFunction);
                    }
                    if (object.approveGenesisKyc != null) {
                        if (typeof object.approveGenesisKyc !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Proposal.approveGenesisKyc: object expected");
                        message.approveGenesisKyc = $root.ic_nns_governance.pb.v1.ApproveGenesisKYC.fromObject(object.approveGenesisKyc);
                    }
                    if (object.addOrRemoveNodeProvider != null) {
                        if (typeof object.addOrRemoveNodeProvider !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Proposal.addOrRemoveNodeProvider: object expected");
                        message.addOrRemoveNodeProvider = $root.ic_nns_governance.pb.v1.AddOrRemoveNodeProvider.fromObject(object.addOrRemoveNodeProvider);
                    }
                    if (object.rewardNodeProvider != null) {
                        if (typeof object.rewardNodeProvider !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Proposal.rewardNodeProvider: object expected");
                        message.rewardNodeProvider = $root.ic_nns_governance.pb.v1.RewardNodeProvider.fromObject(object.rewardNodeProvider);
                    }
                    if (object.setDefaultFollowees != null) {
                        if (typeof object.setDefaultFollowees !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Proposal.setDefaultFollowees: object expected");
                        message.setDefaultFollowees = $root.ic_nns_governance.pb.v1.SetDefaultFollowees.fromObject(object.setDefaultFollowees);
                    }
                    if (object.rewardNodeProviders != null) {
                        if (typeof object.rewardNodeProviders !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Proposal.rewardNodeProviders: object expected");
                        message.rewardNodeProviders = $root.ic_nns_governance.pb.v1.RewardNodeProviders.fromObject(object.rewardNodeProviders);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Proposal message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @static
                 * @param {ic_nns_governance.pb.v1.Proposal} message Proposal
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Proposal.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.summary = "";
                        object.url = "";
                    }
                    if (message.summary != null && message.hasOwnProperty("summary"))
                        object.summary = message.summary;
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = message.url;
                    if (message.manageNeuron != null && message.hasOwnProperty("manageNeuron")) {
                        object.manageNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.toObject(message.manageNeuron, options);
                        if (options.oneofs)
                            object.action = "manageNeuron";
                    }
                    if (message.manageNetworkEconomics != null && message.hasOwnProperty("manageNetworkEconomics")) {
                        object.manageNetworkEconomics = $root.ic_nns_governance.pb.v1.NetworkEconomics.toObject(message.manageNetworkEconomics, options);
                        if (options.oneofs)
                            object.action = "manageNetworkEconomics";
                    }
                    if (message.motion != null && message.hasOwnProperty("motion")) {
                        object.motion = $root.ic_nns_governance.pb.v1.Motion.toObject(message.motion, options);
                        if (options.oneofs)
                            object.action = "motion";
                    }
                    if (message.executeNnsFunction != null && message.hasOwnProperty("executeNnsFunction")) {
                        object.executeNnsFunction = $root.ic_nns_governance.pb.v1.ExecuteNnsFunction.toObject(message.executeNnsFunction, options);
                        if (options.oneofs)
                            object.action = "executeNnsFunction";
                    }
                    if (message.approveGenesisKyc != null && message.hasOwnProperty("approveGenesisKyc")) {
                        object.approveGenesisKyc = $root.ic_nns_governance.pb.v1.ApproveGenesisKYC.toObject(message.approveGenesisKyc, options);
                        if (options.oneofs)
                            object.action = "approveGenesisKyc";
                    }
                    if (message.addOrRemoveNodeProvider != null && message.hasOwnProperty("addOrRemoveNodeProvider")) {
                        object.addOrRemoveNodeProvider = $root.ic_nns_governance.pb.v1.AddOrRemoveNodeProvider.toObject(message.addOrRemoveNodeProvider, options);
                        if (options.oneofs)
                            object.action = "addOrRemoveNodeProvider";
                    }
                    if (message.rewardNodeProvider != null && message.hasOwnProperty("rewardNodeProvider")) {
                        object.rewardNodeProvider = $root.ic_nns_governance.pb.v1.RewardNodeProvider.toObject(message.rewardNodeProvider, options);
                        if (options.oneofs)
                            object.action = "rewardNodeProvider";
                    }
                    if (message.setDefaultFollowees != null && message.hasOwnProperty("setDefaultFollowees")) {
                        object.setDefaultFollowees = $root.ic_nns_governance.pb.v1.SetDefaultFollowees.toObject(message.setDefaultFollowees, options);
                        if (options.oneofs)
                            object.action = "setDefaultFollowees";
                    }
                    if (message.rewardNodeProviders != null && message.hasOwnProperty("rewardNodeProviders")) {
                        object.rewardNodeProviders = $root.ic_nns_governance.pb.v1.RewardNodeProviders.toObject(message.rewardNodeProviders, options);
                        if (options.oneofs)
                            object.action = "rewardNodeProviders";
                    }
                    if (message.title != null && message.hasOwnProperty("title")) {
                        object.title = message.title;
                        if (options.oneofs)
                            object._title = "title";
                    }
                    return object;
                };

                /**
                 * Converts this Proposal to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.Proposal
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Proposal.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Proposal;
            })();

            v1.Empty = (function() {

                /**
                 * Properties of an Empty.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IEmpty
                 */

                /**
                 * Constructs a new Empty.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents an Empty.
                 * @implements IEmpty
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IEmpty=} [properties] Properties to set
                 */
                function Empty(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Empty instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.Empty
                 * @static
                 * @param {ic_nns_governance.pb.v1.IEmpty=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.Empty} Empty instance
                 */
                Empty.create = function create(properties) {
                    return new Empty(properties);
                };

                /**
                 * Encodes the specified Empty message. Does not implicitly {@link ic_nns_governance.pb.v1.Empty.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.Empty
                 * @static
                 * @param {ic_nns_governance.pb.v1.IEmpty} message Empty message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Empty.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Empty message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.Empty.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Empty
                 * @static
                 * @param {ic_nns_governance.pb.v1.IEmpty} message Empty message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Empty.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Empty message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.Empty
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.Empty} Empty
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Empty.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.Empty();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Empty message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Empty
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.Empty} Empty
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Empty.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Empty message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.Empty
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Empty.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an Empty message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.Empty
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.Empty} Empty
                 */
                Empty.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.Empty)
                        return object;
                    return new $root.ic_nns_governance.pb.v1.Empty();
                };

                /**
                 * Creates a plain object from an Empty message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.Empty
                 * @static
                 * @param {ic_nns_governance.pb.v1.Empty} message Empty
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Empty.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Empty to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.Empty
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Empty.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Empty;
            })();

            v1.ManageNeuron = (function() {

                /**
                 * Properties of a ManageNeuron.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IManageNeuron
                 * @property {ic_nns_common.pb.v1.INeuronId|null} [id] ManageNeuron id
                 * @property {Uint8Array|null} [subaccount] ManageNeuron subaccount
                 * @property {ic_nns_common.pb.v1.INeuronId|null} [neuronId] ManageNeuron neuronId
                 * @property {ic_nns_governance.pb.v1.ManageNeuron.IConfigure|null} [configure] ManageNeuron configure
                 * @property {ic_nns_governance.pb.v1.ManageNeuron.IDisburse|null} [disburse] ManageNeuron disburse
                 * @property {ic_nns_governance.pb.v1.ManageNeuron.ISpawn|null} [spawn] ManageNeuron spawn
                 * @property {ic_nns_governance.pb.v1.ManageNeuron.IFollow|null} [follow] ManageNeuron follow
                 * @property {ic_nns_governance.pb.v1.IProposal|null} [makeProposal] ManageNeuron makeProposal
                 * @property {ic_nns_governance.pb.v1.ManageNeuron.IRegisterVote|null} [registerVote] ManageNeuron registerVote
                 * @property {ic_nns_governance.pb.v1.ManageNeuron.ISplit|null} [split] ManageNeuron split
                 * @property {ic_nns_governance.pb.v1.ManageNeuron.IDisburseToNeuron|null} [disburseToNeuron] ManageNeuron disburseToNeuron
                 * @property {ic_nns_governance.pb.v1.ManageNeuron.IClaimOrRefresh|null} [claimOrRefresh] ManageNeuron claimOrRefresh
                 * @property {ic_nns_governance.pb.v1.ManageNeuron.IMergeMaturity|null} [mergeMaturity] ManageNeuron mergeMaturity
                 */

                /**
                 * Constructs a new ManageNeuron.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a ManageNeuron.
                 * @implements IManageNeuron
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IManageNeuron=} [properties] Properties to set
                 */
                function ManageNeuron(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ManageNeuron id.
                 * @member {ic_nns_common.pb.v1.INeuronId|null|undefined} id
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.id = null;

                /**
                 * ManageNeuron subaccount.
                 * @member {Uint8Array|null|undefined} subaccount
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.subaccount = null;

                /**
                 * ManageNeuron neuronId.
                 * @member {ic_nns_common.pb.v1.INeuronId|null|undefined} neuronId
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.neuronId = null;

                /**
                 * ManageNeuron configure.
                 * @member {ic_nns_governance.pb.v1.ManageNeuron.IConfigure|null|undefined} configure
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.configure = null;

                /**
                 * ManageNeuron disburse.
                 * @member {ic_nns_governance.pb.v1.ManageNeuron.IDisburse|null|undefined} disburse
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.disburse = null;

                /**
                 * ManageNeuron spawn.
                 * @member {ic_nns_governance.pb.v1.ManageNeuron.ISpawn|null|undefined} spawn
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.spawn = null;

                /**
                 * ManageNeuron follow.
                 * @member {ic_nns_governance.pb.v1.ManageNeuron.IFollow|null|undefined} follow
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.follow = null;

                /**
                 * ManageNeuron makeProposal.
                 * @member {ic_nns_governance.pb.v1.IProposal|null|undefined} makeProposal
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.makeProposal = null;

                /**
                 * ManageNeuron registerVote.
                 * @member {ic_nns_governance.pb.v1.ManageNeuron.IRegisterVote|null|undefined} registerVote
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.registerVote = null;

                /**
                 * ManageNeuron split.
                 * @member {ic_nns_governance.pb.v1.ManageNeuron.ISplit|null|undefined} split
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.split = null;

                /**
                 * ManageNeuron disburseToNeuron.
                 * @member {ic_nns_governance.pb.v1.ManageNeuron.IDisburseToNeuron|null|undefined} disburseToNeuron
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.disburseToNeuron = null;

                /**
                 * ManageNeuron claimOrRefresh.
                 * @member {ic_nns_governance.pb.v1.ManageNeuron.IClaimOrRefresh|null|undefined} claimOrRefresh
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.claimOrRefresh = null;

                /**
                 * ManageNeuron mergeMaturity.
                 * @member {ic_nns_governance.pb.v1.ManageNeuron.IMergeMaturity|null|undefined} mergeMaturity
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                ManageNeuron.prototype.mergeMaturity = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * ManageNeuron neuronIdOrSubaccount.
                 * @member {"subaccount"|"neuronId"|undefined} neuronIdOrSubaccount
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                Object.defineProperty(ManageNeuron.prototype, "neuronIdOrSubaccount", {
                    get: $util.oneOfGetter($oneOfFields = ["subaccount", "neuronId"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * ManageNeuron command.
                 * @member {"configure"|"disburse"|"spawn"|"follow"|"makeProposal"|"registerVote"|"split"|"disburseToNeuron"|"claimOrRefresh"|"mergeMaturity"|undefined} command
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 */
                Object.defineProperty(ManageNeuron.prototype, "command", {
                    get: $util.oneOfGetter($oneOfFields = ["configure", "disburse", "spawn", "follow", "makeProposal", "registerVote", "split", "disburseToNeuron", "claimOrRefresh", "mergeMaturity"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new ManageNeuron instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @static
                 * @param {ic_nns_governance.pb.v1.IManageNeuron=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ManageNeuron} ManageNeuron instance
                 */
                ManageNeuron.create = function create(properties) {
                    return new ManageNeuron(properties);
                };

                /**
                 * Encodes the specified ManageNeuron message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @static
                 * @param {ic_nns_governance.pb.v1.IManageNeuron} message ManageNeuron message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ManageNeuron.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        $root.ic_nns_common.pb.v1.NeuronId.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.configure != null && Object.hasOwnProperty.call(message, "configure"))
                        $root.ic_nns_governance.pb.v1.ManageNeuron.Configure.encode(message.configure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.disburse != null && Object.hasOwnProperty.call(message, "disburse"))
                        $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.encode(message.disburse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.spawn != null && Object.hasOwnProperty.call(message, "spawn"))
                        $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn.encode(message.spawn, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.follow != null && Object.hasOwnProperty.call(message, "follow"))
                        $root.ic_nns_governance.pb.v1.ManageNeuron.Follow.encode(message.follow, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.makeProposal != null && Object.hasOwnProperty.call(message, "makeProposal"))
                        $root.ic_nns_governance.pb.v1.Proposal.encode(message.makeProposal, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.registerVote != null && Object.hasOwnProperty.call(message, "registerVote"))
                        $root.ic_nns_governance.pb.v1.ManageNeuron.RegisterVote.encode(message.registerVote, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.split != null && Object.hasOwnProperty.call(message, "split"))
                        $root.ic_nns_governance.pb.v1.ManageNeuron.Split.encode(message.split, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.disburseToNeuron != null && Object.hasOwnProperty.call(message, "disburseToNeuron"))
                        $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.encode(message.disburseToNeuron, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.claimOrRefresh != null && Object.hasOwnProperty.call(message, "claimOrRefresh"))
                        $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.encode(message.claimOrRefresh, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.subaccount != null && Object.hasOwnProperty.call(message, "subaccount"))
                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.subaccount);
                    if (message.neuronId != null && Object.hasOwnProperty.call(message, "neuronId"))
                        $root.ic_nns_common.pb.v1.NeuronId.encode(message.neuronId, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.mergeMaturity != null && Object.hasOwnProperty.call(message, "mergeMaturity"))
                        $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.encode(message.mergeMaturity, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ManageNeuron message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @static
                 * @param {ic_nns_governance.pb.v1.IManageNeuron} message ManageNeuron message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ManageNeuron.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ManageNeuron message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ManageNeuron} ManageNeuron
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ManageNeuron.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.subaccount = reader.bytes();
                            break;
                        case 12:
                            message.neuronId = $root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.configure = $root.ic_nns_governance.pb.v1.ManageNeuron.Configure.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.disburse = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.spawn = $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.follow = $root.ic_nns_governance.pb.v1.ManageNeuron.Follow.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.makeProposal = $root.ic_nns_governance.pb.v1.Proposal.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.registerVote = $root.ic_nns_governance.pb.v1.ManageNeuron.RegisterVote.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.split = $root.ic_nns_governance.pb.v1.ManageNeuron.Split.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.disburseToNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.claimOrRefresh = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.mergeMaturity = $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ManageNeuron message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ManageNeuron} ManageNeuron
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ManageNeuron.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ManageNeuron message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ManageNeuron.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.id != null && message.hasOwnProperty("id")) {
                        let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.subaccount != null && message.hasOwnProperty("subaccount")) {
                        properties.neuronIdOrSubaccount = 1;
                        if (!(message.subaccount && typeof message.subaccount.length === "number" || $util.isString(message.subaccount)))
                            return "subaccount: buffer expected";
                    }
                    if (message.neuronId != null && message.hasOwnProperty("neuronId")) {
                        if (properties.neuronIdOrSubaccount === 1)
                            return "neuronIdOrSubaccount: multiple values";
                        properties.neuronIdOrSubaccount = 1;
                        {
                            let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.neuronId);
                            if (error)
                                return "neuronId." + error;
                        }
                    }
                    if (message.configure != null && message.hasOwnProperty("configure")) {
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuron.Configure.verify(message.configure);
                            if (error)
                                return "configure." + error;
                        }
                    }
                    if (message.disburse != null && message.hasOwnProperty("disburse")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.verify(message.disburse);
                            if (error)
                                return "disburse." + error;
                        }
                    }
                    if (message.spawn != null && message.hasOwnProperty("spawn")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn.verify(message.spawn);
                            if (error)
                                return "spawn." + error;
                        }
                    }
                    if (message.follow != null && message.hasOwnProperty("follow")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuron.Follow.verify(message.follow);
                            if (error)
                                return "follow." + error;
                        }
                    }
                    if (message.makeProposal != null && message.hasOwnProperty("makeProposal")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.Proposal.verify(message.makeProposal);
                            if (error)
                                return "makeProposal." + error;
                        }
                    }
                    if (message.registerVote != null && message.hasOwnProperty("registerVote")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuron.RegisterVote.verify(message.registerVote);
                            if (error)
                                return "registerVote." + error;
                        }
                    }
                    if (message.split != null && message.hasOwnProperty("split")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuron.Split.verify(message.split);
                            if (error)
                                return "split." + error;
                        }
                    }
                    if (message.disburseToNeuron != null && message.hasOwnProperty("disburseToNeuron")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.verify(message.disburseToNeuron);
                            if (error)
                                return "disburseToNeuron." + error;
                        }
                    }
                    if (message.claimOrRefresh != null && message.hasOwnProperty("claimOrRefresh")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.verify(message.claimOrRefresh);
                            if (error)
                                return "claimOrRefresh." + error;
                        }
                    }
                    if (message.mergeMaturity != null && message.hasOwnProperty("mergeMaturity")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.verify(message.mergeMaturity);
                            if (error)
                                return "mergeMaturity." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ManageNeuron message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ManageNeuron} ManageNeuron
                 */
                ManageNeuron.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ManageNeuron();
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.id: object expected");
                        message.id = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.id);
                    }
                    if (object.subaccount != null)
                        if (typeof object.subaccount === "string")
                            $util.base64.decode(object.subaccount, message.subaccount = $util.newBuffer($util.base64.length(object.subaccount)), 0);
                        else if (object.subaccount.length)
                            message.subaccount = object.subaccount;
                    if (object.neuronId != null) {
                        if (typeof object.neuronId !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.neuronId: object expected");
                        message.neuronId = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.neuronId);
                    }
                    if (object.configure != null) {
                        if (typeof object.configure !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.configure: object expected");
                        message.configure = $root.ic_nns_governance.pb.v1.ManageNeuron.Configure.fromObject(object.configure);
                    }
                    if (object.disburse != null) {
                        if (typeof object.disburse !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.disburse: object expected");
                        message.disburse = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.fromObject(object.disburse);
                    }
                    if (object.spawn != null) {
                        if (typeof object.spawn !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.spawn: object expected");
                        message.spawn = $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn.fromObject(object.spawn);
                    }
                    if (object.follow != null) {
                        if (typeof object.follow !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.follow: object expected");
                        message.follow = $root.ic_nns_governance.pb.v1.ManageNeuron.Follow.fromObject(object.follow);
                    }
                    if (object.makeProposal != null) {
                        if (typeof object.makeProposal !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.makeProposal: object expected");
                        message.makeProposal = $root.ic_nns_governance.pb.v1.Proposal.fromObject(object.makeProposal);
                    }
                    if (object.registerVote != null) {
                        if (typeof object.registerVote !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.registerVote: object expected");
                        message.registerVote = $root.ic_nns_governance.pb.v1.ManageNeuron.RegisterVote.fromObject(object.registerVote);
                    }
                    if (object.split != null) {
                        if (typeof object.split !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.split: object expected");
                        message.split = $root.ic_nns_governance.pb.v1.ManageNeuron.Split.fromObject(object.split);
                    }
                    if (object.disburseToNeuron != null) {
                        if (typeof object.disburseToNeuron !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.disburseToNeuron: object expected");
                        message.disburseToNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.fromObject(object.disburseToNeuron);
                    }
                    if (object.claimOrRefresh != null) {
                        if (typeof object.claimOrRefresh !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.claimOrRefresh: object expected");
                        message.claimOrRefresh = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.fromObject(object.claimOrRefresh);
                    }
                    if (object.mergeMaturity != null) {
                        if (typeof object.mergeMaturity !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.mergeMaturity: object expected");
                        message.mergeMaturity = $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.fromObject(object.mergeMaturity);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ManageNeuron message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @static
                 * @param {ic_nns_governance.pb.v1.ManageNeuron} message ManageNeuron
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ManageNeuron.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.id = null;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.id, options);
                    if (message.configure != null && message.hasOwnProperty("configure")) {
                        object.configure = $root.ic_nns_governance.pb.v1.ManageNeuron.Configure.toObject(message.configure, options);
                        if (options.oneofs)
                            object.command = "configure";
                    }
                    if (message.disburse != null && message.hasOwnProperty("disburse")) {
                        object.disburse = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.toObject(message.disburse, options);
                        if (options.oneofs)
                            object.command = "disburse";
                    }
                    if (message.spawn != null && message.hasOwnProperty("spawn")) {
                        object.spawn = $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn.toObject(message.spawn, options);
                        if (options.oneofs)
                            object.command = "spawn";
                    }
                    if (message.follow != null && message.hasOwnProperty("follow")) {
                        object.follow = $root.ic_nns_governance.pb.v1.ManageNeuron.Follow.toObject(message.follow, options);
                        if (options.oneofs)
                            object.command = "follow";
                    }
                    if (message.makeProposal != null && message.hasOwnProperty("makeProposal")) {
                        object.makeProposal = $root.ic_nns_governance.pb.v1.Proposal.toObject(message.makeProposal, options);
                        if (options.oneofs)
                            object.command = "makeProposal";
                    }
                    if (message.registerVote != null && message.hasOwnProperty("registerVote")) {
                        object.registerVote = $root.ic_nns_governance.pb.v1.ManageNeuron.RegisterVote.toObject(message.registerVote, options);
                        if (options.oneofs)
                            object.command = "registerVote";
                    }
                    if (message.split != null && message.hasOwnProperty("split")) {
                        object.split = $root.ic_nns_governance.pb.v1.ManageNeuron.Split.toObject(message.split, options);
                        if (options.oneofs)
                            object.command = "split";
                    }
                    if (message.disburseToNeuron != null && message.hasOwnProperty("disburseToNeuron")) {
                        object.disburseToNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.toObject(message.disburseToNeuron, options);
                        if (options.oneofs)
                            object.command = "disburseToNeuron";
                    }
                    if (message.claimOrRefresh != null && message.hasOwnProperty("claimOrRefresh")) {
                        object.claimOrRefresh = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.toObject(message.claimOrRefresh, options);
                        if (options.oneofs)
                            object.command = "claimOrRefresh";
                    }
                    if (message.subaccount != null && message.hasOwnProperty("subaccount")) {
                        object.subaccount = options.bytes === String ? $util.base64.encode(message.subaccount, 0, message.subaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.subaccount) : message.subaccount;
                        if (options.oneofs)
                            object.neuronIdOrSubaccount = "subaccount";
                    }
                    if (message.neuronId != null && message.hasOwnProperty("neuronId")) {
                        object.neuronId = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.neuronId, options);
                        if (options.oneofs)
                            object.neuronIdOrSubaccount = "neuronId";
                    }
                    if (message.mergeMaturity != null && message.hasOwnProperty("mergeMaturity")) {
                        object.mergeMaturity = $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.toObject(message.mergeMaturity, options);
                        if (options.oneofs)
                            object.command = "mergeMaturity";
                    }
                    return object;
                };

                /**
                 * Converts this ManageNeuron to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ManageNeuron
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ManageNeuron.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                ManageNeuron.IncreaseDissolveDelay = (function() {

                    /**
                     * Properties of an IncreaseDissolveDelay.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IIncreaseDissolveDelay
                     * @property {number|null} [additionalDissolveDelaySeconds] IncreaseDissolveDelay additionalDissolveDelaySeconds
                     */

                    /**
                     * Constructs a new IncreaseDissolveDelay.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents an IncreaseDissolveDelay.
                     * @implements IIncreaseDissolveDelay
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IIncreaseDissolveDelay=} [properties] Properties to set
                     */
                    function IncreaseDissolveDelay(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * IncreaseDissolveDelay additionalDissolveDelaySeconds.
                     * @member {number} additionalDissolveDelaySeconds
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay
                     * @instance
                     */
                    IncreaseDissolveDelay.prototype.additionalDissolveDelaySeconds = 0;

                    /**
                     * Creates a new IncreaseDissolveDelay instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IIncreaseDissolveDelay=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay} IncreaseDissolveDelay instance
                     */
                    IncreaseDissolveDelay.create = function create(properties) {
                        return new IncreaseDissolveDelay(properties);
                    };

                    /**
                     * Encodes the specified IncreaseDissolveDelay message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IIncreaseDissolveDelay} message IncreaseDissolveDelay message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    IncreaseDissolveDelay.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.additionalDissolveDelaySeconds != null && Object.hasOwnProperty.call(message, "additionalDissolveDelaySeconds"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.additionalDissolveDelaySeconds);
                        return writer;
                    };

                    /**
                     * Encodes the specified IncreaseDissolveDelay message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IIncreaseDissolveDelay} message IncreaseDissolveDelay message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    IncreaseDissolveDelay.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an IncreaseDissolveDelay message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay} IncreaseDissolveDelay
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    IncreaseDissolveDelay.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.additionalDissolveDelaySeconds = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an IncreaseDissolveDelay message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay} IncreaseDissolveDelay
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    IncreaseDissolveDelay.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an IncreaseDissolveDelay message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    IncreaseDissolveDelay.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.additionalDissolveDelaySeconds != null && message.hasOwnProperty("additionalDissolveDelaySeconds"))
                            if (!$util.isInteger(message.additionalDissolveDelaySeconds))
                                return "additionalDissolveDelaySeconds: integer expected";
                        return null;
                    };

                    /**
                     * Creates an IncreaseDissolveDelay message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay} IncreaseDissolveDelay
                     */
                    IncreaseDissolveDelay.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay();
                        if (object.additionalDissolveDelaySeconds != null)
                            message.additionalDissolveDelaySeconds = object.additionalDissolveDelaySeconds >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from an IncreaseDissolveDelay message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay} message IncreaseDissolveDelay
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    IncreaseDissolveDelay.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.additionalDissolveDelaySeconds = 0;
                        if (message.additionalDissolveDelaySeconds != null && message.hasOwnProperty("additionalDissolveDelaySeconds"))
                            object.additionalDissolveDelaySeconds = message.additionalDissolveDelaySeconds;
                        return object;
                    };

                    /**
                     * Converts this IncreaseDissolveDelay to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    IncreaseDissolveDelay.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return IncreaseDissolveDelay;
                })();

                ManageNeuron.StartDissolving = (function() {

                    /**
                     * Properties of a StartDissolving.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IStartDissolving
                     */

                    /**
                     * Constructs a new StartDissolving.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a StartDissolving.
                     * @implements IStartDissolving
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IStartDissolving=} [properties] Properties to set
                     */
                    function StartDissolving(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new StartDissolving instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StartDissolving
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IStartDissolving=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.StartDissolving} StartDissolving instance
                     */
                    StartDissolving.create = function create(properties) {
                        return new StartDissolving(properties);
                    };

                    /**
                     * Encodes the specified StartDissolving message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.StartDissolving.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StartDissolving
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IStartDissolving} message StartDissolving message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StartDissolving.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified StartDissolving message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.StartDissolving.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StartDissolving
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IStartDissolving} message StartDissolving message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StartDissolving.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a StartDissolving message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StartDissolving
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.StartDissolving} StartDissolving
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StartDissolving.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.StartDissolving();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a StartDissolving message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StartDissolving
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.StartDissolving} StartDissolving
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StartDissolving.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a StartDissolving message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StartDissolving
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StartDissolving.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a StartDissolving message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StartDissolving
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.StartDissolving} StartDissolving
                     */
                    StartDissolving.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.StartDissolving)
                            return object;
                        return new $root.ic_nns_governance.pb.v1.ManageNeuron.StartDissolving();
                    };

                    /**
                     * Creates a plain object from a StartDissolving message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StartDissolving
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.StartDissolving} message StartDissolving
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StartDissolving.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this StartDissolving to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StartDissolving
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StartDissolving.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return StartDissolving;
                })();

                ManageNeuron.StopDissolving = (function() {

                    /**
                     * Properties of a StopDissolving.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IStopDissolving
                     */

                    /**
                     * Constructs a new StopDissolving.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a StopDissolving.
                     * @implements IStopDissolving
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IStopDissolving=} [properties] Properties to set
                     */
                    function StopDissolving(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new StopDissolving instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StopDissolving
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IStopDissolving=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.StopDissolving} StopDissolving instance
                     */
                    StopDissolving.create = function create(properties) {
                        return new StopDissolving(properties);
                    };

                    /**
                     * Encodes the specified StopDissolving message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.StopDissolving.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StopDissolving
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IStopDissolving} message StopDissolving message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StopDissolving.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified StopDissolving message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.StopDissolving.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StopDissolving
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IStopDissolving} message StopDissolving message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    StopDissolving.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a StopDissolving message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StopDissolving
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.StopDissolving} StopDissolving
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StopDissolving.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.StopDissolving();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a StopDissolving message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StopDissolving
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.StopDissolving} StopDissolving
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    StopDissolving.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a StopDissolving message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StopDissolving
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StopDissolving.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a StopDissolving message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StopDissolving
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.StopDissolving} StopDissolving
                     */
                    StopDissolving.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.StopDissolving)
                            return object;
                        return new $root.ic_nns_governance.pb.v1.ManageNeuron.StopDissolving();
                    };

                    /**
                     * Creates a plain object from a StopDissolving message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StopDissolving
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.StopDissolving} message StopDissolving
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StopDissolving.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this StopDissolving to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.StopDissolving
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StopDissolving.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return StopDissolving;
                })();

                ManageNeuron.AddHotKey = (function() {

                    /**
                     * Properties of an AddHotKey.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IAddHotKey
                     * @property {ic_base_types.pb.v1.IPrincipalId|null} [newHotKey] AddHotKey newHotKey
                     */

                    /**
                     * Constructs a new AddHotKey.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents an AddHotKey.
                     * @implements IAddHotKey
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IAddHotKey=} [properties] Properties to set
                     */
                    function AddHotKey(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * AddHotKey newHotKey.
                     * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} newHotKey
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.AddHotKey
                     * @instance
                     */
                    AddHotKey.prototype.newHotKey = null;

                    /**
                     * Creates a new AddHotKey instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.AddHotKey
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IAddHotKey=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.AddHotKey} AddHotKey instance
                     */
                    AddHotKey.create = function create(properties) {
                        return new AddHotKey(properties);
                    };

                    /**
                     * Encodes the specified AddHotKey message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.AddHotKey.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.AddHotKey
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IAddHotKey} message AddHotKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AddHotKey.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.newHotKey != null && Object.hasOwnProperty.call(message, "newHotKey"))
                            $root.ic_base_types.pb.v1.PrincipalId.encode(message.newHotKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified AddHotKey message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.AddHotKey.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.AddHotKey
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IAddHotKey} message AddHotKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    AddHotKey.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an AddHotKey message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.AddHotKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.AddHotKey} AddHotKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AddHotKey.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.AddHotKey();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.newHotKey = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an AddHotKey message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.AddHotKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.AddHotKey} AddHotKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    AddHotKey.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an AddHotKey message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.AddHotKey
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AddHotKey.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.newHotKey != null && message.hasOwnProperty("newHotKey")) {
                            let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.newHotKey);
                            if (error)
                                return "newHotKey." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an AddHotKey message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.AddHotKey
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.AddHotKey} AddHotKey
                     */
                    AddHotKey.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.AddHotKey)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.AddHotKey();
                        if (object.newHotKey != null) {
                            if (typeof object.newHotKey !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.AddHotKey.newHotKey: object expected");
                            message.newHotKey = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.newHotKey);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an AddHotKey message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.AddHotKey
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.AddHotKey} message AddHotKey
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AddHotKey.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.newHotKey = null;
                        if (message.newHotKey != null && message.hasOwnProperty("newHotKey"))
                            object.newHotKey = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.newHotKey, options);
                        return object;
                    };

                    /**
                     * Converts this AddHotKey to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.AddHotKey
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AddHotKey.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return AddHotKey;
                })();

                ManageNeuron.RemoveHotKey = (function() {

                    /**
                     * Properties of a RemoveHotKey.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IRemoveHotKey
                     * @property {ic_base_types.pb.v1.IPrincipalId|null} [hotKeyToRemove] RemoveHotKey hotKeyToRemove
                     */

                    /**
                     * Constructs a new RemoveHotKey.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a RemoveHotKey.
                     * @implements IRemoveHotKey
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IRemoveHotKey=} [properties] Properties to set
                     */
                    function RemoveHotKey(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * RemoveHotKey hotKeyToRemove.
                     * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} hotKeyToRemove
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey
                     * @instance
                     */
                    RemoveHotKey.prototype.hotKeyToRemove = null;

                    /**
                     * Creates a new RemoveHotKey instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IRemoveHotKey=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey} RemoveHotKey instance
                     */
                    RemoveHotKey.create = function create(properties) {
                        return new RemoveHotKey(properties);
                    };

                    /**
                     * Encodes the specified RemoveHotKey message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IRemoveHotKey} message RemoveHotKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RemoveHotKey.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.hotKeyToRemove != null && Object.hasOwnProperty.call(message, "hotKeyToRemove"))
                            $root.ic_base_types.pb.v1.PrincipalId.encode(message.hotKeyToRemove, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified RemoveHotKey message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IRemoveHotKey} message RemoveHotKey message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RemoveHotKey.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a RemoveHotKey message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey} RemoveHotKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RemoveHotKey.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.hotKeyToRemove = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a RemoveHotKey message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey} RemoveHotKey
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RemoveHotKey.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a RemoveHotKey message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RemoveHotKey.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.hotKeyToRemove != null && message.hasOwnProperty("hotKeyToRemove")) {
                            let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.hotKeyToRemove);
                            if (error)
                                return "hotKeyToRemove." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a RemoveHotKey message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey} RemoveHotKey
                     */
                    RemoveHotKey.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey();
                        if (object.hotKeyToRemove != null) {
                            if (typeof object.hotKeyToRemove !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey.hotKeyToRemove: object expected");
                            message.hotKeyToRemove = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.hotKeyToRemove);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a RemoveHotKey message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey} message RemoveHotKey
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RemoveHotKey.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.hotKeyToRemove = null;
                        if (message.hotKeyToRemove != null && message.hasOwnProperty("hotKeyToRemove"))
                            object.hotKeyToRemove = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.hotKeyToRemove, options);
                        return object;
                    };

                    /**
                     * Converts this RemoveHotKey to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RemoveHotKey.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return RemoveHotKey;
                })();

                ManageNeuron.SetDissolveTimestamp = (function() {

                    /**
                     * Properties of a SetDissolveTimestamp.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface ISetDissolveTimestamp
                     * @property {number|Long|null} [dissolveTimestampSeconds] SetDissolveTimestamp dissolveTimestampSeconds
                     */

                    /**
                     * Constructs a new SetDissolveTimestamp.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a SetDissolveTimestamp.
                     * @implements ISetDissolveTimestamp
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISetDissolveTimestamp=} [properties] Properties to set
                     */
                    function SetDissolveTimestamp(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SetDissolveTimestamp dissolveTimestampSeconds.
                     * @member {number|Long} dissolveTimestampSeconds
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp
                     * @instance
                     */
                    SetDissolveTimestamp.prototype.dissolveTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new SetDissolveTimestamp instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISetDissolveTimestamp=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp} SetDissolveTimestamp instance
                     */
                    SetDissolveTimestamp.create = function create(properties) {
                        return new SetDissolveTimestamp(properties);
                    };

                    /**
                     * Encodes the specified SetDissolveTimestamp message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISetDissolveTimestamp} message SetDissolveTimestamp message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetDissolveTimestamp.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.dissolveTimestampSeconds != null && Object.hasOwnProperty.call(message, "dissolveTimestampSeconds"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.dissolveTimestampSeconds);
                        return writer;
                    };

                    /**
                     * Encodes the specified SetDissolveTimestamp message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISetDissolveTimestamp} message SetDissolveTimestamp message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SetDissolveTimestamp.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SetDissolveTimestamp message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp} SetDissolveTimestamp
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetDissolveTimestamp.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.dissolveTimestampSeconds = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SetDissolveTimestamp message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp} SetDissolveTimestamp
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SetDissolveTimestamp.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a SetDissolveTimestamp message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SetDissolveTimestamp.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.dissolveTimestampSeconds != null && message.hasOwnProperty("dissolveTimestampSeconds"))
                            if (!$util.isInteger(message.dissolveTimestampSeconds) && !(message.dissolveTimestampSeconds && $util.isInteger(message.dissolveTimestampSeconds.low) && $util.isInteger(message.dissolveTimestampSeconds.high)))
                                return "dissolveTimestampSeconds: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a SetDissolveTimestamp message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp} SetDissolveTimestamp
                     */
                    SetDissolveTimestamp.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp();
                        if (object.dissolveTimestampSeconds != null)
                            if ($util.Long)
                                (message.dissolveTimestampSeconds = $util.Long.fromValue(object.dissolveTimestampSeconds)).unsigned = true;
                            else if (typeof object.dissolveTimestampSeconds === "string")
                                message.dissolveTimestampSeconds = parseInt(object.dissolveTimestampSeconds, 10);
                            else if (typeof object.dissolveTimestampSeconds === "number")
                                message.dissolveTimestampSeconds = object.dissolveTimestampSeconds;
                            else if (typeof object.dissolveTimestampSeconds === "object")
                                message.dissolveTimestampSeconds = new $util.LongBits(object.dissolveTimestampSeconds.low >>> 0, object.dissolveTimestampSeconds.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a SetDissolveTimestamp message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp} message SetDissolveTimestamp
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SetDissolveTimestamp.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.dissolveTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.dissolveTimestampSeconds = options.longs === String ? "0" : 0;
                        if (message.dissolveTimestampSeconds != null && message.hasOwnProperty("dissolveTimestampSeconds"))
                            if (typeof message.dissolveTimestampSeconds === "number")
                                object.dissolveTimestampSeconds = options.longs === String ? String(message.dissolveTimestampSeconds) : message.dissolveTimestampSeconds;
                            else
                                object.dissolveTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.dissolveTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.dissolveTimestampSeconds.low >>> 0, message.dissolveTimestampSeconds.high >>> 0).toNumber(true) : message.dissolveTimestampSeconds;
                        return object;
                    };

                    /**
                     * Converts this SetDissolveTimestamp to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SetDissolveTimestamp.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SetDissolveTimestamp;
                })();

                ManageNeuron.JoinCommunityFund = (function() {

                    /**
                     * Properties of a JoinCommunityFund.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IJoinCommunityFund
                     */

                    /**
                     * Constructs a new JoinCommunityFund.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a JoinCommunityFund.
                     * @implements IJoinCommunityFund
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IJoinCommunityFund=} [properties] Properties to set
                     */
                    function JoinCommunityFund(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new JoinCommunityFund instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IJoinCommunityFund=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund} JoinCommunityFund instance
                     */
                    JoinCommunityFund.create = function create(properties) {
                        return new JoinCommunityFund(properties);
                    };

                    /**
                     * Encodes the specified JoinCommunityFund message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IJoinCommunityFund} message JoinCommunityFund message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JoinCommunityFund.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified JoinCommunityFund message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IJoinCommunityFund} message JoinCommunityFund message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    JoinCommunityFund.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a JoinCommunityFund message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund} JoinCommunityFund
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JoinCommunityFund.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a JoinCommunityFund message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund} JoinCommunityFund
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    JoinCommunityFund.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a JoinCommunityFund message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    JoinCommunityFund.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a JoinCommunityFund message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund} JoinCommunityFund
                     */
                    JoinCommunityFund.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund)
                            return object;
                        return new $root.ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund();
                    };

                    /**
                     * Creates a plain object from a JoinCommunityFund message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund} message JoinCommunityFund
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    JoinCommunityFund.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this JoinCommunityFund to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    JoinCommunityFund.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return JoinCommunityFund;
                })();

                ManageNeuron.Configure = (function() {

                    /**
                     * Properties of a Configure.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IConfigure
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.IIncreaseDissolveDelay|null} [increaseDissolveDelay] Configure increaseDissolveDelay
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.IStartDissolving|null} [startDissolving] Configure startDissolving
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.IStopDissolving|null} [stopDissolving] Configure stopDissolving
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.IAddHotKey|null} [addHotKey] Configure addHotKey
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.IRemoveHotKey|null} [removeHotKey] Configure removeHotKey
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.ISetDissolveTimestamp|null} [setDissolveTimestamp] Configure setDissolveTimestamp
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.IJoinCommunityFund|null} [joinCommunityFund] Configure joinCommunityFund
                     */

                    /**
                     * Constructs a new Configure.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a Configure.
                     * @implements IConfigure
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IConfigure=} [properties] Properties to set
                     */
                    function Configure(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Configure increaseDissolveDelay.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.IIncreaseDissolveDelay|null|undefined} increaseDissolveDelay
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @instance
                     */
                    Configure.prototype.increaseDissolveDelay = null;

                    /**
                     * Configure startDissolving.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.IStartDissolving|null|undefined} startDissolving
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @instance
                     */
                    Configure.prototype.startDissolving = null;

                    /**
                     * Configure stopDissolving.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.IStopDissolving|null|undefined} stopDissolving
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @instance
                     */
                    Configure.prototype.stopDissolving = null;

                    /**
                     * Configure addHotKey.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.IAddHotKey|null|undefined} addHotKey
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @instance
                     */
                    Configure.prototype.addHotKey = null;

                    /**
                     * Configure removeHotKey.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.IRemoveHotKey|null|undefined} removeHotKey
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @instance
                     */
                    Configure.prototype.removeHotKey = null;

                    /**
                     * Configure setDissolveTimestamp.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.ISetDissolveTimestamp|null|undefined} setDissolveTimestamp
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @instance
                     */
                    Configure.prototype.setDissolveTimestamp = null;

                    /**
                     * Configure joinCommunityFund.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.IJoinCommunityFund|null|undefined} joinCommunityFund
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @instance
                     */
                    Configure.prototype.joinCommunityFund = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Configure operation.
                     * @member {"increaseDissolveDelay"|"startDissolving"|"stopDissolving"|"addHotKey"|"removeHotKey"|"setDissolveTimestamp"|"joinCommunityFund"|undefined} operation
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @instance
                     */
                    Object.defineProperty(Configure.prototype, "operation", {
                        get: $util.oneOfGetter($oneOfFields = ["increaseDissolveDelay", "startDissolving", "stopDissolving", "addHotKey", "removeHotKey", "setDissolveTimestamp", "joinCommunityFund"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new Configure instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IConfigure=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Configure} Configure instance
                     */
                    Configure.create = function create(properties) {
                        return new Configure(properties);
                    };

                    /**
                     * Encodes the specified Configure message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Configure.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IConfigure} message Configure message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Configure.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.increaseDissolveDelay != null && Object.hasOwnProperty.call(message, "increaseDissolveDelay"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay.encode(message.increaseDissolveDelay, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.startDissolving != null && Object.hasOwnProperty.call(message, "startDissolving"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.StartDissolving.encode(message.startDissolving, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.stopDissolving != null && Object.hasOwnProperty.call(message, "stopDissolving"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.StopDissolving.encode(message.stopDissolving, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.addHotKey != null && Object.hasOwnProperty.call(message, "addHotKey"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.AddHotKey.encode(message.addHotKey, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.removeHotKey != null && Object.hasOwnProperty.call(message, "removeHotKey"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey.encode(message.removeHotKey, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.setDissolveTimestamp != null && Object.hasOwnProperty.call(message, "setDissolveTimestamp"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp.encode(message.setDissolveTimestamp, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.joinCommunityFund != null && Object.hasOwnProperty.call(message, "joinCommunityFund"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund.encode(message.joinCommunityFund, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Configure message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Configure.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IConfigure} message Configure message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Configure.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Configure message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Configure} Configure
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Configure.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Configure();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.increaseDissolveDelay = $root.ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.startDissolving = $root.ic_nns_governance.pb.v1.ManageNeuron.StartDissolving.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.stopDissolving = $root.ic_nns_governance.pb.v1.ManageNeuron.StopDissolving.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.addHotKey = $root.ic_nns_governance.pb.v1.ManageNeuron.AddHotKey.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.removeHotKey = $root.ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.setDissolveTimestamp = $root.ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.joinCommunityFund = $root.ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Configure message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Configure} Configure
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Configure.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Configure message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Configure.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.increaseDissolveDelay != null && message.hasOwnProperty("increaseDissolveDelay")) {
                            properties.operation = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay.verify(message.increaseDissolveDelay);
                                if (error)
                                    return "increaseDissolveDelay." + error;
                            }
                        }
                        if (message.startDissolving != null && message.hasOwnProperty("startDissolving")) {
                            if (properties.operation === 1)
                                return "operation: multiple values";
                            properties.operation = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.StartDissolving.verify(message.startDissolving);
                                if (error)
                                    return "startDissolving." + error;
                            }
                        }
                        if (message.stopDissolving != null && message.hasOwnProperty("stopDissolving")) {
                            if (properties.operation === 1)
                                return "operation: multiple values";
                            properties.operation = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.StopDissolving.verify(message.stopDissolving);
                                if (error)
                                    return "stopDissolving." + error;
                            }
                        }
                        if (message.addHotKey != null && message.hasOwnProperty("addHotKey")) {
                            if (properties.operation === 1)
                                return "operation: multiple values";
                            properties.operation = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.AddHotKey.verify(message.addHotKey);
                                if (error)
                                    return "addHotKey." + error;
                            }
                        }
                        if (message.removeHotKey != null && message.hasOwnProperty("removeHotKey")) {
                            if (properties.operation === 1)
                                return "operation: multiple values";
                            properties.operation = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey.verify(message.removeHotKey);
                                if (error)
                                    return "removeHotKey." + error;
                            }
                        }
                        if (message.setDissolveTimestamp != null && message.hasOwnProperty("setDissolveTimestamp")) {
                            if (properties.operation === 1)
                                return "operation: multiple values";
                            properties.operation = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp.verify(message.setDissolveTimestamp);
                                if (error)
                                    return "setDissolveTimestamp." + error;
                            }
                        }
                        if (message.joinCommunityFund != null && message.hasOwnProperty("joinCommunityFund")) {
                            if (properties.operation === 1)
                                return "operation: multiple values";
                            properties.operation = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund.verify(message.joinCommunityFund);
                                if (error)
                                    return "joinCommunityFund." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Configure message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Configure} Configure
                     */
                    Configure.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.Configure)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Configure();
                        if (object.increaseDissolveDelay != null) {
                            if (typeof object.increaseDissolveDelay !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Configure.increaseDissolveDelay: object expected");
                            message.increaseDissolveDelay = $root.ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay.fromObject(object.increaseDissolveDelay);
                        }
                        if (object.startDissolving != null) {
                            if (typeof object.startDissolving !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Configure.startDissolving: object expected");
                            message.startDissolving = $root.ic_nns_governance.pb.v1.ManageNeuron.StartDissolving.fromObject(object.startDissolving);
                        }
                        if (object.stopDissolving != null) {
                            if (typeof object.stopDissolving !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Configure.stopDissolving: object expected");
                            message.stopDissolving = $root.ic_nns_governance.pb.v1.ManageNeuron.StopDissolving.fromObject(object.stopDissolving);
                        }
                        if (object.addHotKey != null) {
                            if (typeof object.addHotKey !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Configure.addHotKey: object expected");
                            message.addHotKey = $root.ic_nns_governance.pb.v1.ManageNeuron.AddHotKey.fromObject(object.addHotKey);
                        }
                        if (object.removeHotKey != null) {
                            if (typeof object.removeHotKey !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Configure.removeHotKey: object expected");
                            message.removeHotKey = $root.ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey.fromObject(object.removeHotKey);
                        }
                        if (object.setDissolveTimestamp != null) {
                            if (typeof object.setDissolveTimestamp !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Configure.setDissolveTimestamp: object expected");
                            message.setDissolveTimestamp = $root.ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp.fromObject(object.setDissolveTimestamp);
                        }
                        if (object.joinCommunityFund != null) {
                            if (typeof object.joinCommunityFund !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Configure.joinCommunityFund: object expected");
                            message.joinCommunityFund = $root.ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund.fromObject(object.joinCommunityFund);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Configure message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.Configure} message Configure
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Configure.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (message.increaseDissolveDelay != null && message.hasOwnProperty("increaseDissolveDelay")) {
                            object.increaseDissolveDelay = $root.ic_nns_governance.pb.v1.ManageNeuron.IncreaseDissolveDelay.toObject(message.increaseDissolveDelay, options);
                            if (options.oneofs)
                                object.operation = "increaseDissolveDelay";
                        }
                        if (message.startDissolving != null && message.hasOwnProperty("startDissolving")) {
                            object.startDissolving = $root.ic_nns_governance.pb.v1.ManageNeuron.StartDissolving.toObject(message.startDissolving, options);
                            if (options.oneofs)
                                object.operation = "startDissolving";
                        }
                        if (message.stopDissolving != null && message.hasOwnProperty("stopDissolving")) {
                            object.stopDissolving = $root.ic_nns_governance.pb.v1.ManageNeuron.StopDissolving.toObject(message.stopDissolving, options);
                            if (options.oneofs)
                                object.operation = "stopDissolving";
                        }
                        if (message.addHotKey != null && message.hasOwnProperty("addHotKey")) {
                            object.addHotKey = $root.ic_nns_governance.pb.v1.ManageNeuron.AddHotKey.toObject(message.addHotKey, options);
                            if (options.oneofs)
                                object.operation = "addHotKey";
                        }
                        if (message.removeHotKey != null && message.hasOwnProperty("removeHotKey")) {
                            object.removeHotKey = $root.ic_nns_governance.pb.v1.ManageNeuron.RemoveHotKey.toObject(message.removeHotKey, options);
                            if (options.oneofs)
                                object.operation = "removeHotKey";
                        }
                        if (message.setDissolveTimestamp != null && message.hasOwnProperty("setDissolveTimestamp")) {
                            object.setDissolveTimestamp = $root.ic_nns_governance.pb.v1.ManageNeuron.SetDissolveTimestamp.toObject(message.setDissolveTimestamp, options);
                            if (options.oneofs)
                                object.operation = "setDissolveTimestamp";
                        }
                        if (message.joinCommunityFund != null && message.hasOwnProperty("joinCommunityFund")) {
                            object.joinCommunityFund = $root.ic_nns_governance.pb.v1.ManageNeuron.JoinCommunityFund.toObject(message.joinCommunityFund, options);
                            if (options.oneofs)
                                object.operation = "joinCommunityFund";
                        }
                        return object;
                    };

                    /**
                     * Converts this Configure to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Configure
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Configure.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Configure;
                })();

                ManageNeuron.Disburse = (function() {

                    /**
                     * Properties of a Disburse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IDisburse
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.Disburse.IAmount|null} [amount] Disburse amount
                     * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [toAccount] Disburse toAccount
                     */

                    /**
                     * Constructs a new Disburse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a Disburse.
                     * @implements IDisburse
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IDisburse=} [properties] Properties to set
                     */
                    function Disburse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Disburse amount.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.Disburse.IAmount|null|undefined} amount
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                     * @instance
                     */
                    Disburse.prototype.amount = null;

                    /**
                     * Disburse toAccount.
                     * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} toAccount
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                     * @instance
                     */
                    Disburse.prototype.toAccount = null;

                    /**
                     * Creates a new Disburse instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IDisburse=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Disburse} Disburse instance
                     */
                    Disburse.create = function create(properties) {
                        return new Disburse(properties);
                    };

                    /**
                     * Encodes the specified Disburse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Disburse.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IDisburse} message Disburse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Disburse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount.encode(message.amount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.toAccount != null && Object.hasOwnProperty.call(message, "toAccount"))
                            $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.toAccount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Disburse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Disburse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IDisburse} message Disburse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Disburse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Disburse message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Disburse} Disburse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Disburse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amount = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.toAccount = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Disburse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Disburse} Disburse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Disburse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Disburse message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Disburse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amount != null && message.hasOwnProperty("amount")) {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount.verify(message.amount);
                            if (error)
                                return "amount." + error;
                        }
                        if (message.toAccount != null && message.hasOwnProperty("toAccount")) {
                            let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.toAccount);
                            if (error)
                                return "toAccount." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Disburse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Disburse} Disburse
                     */
                    Disburse.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse();
                        if (object.amount != null) {
                            if (typeof object.amount !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Disburse.amount: object expected");
                            message.amount = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount.fromObject(object.amount);
                        }
                        if (object.toAccount != null) {
                            if (typeof object.toAccount !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Disburse.toAccount: object expected");
                            message.toAccount = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.toAccount);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Disburse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.Disburse} message Disburse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Disburse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.amount = null;
                            object.toAccount = null;
                        }
                        if (message.amount != null && message.hasOwnProperty("amount"))
                            object.amount = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount.toObject(message.amount, options);
                        if (message.toAccount != null && message.hasOwnProperty("toAccount"))
                            object.toAccount = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.toAccount, options);
                        return object;
                    };

                    /**
                     * Converts this Disburse to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Disburse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Disburse.Amount = (function() {

                        /**
                         * Properties of an Amount.
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                         * @interface IAmount
                         * @property {number|Long|null} [e8s] Amount e8s
                         */

                        /**
                         * Constructs a new Amount.
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse
                         * @classdesc Represents an Amount.
                         * @implements IAmount
                         * @constructor
                         * @param {ic_nns_governance.pb.v1.ManageNeuron.Disburse.IAmount=} [properties] Properties to set
                         */
                        function Amount(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Amount e8s.
                         * @member {number|Long} e8s
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount
                         * @instance
                         */
                        Amount.prototype.e8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                        /**
                         * Creates a new Amount instance using the specified properties.
                         * @function create
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount
                         * @static
                         * @param {ic_nns_governance.pb.v1.ManageNeuron.Disburse.IAmount=} [properties] Properties to set
                         * @returns {ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount} Amount instance
                         */
                        Amount.create = function create(properties) {
                            return new Amount(properties);
                        };

                        /**
                         * Encodes the specified Amount message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount.verify|verify} messages.
                         * @function encode
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount
                         * @static
                         * @param {ic_nns_governance.pb.v1.ManageNeuron.Disburse.IAmount} message Amount message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Amount.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.e8s != null && Object.hasOwnProperty.call(message, "e8s"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.e8s);
                            return writer;
                        };

                        /**
                         * Encodes the specified Amount message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount
                         * @static
                         * @param {ic_nns_governance.pb.v1.ManageNeuron.Disburse.IAmount} message Amount message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Amount.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Amount message from the specified reader or buffer.
                         * @function decode
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount} Amount
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Amount.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.e8s = reader.uint64();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Amount message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount} Amount
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Amount.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Amount message.
                         * @function verify
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Amount.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.e8s != null && message.hasOwnProperty("e8s"))
                                if (!$util.isInteger(message.e8s) && !(message.e8s && $util.isInteger(message.e8s.low) && $util.isInteger(message.e8s.high)))
                                    return "e8s: integer|Long expected";
                            return null;
                        };

                        /**
                         * Creates an Amount message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount} Amount
                         */
                        Amount.fromObject = function fromObject(object) {
                            if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount)
                                return object;
                            let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount();
                            if (object.e8s != null)
                                if ($util.Long)
                                    (message.e8s = $util.Long.fromValue(object.e8s)).unsigned = true;
                                else if (typeof object.e8s === "string")
                                    message.e8s = parseInt(object.e8s, 10);
                                else if (typeof object.e8s === "number")
                                    message.e8s = object.e8s;
                                else if (typeof object.e8s === "object")
                                    message.e8s = new $util.LongBits(object.e8s.low >>> 0, object.e8s.high >>> 0).toNumber(true);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Amount message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount
                         * @static
                         * @param {ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount} message Amount
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Amount.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                if ($util.Long) {
                                    let long = new $util.Long(0, 0, true);
                                    object.e8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.e8s = options.longs === String ? "0" : 0;
                            if (message.e8s != null && message.hasOwnProperty("e8s"))
                                if (typeof message.e8s === "number")
                                    object.e8s = options.longs === String ? String(message.e8s) : message.e8s;
                                else
                                    object.e8s = options.longs === String ? $util.Long.prototype.toString.call(message.e8s) : options.longs === Number ? new $util.LongBits(message.e8s.low >>> 0, message.e8s.high >>> 0).toNumber(true) : message.e8s;
                            return object;
                        };

                        /**
                         * Converts this Amount to JSON.
                         * @function toJSON
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.Disburse.Amount
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Amount.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Amount;
                    })();

                    return Disburse;
                })();

                ManageNeuron.Split = (function() {

                    /**
                     * Properties of a Split.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface ISplit
                     * @property {number|Long|null} [amountE8s] Split amountE8s
                     */

                    /**
                     * Constructs a new Split.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a Split.
                     * @implements ISplit
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISplit=} [properties] Properties to set
                     */
                    function Split(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Split amountE8s.
                     * @member {number|Long} amountE8s
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Split
                     * @instance
                     */
                    Split.prototype.amountE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new Split instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Split
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISplit=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Split} Split instance
                     */
                    Split.create = function create(properties) {
                        return new Split(properties);
                    };

                    /**
                     * Encodes the specified Split message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Split.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Split
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISplit} message Split message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Split.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.amountE8s != null && Object.hasOwnProperty.call(message, "amountE8s"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.amountE8s);
                        return writer;
                    };

                    /**
                     * Encodes the specified Split message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Split.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Split
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISplit} message Split message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Split.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Split message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Split
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Split} Split
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Split.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Split();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.amountE8s = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Split message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Split
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Split} Split
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Split.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Split message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Split
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Split.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.amountE8s != null && message.hasOwnProperty("amountE8s"))
                            if (!$util.isInteger(message.amountE8s) && !(message.amountE8s && $util.isInteger(message.amountE8s.low) && $util.isInteger(message.amountE8s.high)))
                                return "amountE8s: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a Split message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Split
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Split} Split
                     */
                    Split.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.Split)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Split();
                        if (object.amountE8s != null)
                            if ($util.Long)
                                (message.amountE8s = $util.Long.fromValue(object.amountE8s)).unsigned = true;
                            else if (typeof object.amountE8s === "string")
                                message.amountE8s = parseInt(object.amountE8s, 10);
                            else if (typeof object.amountE8s === "number")
                                message.amountE8s = object.amountE8s;
                            else if (typeof object.amountE8s === "object")
                                message.amountE8s = new $util.LongBits(object.amountE8s.low >>> 0, object.amountE8s.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Split message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Split
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.Split} message Split
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Split.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.amountE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amountE8s = options.longs === String ? "0" : 0;
                        if (message.amountE8s != null && message.hasOwnProperty("amountE8s"))
                            if (typeof message.amountE8s === "number")
                                object.amountE8s = options.longs === String ? String(message.amountE8s) : message.amountE8s;
                            else
                                object.amountE8s = options.longs === String ? $util.Long.prototype.toString.call(message.amountE8s) : options.longs === Number ? new $util.LongBits(message.amountE8s.low >>> 0, message.amountE8s.high >>> 0).toNumber(true) : message.amountE8s;
                        return object;
                    };

                    /**
                     * Converts this Split to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Split
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Split.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Split;
                })();

                ManageNeuron.Spawn = (function() {

                    /**
                     * Properties of a Spawn.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface ISpawn
                     * @property {ic_base_types.pb.v1.IPrincipalId|null} [newController] Spawn newController
                     */

                    /**
                     * Constructs a new Spawn.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a Spawn.
                     * @implements ISpawn
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISpawn=} [properties] Properties to set
                     */
                    function Spawn(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Spawn newController.
                     * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} newController
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Spawn
                     * @instance
                     */
                    Spawn.prototype.newController = null;

                    /**
                     * Creates a new Spawn instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Spawn
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISpawn=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Spawn} Spawn instance
                     */
                    Spawn.create = function create(properties) {
                        return new Spawn(properties);
                    };

                    /**
                     * Encodes the specified Spawn message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Spawn.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Spawn
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISpawn} message Spawn message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Spawn.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.newController != null && Object.hasOwnProperty.call(message, "newController"))
                            $root.ic_base_types.pb.v1.PrincipalId.encode(message.newController, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Spawn message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Spawn.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Spawn
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ISpawn} message Spawn message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Spawn.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Spawn message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Spawn
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Spawn} Spawn
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Spawn.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.newController = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Spawn message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Spawn
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Spawn} Spawn
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Spawn.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Spawn message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Spawn
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Spawn.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.newController != null && message.hasOwnProperty("newController")) {
                            let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.newController);
                            if (error)
                                return "newController." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Spawn message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Spawn
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Spawn} Spawn
                     */
                    Spawn.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn();
                        if (object.newController != null) {
                            if (typeof object.newController !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Spawn.newController: object expected");
                            message.newController = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.newController);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Spawn message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Spawn
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.Spawn} message Spawn
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Spawn.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.newController = null;
                        if (message.newController != null && message.hasOwnProperty("newController"))
                            object.newController = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.newController, options);
                        return object;
                    };

                    /**
                     * Converts this Spawn to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Spawn
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Spawn.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Spawn;
                })();

                ManageNeuron.MergeMaturity = (function() {

                    /**
                     * Properties of a MergeMaturity.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IMergeMaturity
                     * @property {number|null} [percentageToMerge] MergeMaturity percentageToMerge
                     */

                    /**
                     * Constructs a new MergeMaturity.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a MergeMaturity.
                     * @implements IMergeMaturity
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IMergeMaturity=} [properties] Properties to set
                     */
                    function MergeMaturity(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MergeMaturity percentageToMerge.
                     * @member {number} percentageToMerge
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity
                     * @instance
                     */
                    MergeMaturity.prototype.percentageToMerge = 0;

                    /**
                     * Creates a new MergeMaturity instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IMergeMaturity=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity} MergeMaturity instance
                     */
                    MergeMaturity.create = function create(properties) {
                        return new MergeMaturity(properties);
                    };

                    /**
                     * Encodes the specified MergeMaturity message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IMergeMaturity} message MergeMaturity message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MergeMaturity.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.percentageToMerge != null && Object.hasOwnProperty.call(message, "percentageToMerge"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.percentageToMerge);
                        return writer;
                    };

                    /**
                     * Encodes the specified MergeMaturity message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IMergeMaturity} message MergeMaturity message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MergeMaturity.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MergeMaturity message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity} MergeMaturity
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MergeMaturity.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.percentageToMerge = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MergeMaturity message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity} MergeMaturity
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MergeMaturity.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MergeMaturity message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MergeMaturity.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.percentageToMerge != null && message.hasOwnProperty("percentageToMerge"))
                            if (!$util.isInteger(message.percentageToMerge))
                                return "percentageToMerge: integer expected";
                        return null;
                    };

                    /**
                     * Creates a MergeMaturity message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity} MergeMaturity
                     */
                    MergeMaturity.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity();
                        if (object.percentageToMerge != null)
                            message.percentageToMerge = object.percentageToMerge >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a MergeMaturity message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity} message MergeMaturity
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MergeMaturity.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.percentageToMerge = 0;
                        if (message.percentageToMerge != null && message.hasOwnProperty("percentageToMerge"))
                            object.percentageToMerge = message.percentageToMerge;
                        return object;
                    };

                    /**
                     * Converts this MergeMaturity to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MergeMaturity.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return MergeMaturity;
                })();

                ManageNeuron.DisburseToNeuron = (function() {

                    /**
                     * Properties of a DisburseToNeuron.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IDisburseToNeuron
                     * @property {ic_base_types.pb.v1.IPrincipalId|null} [newController] DisburseToNeuron newController
                     * @property {number|Long|null} [amountE8s] DisburseToNeuron amountE8s
                     * @property {number|Long|null} [dissolveDelaySeconds] DisburseToNeuron dissolveDelaySeconds
                     * @property {boolean|null} [kycVerified] DisburseToNeuron kycVerified
                     * @property {number|Long|null} [nonce] DisburseToNeuron nonce
                     */

                    /**
                     * Constructs a new DisburseToNeuron.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a DisburseToNeuron.
                     * @implements IDisburseToNeuron
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IDisburseToNeuron=} [properties] Properties to set
                     */
                    function DisburseToNeuron(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * DisburseToNeuron newController.
                     * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} newController
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @instance
                     */
                    DisburseToNeuron.prototype.newController = null;

                    /**
                     * DisburseToNeuron amountE8s.
                     * @member {number|Long} amountE8s
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @instance
                     */
                    DisburseToNeuron.prototype.amountE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * DisburseToNeuron dissolveDelaySeconds.
                     * @member {number|Long} dissolveDelaySeconds
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @instance
                     */
                    DisburseToNeuron.prototype.dissolveDelaySeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * DisburseToNeuron kycVerified.
                     * @member {boolean} kycVerified
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @instance
                     */
                    DisburseToNeuron.prototype.kycVerified = false;

                    /**
                     * DisburseToNeuron nonce.
                     * @member {number|Long} nonce
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @instance
                     */
                    DisburseToNeuron.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new DisburseToNeuron instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IDisburseToNeuron=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron} DisburseToNeuron instance
                     */
                    DisburseToNeuron.create = function create(properties) {
                        return new DisburseToNeuron(properties);
                    };

                    /**
                     * Encodes the specified DisburseToNeuron message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IDisburseToNeuron} message DisburseToNeuron message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DisburseToNeuron.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.newController != null && Object.hasOwnProperty.call(message, "newController"))
                            $root.ic_base_types.pb.v1.PrincipalId.encode(message.newController, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.amountE8s != null && Object.hasOwnProperty.call(message, "amountE8s"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amountE8s);
                        if (message.dissolveDelaySeconds != null && Object.hasOwnProperty.call(message, "dissolveDelaySeconds"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.dissolveDelaySeconds);
                        if (message.kycVerified != null && Object.hasOwnProperty.call(message, "kycVerified"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.kycVerified);
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.nonce);
                        return writer;
                    };

                    /**
                     * Encodes the specified DisburseToNeuron message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IDisburseToNeuron} message DisburseToNeuron message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DisburseToNeuron.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a DisburseToNeuron message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron} DisburseToNeuron
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DisburseToNeuron.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.newController = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.amountE8s = reader.uint64();
                                break;
                            case 3:
                                message.dissolveDelaySeconds = reader.uint64();
                                break;
                            case 4:
                                message.kycVerified = reader.bool();
                                break;
                            case 5:
                                message.nonce = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a DisburseToNeuron message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron} DisburseToNeuron
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DisburseToNeuron.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a DisburseToNeuron message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DisburseToNeuron.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.newController != null && message.hasOwnProperty("newController")) {
                            let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.newController);
                            if (error)
                                return "newController." + error;
                        }
                        if (message.amountE8s != null && message.hasOwnProperty("amountE8s"))
                            if (!$util.isInteger(message.amountE8s) && !(message.amountE8s && $util.isInteger(message.amountE8s.low) && $util.isInteger(message.amountE8s.high)))
                                return "amountE8s: integer|Long expected";
                        if (message.dissolveDelaySeconds != null && message.hasOwnProperty("dissolveDelaySeconds"))
                            if (!$util.isInteger(message.dissolveDelaySeconds) && !(message.dissolveDelaySeconds && $util.isInteger(message.dissolveDelaySeconds.low) && $util.isInteger(message.dissolveDelaySeconds.high)))
                                return "dissolveDelaySeconds: integer|Long expected";
                        if (message.kycVerified != null && message.hasOwnProperty("kycVerified"))
                            if (typeof message.kycVerified !== "boolean")
                                return "kycVerified: boolean expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                                return "nonce: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a DisburseToNeuron message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron} DisburseToNeuron
                     */
                    DisburseToNeuron.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron();
                        if (object.newController != null) {
                            if (typeof object.newController !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.newController: object expected");
                            message.newController = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.newController);
                        }
                        if (object.amountE8s != null)
                            if ($util.Long)
                                (message.amountE8s = $util.Long.fromValue(object.amountE8s)).unsigned = true;
                            else if (typeof object.amountE8s === "string")
                                message.amountE8s = parseInt(object.amountE8s, 10);
                            else if (typeof object.amountE8s === "number")
                                message.amountE8s = object.amountE8s;
                            else if (typeof object.amountE8s === "object")
                                message.amountE8s = new $util.LongBits(object.amountE8s.low >>> 0, object.amountE8s.high >>> 0).toNumber(true);
                        if (object.dissolveDelaySeconds != null)
                            if ($util.Long)
                                (message.dissolveDelaySeconds = $util.Long.fromValue(object.dissolveDelaySeconds)).unsigned = true;
                            else if (typeof object.dissolveDelaySeconds === "string")
                                message.dissolveDelaySeconds = parseInt(object.dissolveDelaySeconds, 10);
                            else if (typeof object.dissolveDelaySeconds === "number")
                                message.dissolveDelaySeconds = object.dissolveDelaySeconds;
                            else if (typeof object.dissolveDelaySeconds === "object")
                                message.dissolveDelaySeconds = new $util.LongBits(object.dissolveDelaySeconds.low >>> 0, object.dissolveDelaySeconds.high >>> 0).toNumber(true);
                        if (object.kycVerified != null)
                            message.kycVerified = Boolean(object.kycVerified);
                        if (object.nonce != null)
                            if ($util.Long)
                                (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                            else if (typeof object.nonce === "string")
                                message.nonce = parseInt(object.nonce, 10);
                            else if (typeof object.nonce === "number")
                                message.nonce = object.nonce;
                            else if (typeof object.nonce === "object")
                                message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a DisburseToNeuron message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron} message DisburseToNeuron
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DisburseToNeuron.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.newController = null;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.amountE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.amountE8s = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.dissolveDelaySeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.dissolveDelaySeconds = options.longs === String ? "0" : 0;
                            object.kycVerified = false;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonce = options.longs === String ? "0" : 0;
                        }
                        if (message.newController != null && message.hasOwnProperty("newController"))
                            object.newController = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.newController, options);
                        if (message.amountE8s != null && message.hasOwnProperty("amountE8s"))
                            if (typeof message.amountE8s === "number")
                                object.amountE8s = options.longs === String ? String(message.amountE8s) : message.amountE8s;
                            else
                                object.amountE8s = options.longs === String ? $util.Long.prototype.toString.call(message.amountE8s) : options.longs === Number ? new $util.LongBits(message.amountE8s.low >>> 0, message.amountE8s.high >>> 0).toNumber(true) : message.amountE8s;
                        if (message.dissolveDelaySeconds != null && message.hasOwnProperty("dissolveDelaySeconds"))
                            if (typeof message.dissolveDelaySeconds === "number")
                                object.dissolveDelaySeconds = options.longs === String ? String(message.dissolveDelaySeconds) : message.dissolveDelaySeconds;
                            else
                                object.dissolveDelaySeconds = options.longs === String ? $util.Long.prototype.toString.call(message.dissolveDelaySeconds) : options.longs === Number ? new $util.LongBits(message.dissolveDelaySeconds.low >>> 0, message.dissolveDelaySeconds.high >>> 0).toNumber(true) : message.dissolveDelaySeconds;
                        if (message.kycVerified != null && message.hasOwnProperty("kycVerified"))
                            object.kycVerified = message.kycVerified;
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (typeof message.nonce === "number")
                                object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                            else
                                object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                        return object;
                    };

                    /**
                     * Converts this DisburseToNeuron to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DisburseToNeuron.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return DisburseToNeuron;
                })();

                ManageNeuron.Follow = (function() {

                    /**
                     * Properties of a Follow.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IFollow
                     * @property {ic_nns_governance.pb.v1.Topic|null} [topic] Follow topic
                     * @property {Array.<ic_nns_common.pb.v1.INeuronId>|null} [followees] Follow followees
                     */

                    /**
                     * Constructs a new Follow.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a Follow.
                     * @implements IFollow
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IFollow=} [properties] Properties to set
                     */
                    function Follow(properties) {
                        this.followees = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Follow topic.
                     * @member {ic_nns_governance.pb.v1.Topic} topic
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Follow
                     * @instance
                     */
                    Follow.prototype.topic = 0;

                    /**
                     * Follow followees.
                     * @member {Array.<ic_nns_common.pb.v1.INeuronId>} followees
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Follow
                     * @instance
                     */
                    Follow.prototype.followees = $util.emptyArray;

                    /**
                     * Creates a new Follow instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Follow
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IFollow=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Follow} Follow instance
                     */
                    Follow.create = function create(properties) {
                        return new Follow(properties);
                    };

                    /**
                     * Encodes the specified Follow message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Follow.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Follow
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IFollow} message Follow message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Follow.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.topic);
                        if (message.followees != null && message.followees.length)
                            for (let i = 0; i < message.followees.length; ++i)
                                $root.ic_nns_common.pb.v1.NeuronId.encode(message.followees[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Follow message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.Follow.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Follow
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IFollow} message Follow message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Follow.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Follow message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Follow
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Follow} Follow
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Follow.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Follow();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.topic = reader.int32();
                                break;
                            case 2:
                                if (!(message.followees && message.followees.length))
                                    message.followees = [];
                                message.followees.push($root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Follow message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Follow
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Follow} Follow
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Follow.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Follow message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Follow
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Follow.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.topic != null && message.hasOwnProperty("topic"))
                            switch (message.topic) {
                            default:
                                return "topic: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                                break;
                            }
                        if (message.followees != null && message.hasOwnProperty("followees")) {
                            if (!Array.isArray(message.followees))
                                return "followees: array expected";
                            for (let i = 0; i < message.followees.length; ++i) {
                                let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.followees[i]);
                                if (error)
                                    return "followees." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Follow message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Follow
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.Follow} Follow
                     */
                    Follow.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.Follow)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.Follow();
                        switch (object.topic) {
                        case "TOPIC_UNSPECIFIED":
                        case 0:
                            message.topic = 0;
                            break;
                        case "TOPIC_NEURON_MANAGEMENT":
                        case 1:
                            message.topic = 1;
                            break;
                        case "TOPIC_EXCHANGE_RATE":
                        case 2:
                            message.topic = 2;
                            break;
                        case "TOPIC_NETWORK_ECONOMICS":
                        case 3:
                            message.topic = 3;
                            break;
                        case "TOPIC_GOVERNANCE":
                        case 4:
                            message.topic = 4;
                            break;
                        case "TOPIC_NODE_ADMIN":
                        case 5:
                            message.topic = 5;
                            break;
                        case "TOPIC_PARTICIPANT_MANAGEMENT":
                        case 6:
                            message.topic = 6;
                            break;
                        case "TOPIC_SUBNET_MANAGEMENT":
                        case 7:
                            message.topic = 7;
                            break;
                        case "TOPIC_NETWORK_CANISTER_MANAGEMENT":
                        case 8:
                            message.topic = 8;
                            break;
                        case "TOPIC_KYC":
                        case 9:
                            message.topic = 9;
                            break;
                        case "TOPIC_NODE_PROVIDER_REWARDS":
                        case 10:
                            message.topic = 10;
                            break;
                        }
                        if (object.followees) {
                            if (!Array.isArray(object.followees))
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Follow.followees: array expected");
                            message.followees = [];
                            for (let i = 0; i < object.followees.length; ++i) {
                                if (typeof object.followees[i] !== "object")
                                    throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.Follow.followees: object expected");
                                message.followees[i] = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.followees[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Follow message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Follow
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.Follow} message Follow
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Follow.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.followees = [];
                        if (options.defaults)
                            object.topic = options.enums === String ? "TOPIC_UNSPECIFIED" : 0;
                        if (message.topic != null && message.hasOwnProperty("topic"))
                            object.topic = options.enums === String ? $root.ic_nns_governance.pb.v1.Topic[message.topic] : message.topic;
                        if (message.followees && message.followees.length) {
                            object.followees = [];
                            for (let j = 0; j < message.followees.length; ++j)
                                object.followees[j] = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.followees[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Follow to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.Follow
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Follow.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Follow;
                })();

                ManageNeuron.RegisterVote = (function() {

                    /**
                     * Properties of a RegisterVote.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IRegisterVote
                     * @property {ic_nns_common.pb.v1.IProposalId|null} [proposal] RegisterVote proposal
                     * @property {ic_nns_governance.pb.v1.Vote|null} [vote] RegisterVote vote
                     */

                    /**
                     * Constructs a new RegisterVote.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a RegisterVote.
                     * @implements IRegisterVote
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IRegisterVote=} [properties] Properties to set
                     */
                    function RegisterVote(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * RegisterVote proposal.
                     * @member {ic_nns_common.pb.v1.IProposalId|null|undefined} proposal
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RegisterVote
                     * @instance
                     */
                    RegisterVote.prototype.proposal = null;

                    /**
                     * RegisterVote vote.
                     * @member {ic_nns_governance.pb.v1.Vote} vote
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RegisterVote
                     * @instance
                     */
                    RegisterVote.prototype.vote = 0;

                    /**
                     * Creates a new RegisterVote instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RegisterVote
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IRegisterVote=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.RegisterVote} RegisterVote instance
                     */
                    RegisterVote.create = function create(properties) {
                        return new RegisterVote(properties);
                    };

                    /**
                     * Encodes the specified RegisterVote message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.RegisterVote.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RegisterVote
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IRegisterVote} message RegisterVote message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RegisterVote.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.proposal != null && Object.hasOwnProperty.call(message, "proposal"))
                            $root.ic_nns_common.pb.v1.ProposalId.encode(message.proposal, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.vote != null && Object.hasOwnProperty.call(message, "vote"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.vote);
                        return writer;
                    };

                    /**
                     * Encodes the specified RegisterVote message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.RegisterVote.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RegisterVote
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IRegisterVote} message RegisterVote message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RegisterVote.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a RegisterVote message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RegisterVote
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.RegisterVote} RegisterVote
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RegisterVote.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.RegisterVote();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.proposal = $root.ic_nns_common.pb.v1.ProposalId.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.vote = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a RegisterVote message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RegisterVote
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.RegisterVote} RegisterVote
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RegisterVote.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a RegisterVote message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RegisterVote
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RegisterVote.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.proposal != null && message.hasOwnProperty("proposal")) {
                            let error = $root.ic_nns_common.pb.v1.ProposalId.verify(message.proposal);
                            if (error)
                                return "proposal." + error;
                        }
                        if (message.vote != null && message.hasOwnProperty("vote"))
                            switch (message.vote) {
                            default:
                                return "vote: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a RegisterVote message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RegisterVote
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.RegisterVote} RegisterVote
                     */
                    RegisterVote.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.RegisterVote)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.RegisterVote();
                        if (object.proposal != null) {
                            if (typeof object.proposal !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.RegisterVote.proposal: object expected");
                            message.proposal = $root.ic_nns_common.pb.v1.ProposalId.fromObject(object.proposal);
                        }
                        switch (object.vote) {
                        case "VOTE_UNSPECIFIED":
                        case 0:
                            message.vote = 0;
                            break;
                        case "VOTE_YES":
                        case 1:
                            message.vote = 1;
                            break;
                        case "VOTE_NO":
                        case 2:
                            message.vote = 2;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a RegisterVote message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RegisterVote
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.RegisterVote} message RegisterVote
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RegisterVote.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.proposal = null;
                            object.vote = options.enums === String ? "VOTE_UNSPECIFIED" : 0;
                        }
                        if (message.proposal != null && message.hasOwnProperty("proposal"))
                            object.proposal = $root.ic_nns_common.pb.v1.ProposalId.toObject(message.proposal, options);
                        if (message.vote != null && message.hasOwnProperty("vote"))
                            object.vote = options.enums === String ? $root.ic_nns_governance.pb.v1.Vote[message.vote] : message.vote;
                        return object;
                    };

                    /**
                     * Converts this RegisterVote to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.RegisterVote
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RegisterVote.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return RegisterVote;
                })();

                ManageNeuron.ClaimOrRefresh = (function() {

                    /**
                     * Properties of a ClaimOrRefresh.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @interface IClaimOrRefresh
                     * @property {number|Long|null} [memo] ClaimOrRefresh memo
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.IMemoAndController|null} [memoAndController] ClaimOrRefresh memoAndController
                     * @property {ic_nns_governance.pb.v1.IEmpty|null} [neuronIdOrSubaccount] ClaimOrRefresh neuronIdOrSubaccount
                     */

                    /**
                     * Constructs a new ClaimOrRefresh.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron
                     * @classdesc Represents a ClaimOrRefresh.
                     * @implements IClaimOrRefresh
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IClaimOrRefresh=} [properties] Properties to set
                     */
                    function ClaimOrRefresh(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ClaimOrRefresh memo.
                     * @member {number|Long|null|undefined} memo
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @instance
                     */
                    ClaimOrRefresh.prototype.memo = null;

                    /**
                     * ClaimOrRefresh memoAndController.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.IMemoAndController|null|undefined} memoAndController
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @instance
                     */
                    ClaimOrRefresh.prototype.memoAndController = null;

                    /**
                     * ClaimOrRefresh neuronIdOrSubaccount.
                     * @member {ic_nns_governance.pb.v1.IEmpty|null|undefined} neuronIdOrSubaccount
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @instance
                     */
                    ClaimOrRefresh.prototype.neuronIdOrSubaccount = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * ClaimOrRefresh by.
                     * @member {"memo"|"memoAndController"|"neuronIdOrSubaccount"|undefined} by
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @instance
                     */
                    Object.defineProperty(ClaimOrRefresh.prototype, "by", {
                        get: $util.oneOfGetter($oneOfFields = ["memo", "memoAndController", "neuronIdOrSubaccount"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new ClaimOrRefresh instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IClaimOrRefresh=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh} ClaimOrRefresh instance
                     */
                    ClaimOrRefresh.create = function create(properties) {
                        return new ClaimOrRefresh(properties);
                    };

                    /**
                     * Encodes the specified ClaimOrRefresh message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IClaimOrRefresh} message ClaimOrRefresh message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClaimOrRefresh.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.memo);
                        if (message.memoAndController != null && Object.hasOwnProperty.call(message, "memoAndController"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController.encode(message.memoAndController, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.neuronIdOrSubaccount != null && Object.hasOwnProperty.call(message, "neuronIdOrSubaccount"))
                            $root.ic_nns_governance.pb.v1.Empty.encode(message.neuronIdOrSubaccount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ClaimOrRefresh message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.IClaimOrRefresh} message ClaimOrRefresh message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClaimOrRefresh.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ClaimOrRefresh message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh} ClaimOrRefresh
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClaimOrRefresh.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.memo = reader.uint64();
                                break;
                            case 2:
                                message.memoAndController = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.neuronIdOrSubaccount = $root.ic_nns_governance.pb.v1.Empty.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ClaimOrRefresh message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh} ClaimOrRefresh
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClaimOrRefresh.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ClaimOrRefresh message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ClaimOrRefresh.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.memo != null && message.hasOwnProperty("memo")) {
                            properties.by = 1;
                            if (!$util.isInteger(message.memo) && !(message.memo && $util.isInteger(message.memo.low) && $util.isInteger(message.memo.high)))
                                return "memo: integer|Long expected";
                        }
                        if (message.memoAndController != null && message.hasOwnProperty("memoAndController")) {
                            if (properties.by === 1)
                                return "by: multiple values";
                            properties.by = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController.verify(message.memoAndController);
                                if (error)
                                    return "memoAndController." + error;
                            }
                        }
                        if (message.neuronIdOrSubaccount != null && message.hasOwnProperty("neuronIdOrSubaccount")) {
                            if (properties.by === 1)
                                return "by: multiple values";
                            properties.by = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.Empty.verify(message.neuronIdOrSubaccount);
                                if (error)
                                    return "neuronIdOrSubaccount." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ClaimOrRefresh message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh} ClaimOrRefresh
                     */
                    ClaimOrRefresh.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh();
                        if (object.memo != null)
                            if ($util.Long)
                                (message.memo = $util.Long.fromValue(object.memo)).unsigned = true;
                            else if (typeof object.memo === "string")
                                message.memo = parseInt(object.memo, 10);
                            else if (typeof object.memo === "number")
                                message.memo = object.memo;
                            else if (typeof object.memo === "object")
                                message.memo = new $util.LongBits(object.memo.low >>> 0, object.memo.high >>> 0).toNumber(true);
                        if (object.memoAndController != null) {
                            if (typeof object.memoAndController !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.memoAndController: object expected");
                            message.memoAndController = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController.fromObject(object.memoAndController);
                        }
                        if (object.neuronIdOrSubaccount != null) {
                            if (typeof object.neuronIdOrSubaccount !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.neuronIdOrSubaccount: object expected");
                            message.neuronIdOrSubaccount = $root.ic_nns_governance.pb.v1.Empty.fromObject(object.neuronIdOrSubaccount);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ClaimOrRefresh message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh} message ClaimOrRefresh
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ClaimOrRefresh.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (message.memo != null && message.hasOwnProperty("memo")) {
                            if (typeof message.memo === "number")
                                object.memo = options.longs === String ? String(message.memo) : message.memo;
                            else
                                object.memo = options.longs === String ? $util.Long.prototype.toString.call(message.memo) : options.longs === Number ? new $util.LongBits(message.memo.low >>> 0, message.memo.high >>> 0).toNumber(true) : message.memo;
                            if (options.oneofs)
                                object.by = "memo";
                        }
                        if (message.memoAndController != null && message.hasOwnProperty("memoAndController")) {
                            object.memoAndController = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController.toObject(message.memoAndController, options);
                            if (options.oneofs)
                                object.by = "memoAndController";
                        }
                        if (message.neuronIdOrSubaccount != null && message.hasOwnProperty("neuronIdOrSubaccount")) {
                            object.neuronIdOrSubaccount = $root.ic_nns_governance.pb.v1.Empty.toObject(message.neuronIdOrSubaccount, options);
                            if (options.oneofs)
                                object.by = "neuronIdOrSubaccount";
                        }
                        return object;
                    };

                    /**
                     * Converts this ClaimOrRefresh to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ClaimOrRefresh.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    ClaimOrRefresh.MemoAndController = (function() {

                        /**
                         * Properties of a MemoAndController.
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                         * @interface IMemoAndController
                         * @property {number|Long|null} [memo] MemoAndController memo
                         * @property {ic_base_types.pb.v1.IPrincipalId|null} [controller] MemoAndController controller
                         */

                        /**
                         * Constructs a new MemoAndController.
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh
                         * @classdesc Represents a MemoAndController.
                         * @implements IMemoAndController
                         * @constructor
                         * @param {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.IMemoAndController=} [properties] Properties to set
                         */
                        function MemoAndController(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * MemoAndController memo.
                         * @member {number|Long} memo
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController
                         * @instance
                         */
                        MemoAndController.prototype.memo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                        /**
                         * MemoAndController controller.
                         * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} controller
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController
                         * @instance
                         */
                        MemoAndController.prototype.controller = null;

                        /**
                         * Creates a new MemoAndController instance using the specified properties.
                         * @function create
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController
                         * @static
                         * @param {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.IMemoAndController=} [properties] Properties to set
                         * @returns {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController} MemoAndController instance
                         */
                        MemoAndController.create = function create(properties) {
                            return new MemoAndController(properties);
                        };

                        /**
                         * Encodes the specified MemoAndController message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController.verify|verify} messages.
                         * @function encode
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController
                         * @static
                         * @param {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.IMemoAndController} message MemoAndController message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        MemoAndController.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.memo);
                            if (message.controller != null && Object.hasOwnProperty.call(message, "controller"))
                                $root.ic_base_types.pb.v1.PrincipalId.encode(message.controller, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified MemoAndController message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController
                         * @static
                         * @param {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.IMemoAndController} message MemoAndController message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        MemoAndController.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a MemoAndController message from the specified reader or buffer.
                         * @function decode
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController} MemoAndController
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        MemoAndController.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController();
                            while (reader.pos < end) {
                                let tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.memo = reader.uint64();
                                    break;
                                case 2:
                                    message.controller = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a MemoAndController message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController} MemoAndController
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        MemoAndController.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a MemoAndController message.
                         * @function verify
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        MemoAndController.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.memo != null && message.hasOwnProperty("memo"))
                                if (!$util.isInteger(message.memo) && !(message.memo && $util.isInteger(message.memo.low) && $util.isInteger(message.memo.high)))
                                    return "memo: integer|Long expected";
                            if (message.controller != null && message.hasOwnProperty("controller")) {
                                let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.controller);
                                if (error)
                                    return "controller." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a MemoAndController message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController} MemoAndController
                         */
                        MemoAndController.fromObject = function fromObject(object) {
                            if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController)
                                return object;
                            let message = new $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController();
                            if (object.memo != null)
                                if ($util.Long)
                                    (message.memo = $util.Long.fromValue(object.memo)).unsigned = true;
                                else if (typeof object.memo === "string")
                                    message.memo = parseInt(object.memo, 10);
                                else if (typeof object.memo === "number")
                                    message.memo = object.memo;
                                else if (typeof object.memo === "object")
                                    message.memo = new $util.LongBits(object.memo.low >>> 0, object.memo.high >>> 0).toNumber(true);
                            if (object.controller != null) {
                                if (typeof object.controller !== "object")
                                    throw TypeError(".ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController.controller: object expected");
                                message.controller = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.controller);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a MemoAndController message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController
                         * @static
                         * @param {ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController} message MemoAndController
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        MemoAndController.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                if ($util.Long) {
                                    let long = new $util.Long(0, 0, true);
                                    object.memo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.memo = options.longs === String ? "0" : 0;
                                object.controller = null;
                            }
                            if (message.memo != null && message.hasOwnProperty("memo"))
                                if (typeof message.memo === "number")
                                    object.memo = options.longs === String ? String(message.memo) : message.memo;
                                else
                                    object.memo = options.longs === String ? $util.Long.prototype.toString.call(message.memo) : options.longs === Number ? new $util.LongBits(message.memo.low >>> 0, message.memo.high >>> 0).toNumber(true) : message.memo;
                            if (message.controller != null && message.hasOwnProperty("controller"))
                                object.controller = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.controller, options);
                            return object;
                        };

                        /**
                         * Converts this MemoAndController to JSON.
                         * @function toJSON
                         * @memberof ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.MemoAndController
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        MemoAndController.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return MemoAndController;
                    })();

                    return ClaimOrRefresh;
                })();

                return ManageNeuron;
            })();

            v1.ManageNeuronResponse = (function() {

                /**
                 * Properties of a ManageNeuronResponse.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IManageNeuronResponse
                 * @property {ic_nns_governance.pb.v1.IGovernanceError|null} [error] ManageNeuronResponse error
                 * @property {ic_nns_governance.pb.v1.ManageNeuronResponse.IConfigureResponse|null} [configure] ManageNeuronResponse configure
                 * @property {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseResponse|null} [disburse] ManageNeuronResponse disburse
                 * @property {ic_nns_governance.pb.v1.ManageNeuronResponse.ISpawnResponse|null} [spawn] ManageNeuronResponse spawn
                 * @property {ic_nns_governance.pb.v1.ManageNeuronResponse.IFollowResponse|null} [follow] ManageNeuronResponse follow
                 * @property {ic_nns_governance.pb.v1.ManageNeuronResponse.IMakeProposalResponse|null} [makeProposal] ManageNeuronResponse makeProposal
                 * @property {ic_nns_governance.pb.v1.ManageNeuronResponse.IRegisterVoteResponse|null} [registerVote] ManageNeuronResponse registerVote
                 * @property {ic_nns_governance.pb.v1.ManageNeuronResponse.ISplitResponse|null} [split] ManageNeuronResponse split
                 * @property {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseToNeuronResponse|null} [disburseToNeuron] ManageNeuronResponse disburseToNeuron
                 * @property {ic_nns_governance.pb.v1.ManageNeuronResponse.IClaimOrRefreshResponse|null} [claimOrRefresh] ManageNeuronResponse claimOrRefresh
                 * @property {ic_nns_governance.pb.v1.ManageNeuronResponse.IMergeMaturityResponse|null} [mergeMaturity] ManageNeuronResponse mergeMaturity
                 */

                /**
                 * Constructs a new ManageNeuronResponse.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a ManageNeuronResponse.
                 * @implements IManageNeuronResponse
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IManageNeuronResponse=} [properties] Properties to set
                 */
                function ManageNeuronResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ManageNeuronResponse error.
                 * @member {ic_nns_governance.pb.v1.IGovernanceError|null|undefined} error
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                ManageNeuronResponse.prototype.error = null;

                /**
                 * ManageNeuronResponse configure.
                 * @member {ic_nns_governance.pb.v1.ManageNeuronResponse.IConfigureResponse|null|undefined} configure
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                ManageNeuronResponse.prototype.configure = null;

                /**
                 * ManageNeuronResponse disburse.
                 * @member {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseResponse|null|undefined} disburse
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                ManageNeuronResponse.prototype.disburse = null;

                /**
                 * ManageNeuronResponse spawn.
                 * @member {ic_nns_governance.pb.v1.ManageNeuronResponse.ISpawnResponse|null|undefined} spawn
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                ManageNeuronResponse.prototype.spawn = null;

                /**
                 * ManageNeuronResponse follow.
                 * @member {ic_nns_governance.pb.v1.ManageNeuronResponse.IFollowResponse|null|undefined} follow
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                ManageNeuronResponse.prototype.follow = null;

                /**
                 * ManageNeuronResponse makeProposal.
                 * @member {ic_nns_governance.pb.v1.ManageNeuronResponse.IMakeProposalResponse|null|undefined} makeProposal
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                ManageNeuronResponse.prototype.makeProposal = null;

                /**
                 * ManageNeuronResponse registerVote.
                 * @member {ic_nns_governance.pb.v1.ManageNeuronResponse.IRegisterVoteResponse|null|undefined} registerVote
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                ManageNeuronResponse.prototype.registerVote = null;

                /**
                 * ManageNeuronResponse split.
                 * @member {ic_nns_governance.pb.v1.ManageNeuronResponse.ISplitResponse|null|undefined} split
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                ManageNeuronResponse.prototype.split = null;

                /**
                 * ManageNeuronResponse disburseToNeuron.
                 * @member {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseToNeuronResponse|null|undefined} disburseToNeuron
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                ManageNeuronResponse.prototype.disburseToNeuron = null;

                /**
                 * ManageNeuronResponse claimOrRefresh.
                 * @member {ic_nns_governance.pb.v1.ManageNeuronResponse.IClaimOrRefreshResponse|null|undefined} claimOrRefresh
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                ManageNeuronResponse.prototype.claimOrRefresh = null;

                /**
                 * ManageNeuronResponse mergeMaturity.
                 * @member {ic_nns_governance.pb.v1.ManageNeuronResponse.IMergeMaturityResponse|null|undefined} mergeMaturity
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                ManageNeuronResponse.prototype.mergeMaturity = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * ManageNeuronResponse command.
                 * @member {"error"|"configure"|"disburse"|"spawn"|"follow"|"makeProposal"|"registerVote"|"split"|"disburseToNeuron"|"claimOrRefresh"|"mergeMaturity"|undefined} command
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 */
                Object.defineProperty(ManageNeuronResponse.prototype, "command", {
                    get: $util.oneOfGetter($oneOfFields = ["error", "configure", "disburse", "spawn", "follow", "makeProposal", "registerVote", "split", "disburseToNeuron", "claimOrRefresh", "mergeMaturity"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new ManageNeuronResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IManageNeuronResponse=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse} ManageNeuronResponse instance
                 */
                ManageNeuronResponse.create = function create(properties) {
                    return new ManageNeuronResponse(properties);
                };

                /**
                 * Encodes the specified ManageNeuronResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IManageNeuronResponse} message ManageNeuronResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ManageNeuronResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.ic_nns_governance.pb.v1.GovernanceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.configure != null && Object.hasOwnProperty.call(message, "configure"))
                        $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse.encode(message.configure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.disburse != null && Object.hasOwnProperty.call(message, "disburse"))
                        $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse.encode(message.disburse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.spawn != null && Object.hasOwnProperty.call(message, "spawn"))
                        $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse.encode(message.spawn, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.follow != null && Object.hasOwnProperty.call(message, "follow"))
                        $root.ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse.encode(message.follow, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.makeProposal != null && Object.hasOwnProperty.call(message, "makeProposal"))
                        $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse.encode(message.makeProposal, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.registerVote != null && Object.hasOwnProperty.call(message, "registerVote"))
                        $root.ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse.encode(message.registerVote, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.split != null && Object.hasOwnProperty.call(message, "split"))
                        $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse.encode(message.split, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.disburseToNeuron != null && Object.hasOwnProperty.call(message, "disburseToNeuron"))
                        $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse.encode(message.disburseToNeuron, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.claimOrRefresh != null && Object.hasOwnProperty.call(message, "claimOrRefresh"))
                        $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse.encode(message.claimOrRefresh, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.mergeMaturity != null && Object.hasOwnProperty.call(message, "mergeMaturity"))
                        $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse.encode(message.mergeMaturity, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ManageNeuronResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IManageNeuronResponse} message ManageNeuronResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ManageNeuronResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ManageNeuronResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse} ManageNeuronResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ManageNeuronResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.ic_nns_governance.pb.v1.GovernanceError.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.configure = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.disburse = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.spawn = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.follow = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.makeProposal = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.registerVote = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.split = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.disburseToNeuron = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.claimOrRefresh = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.mergeMaturity = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ManageNeuronResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse} ManageNeuronResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ManageNeuronResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ManageNeuronResponse message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ManageNeuronResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.error != null && message.hasOwnProperty("error")) {
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.GovernanceError.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                    }
                    if (message.configure != null && message.hasOwnProperty("configure")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse.verify(message.configure);
                            if (error)
                                return "configure." + error;
                        }
                    }
                    if (message.disburse != null && message.hasOwnProperty("disburse")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse.verify(message.disburse);
                            if (error)
                                return "disburse." + error;
                        }
                    }
                    if (message.spawn != null && message.hasOwnProperty("spawn")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse.verify(message.spawn);
                            if (error)
                                return "spawn." + error;
                        }
                    }
                    if (message.follow != null && message.hasOwnProperty("follow")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse.verify(message.follow);
                            if (error)
                                return "follow." + error;
                        }
                    }
                    if (message.makeProposal != null && message.hasOwnProperty("makeProposal")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse.verify(message.makeProposal);
                            if (error)
                                return "makeProposal." + error;
                        }
                    }
                    if (message.registerVote != null && message.hasOwnProperty("registerVote")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse.verify(message.registerVote);
                            if (error)
                                return "registerVote." + error;
                        }
                    }
                    if (message.split != null && message.hasOwnProperty("split")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse.verify(message.split);
                            if (error)
                                return "split." + error;
                        }
                    }
                    if (message.disburseToNeuron != null && message.hasOwnProperty("disburseToNeuron")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse.verify(message.disburseToNeuron);
                            if (error)
                                return "disburseToNeuron." + error;
                        }
                    }
                    if (message.claimOrRefresh != null && message.hasOwnProperty("claimOrRefresh")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse.verify(message.claimOrRefresh);
                            if (error)
                                return "claimOrRefresh." + error;
                        }
                    }
                    if (message.mergeMaturity != null && message.hasOwnProperty("mergeMaturity")) {
                        if (properties.command === 1)
                            return "command: multiple values";
                        properties.command = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse.verify(message.mergeMaturity);
                            if (error)
                                return "mergeMaturity." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ManageNeuronResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse} ManageNeuronResponse
                 */
                ManageNeuronResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuronResponse)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.error: object expected");
                        message.error = $root.ic_nns_governance.pb.v1.GovernanceError.fromObject(object.error);
                    }
                    if (object.configure != null) {
                        if (typeof object.configure !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.configure: object expected");
                        message.configure = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse.fromObject(object.configure);
                    }
                    if (object.disburse != null) {
                        if (typeof object.disburse !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.disburse: object expected");
                        message.disburse = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse.fromObject(object.disburse);
                    }
                    if (object.spawn != null) {
                        if (typeof object.spawn !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.spawn: object expected");
                        message.spawn = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse.fromObject(object.spawn);
                    }
                    if (object.follow != null) {
                        if (typeof object.follow !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.follow: object expected");
                        message.follow = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse.fromObject(object.follow);
                    }
                    if (object.makeProposal != null) {
                        if (typeof object.makeProposal !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.makeProposal: object expected");
                        message.makeProposal = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse.fromObject(object.makeProposal);
                    }
                    if (object.registerVote != null) {
                        if (typeof object.registerVote !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.registerVote: object expected");
                        message.registerVote = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse.fromObject(object.registerVote);
                    }
                    if (object.split != null) {
                        if (typeof object.split !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.split: object expected");
                        message.split = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse.fromObject(object.split);
                    }
                    if (object.disburseToNeuron != null) {
                        if (typeof object.disburseToNeuron !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.disburseToNeuron: object expected");
                        message.disburseToNeuron = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse.fromObject(object.disburseToNeuron);
                    }
                    if (object.claimOrRefresh != null) {
                        if (typeof object.claimOrRefresh !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.claimOrRefresh: object expected");
                        message.claimOrRefresh = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse.fromObject(object.claimOrRefresh);
                    }
                    if (object.mergeMaturity != null) {
                        if (typeof object.mergeMaturity !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.mergeMaturity: object expected");
                        message.mergeMaturity = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse.fromObject(object.mergeMaturity);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ManageNeuronResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.ManageNeuronResponse} message ManageNeuronResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ManageNeuronResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.error != null && message.hasOwnProperty("error")) {
                        object.error = $root.ic_nns_governance.pb.v1.GovernanceError.toObject(message.error, options);
                        if (options.oneofs)
                            object.command = "error";
                    }
                    if (message.configure != null && message.hasOwnProperty("configure")) {
                        object.configure = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse.toObject(message.configure, options);
                        if (options.oneofs)
                            object.command = "configure";
                    }
                    if (message.disburse != null && message.hasOwnProperty("disburse")) {
                        object.disburse = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse.toObject(message.disburse, options);
                        if (options.oneofs)
                            object.command = "disburse";
                    }
                    if (message.spawn != null && message.hasOwnProperty("spawn")) {
                        object.spawn = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse.toObject(message.spawn, options);
                        if (options.oneofs)
                            object.command = "spawn";
                    }
                    if (message.follow != null && message.hasOwnProperty("follow")) {
                        object.follow = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse.toObject(message.follow, options);
                        if (options.oneofs)
                            object.command = "follow";
                    }
                    if (message.makeProposal != null && message.hasOwnProperty("makeProposal")) {
                        object.makeProposal = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse.toObject(message.makeProposal, options);
                        if (options.oneofs)
                            object.command = "makeProposal";
                    }
                    if (message.registerVote != null && message.hasOwnProperty("registerVote")) {
                        object.registerVote = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse.toObject(message.registerVote, options);
                        if (options.oneofs)
                            object.command = "registerVote";
                    }
                    if (message.split != null && message.hasOwnProperty("split")) {
                        object.split = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse.toObject(message.split, options);
                        if (options.oneofs)
                            object.command = "split";
                    }
                    if (message.disburseToNeuron != null && message.hasOwnProperty("disburseToNeuron")) {
                        object.disburseToNeuron = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse.toObject(message.disburseToNeuron, options);
                        if (options.oneofs)
                            object.command = "disburseToNeuron";
                    }
                    if (message.claimOrRefresh != null && message.hasOwnProperty("claimOrRefresh")) {
                        object.claimOrRefresh = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse.toObject(message.claimOrRefresh, options);
                        if (options.oneofs)
                            object.command = "claimOrRefresh";
                    }
                    if (message.mergeMaturity != null && message.hasOwnProperty("mergeMaturity")) {
                        object.mergeMaturity = $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse.toObject(message.mergeMaturity, options);
                        if (options.oneofs)
                            object.command = "mergeMaturity";
                    }
                    return object;
                };

                /**
                 * Converts this ManageNeuronResponse to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ManageNeuronResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                ManageNeuronResponse.ConfigureResponse = (function() {

                    /**
                     * Properties of a ConfigureResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @interface IConfigureResponse
                     */

                    /**
                     * Constructs a new ConfigureResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @classdesc Represents a ConfigureResponse.
                     * @implements IConfigureResponse
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IConfigureResponse=} [properties] Properties to set
                     */
                    function ConfigureResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new ConfigureResponse instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IConfigureResponse=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse} ConfigureResponse instance
                     */
                    ConfigureResponse.create = function create(properties) {
                        return new ConfigureResponse(properties);
                    };

                    /**
                     * Encodes the specified ConfigureResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IConfigureResponse} message ConfigureResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ConfigureResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified ConfigureResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IConfigureResponse} message ConfigureResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ConfigureResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ConfigureResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse} ConfigureResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ConfigureResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ConfigureResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse} ConfigureResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ConfigureResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ConfigureResponse message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ConfigureResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a ConfigureResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse} ConfigureResponse
                     */
                    ConfigureResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse)
                            return object;
                        return new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse();
                    };

                    /**
                     * Creates a plain object from a ConfigureResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse} message ConfigureResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ConfigureResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this ConfigureResponse to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ConfigureResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ConfigureResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ConfigureResponse;
                })();

                ManageNeuronResponse.DisburseResponse = (function() {

                    /**
                     * Properties of a DisburseResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @interface IDisburseResponse
                     * @property {number|Long|null} [transferBlockHeight] DisburseResponse transferBlockHeight
                     */

                    /**
                     * Constructs a new DisburseResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @classdesc Represents a DisburseResponse.
                     * @implements IDisburseResponse
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseResponse=} [properties] Properties to set
                     */
                    function DisburseResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * DisburseResponse transferBlockHeight.
                     * @member {number|Long} transferBlockHeight
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse
                     * @instance
                     */
                    DisburseResponse.prototype.transferBlockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new DisburseResponse instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseResponse=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse} DisburseResponse instance
                     */
                    DisburseResponse.create = function create(properties) {
                        return new DisburseResponse(properties);
                    };

                    /**
                     * Encodes the specified DisburseResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseResponse} message DisburseResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DisburseResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transferBlockHeight != null && Object.hasOwnProperty.call(message, "transferBlockHeight"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.transferBlockHeight);
                        return writer;
                    };

                    /**
                     * Encodes the specified DisburseResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseResponse} message DisburseResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DisburseResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a DisburseResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse} DisburseResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DisburseResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transferBlockHeight = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a DisburseResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse} DisburseResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DisburseResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a DisburseResponse message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DisburseResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transferBlockHeight != null && message.hasOwnProperty("transferBlockHeight"))
                            if (!$util.isInteger(message.transferBlockHeight) && !(message.transferBlockHeight && $util.isInteger(message.transferBlockHeight.low) && $util.isInteger(message.transferBlockHeight.high)))
                                return "transferBlockHeight: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a DisburseResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse} DisburseResponse
                     */
                    DisburseResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse();
                        if (object.transferBlockHeight != null)
                            if ($util.Long)
                                (message.transferBlockHeight = $util.Long.fromValue(object.transferBlockHeight)).unsigned = true;
                            else if (typeof object.transferBlockHeight === "string")
                                message.transferBlockHeight = parseInt(object.transferBlockHeight, 10);
                            else if (typeof object.transferBlockHeight === "number")
                                message.transferBlockHeight = object.transferBlockHeight;
                            else if (typeof object.transferBlockHeight === "object")
                                message.transferBlockHeight = new $util.LongBits(object.transferBlockHeight.low >>> 0, object.transferBlockHeight.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a DisburseResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse} message DisburseResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DisburseResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.transferBlockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.transferBlockHeight = options.longs === String ? "0" : 0;
                        if (message.transferBlockHeight != null && message.hasOwnProperty("transferBlockHeight"))
                            if (typeof message.transferBlockHeight === "number")
                                object.transferBlockHeight = options.longs === String ? String(message.transferBlockHeight) : message.transferBlockHeight;
                            else
                                object.transferBlockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.transferBlockHeight) : options.longs === Number ? new $util.LongBits(message.transferBlockHeight.low >>> 0, message.transferBlockHeight.high >>> 0).toNumber(true) : message.transferBlockHeight;
                        return object;
                    };

                    /**
                     * Converts this DisburseResponse to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DisburseResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return DisburseResponse;
                })();

                ManageNeuronResponse.SpawnResponse = (function() {

                    /**
                     * Properties of a SpawnResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @interface ISpawnResponse
                     * @property {ic_nns_common.pb.v1.INeuronId|null} [createdNeuronId] SpawnResponse createdNeuronId
                     */

                    /**
                     * Constructs a new SpawnResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @classdesc Represents a SpawnResponse.
                     * @implements ISpawnResponse
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.ISpawnResponse=} [properties] Properties to set
                     */
                    function SpawnResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SpawnResponse createdNeuronId.
                     * @member {ic_nns_common.pb.v1.INeuronId|null|undefined} createdNeuronId
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse
                     * @instance
                     */
                    SpawnResponse.prototype.createdNeuronId = null;

                    /**
                     * Creates a new SpawnResponse instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.ISpawnResponse=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse} SpawnResponse instance
                     */
                    SpawnResponse.create = function create(properties) {
                        return new SpawnResponse(properties);
                    };

                    /**
                     * Encodes the specified SpawnResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.ISpawnResponse} message SpawnResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SpawnResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.createdNeuronId != null && Object.hasOwnProperty.call(message, "createdNeuronId"))
                            $root.ic_nns_common.pb.v1.NeuronId.encode(message.createdNeuronId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified SpawnResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.ISpawnResponse} message SpawnResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SpawnResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SpawnResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse} SpawnResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SpawnResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.createdNeuronId = $root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SpawnResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse} SpawnResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SpawnResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a SpawnResponse message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SpawnResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.createdNeuronId != null && message.hasOwnProperty("createdNeuronId")) {
                            let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.createdNeuronId);
                            if (error)
                                return "createdNeuronId." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a SpawnResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse} SpawnResponse
                     */
                    SpawnResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse();
                        if (object.createdNeuronId != null) {
                            if (typeof object.createdNeuronId !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse.createdNeuronId: object expected");
                            message.createdNeuronId = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.createdNeuronId);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a SpawnResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse} message SpawnResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SpawnResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.createdNeuronId = null;
                        if (message.createdNeuronId != null && message.hasOwnProperty("createdNeuronId"))
                            object.createdNeuronId = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.createdNeuronId, options);
                        return object;
                    };

                    /**
                     * Converts this SpawnResponse to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SpawnResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SpawnResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SpawnResponse;
                })();

                ManageNeuronResponse.MergeMaturityResponse = (function() {

                    /**
                     * Properties of a MergeMaturityResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @interface IMergeMaturityResponse
                     * @property {number|Long|null} [mergedMaturityE8s] MergeMaturityResponse mergedMaturityE8s
                     * @property {number|Long|null} [newStakeE8s] MergeMaturityResponse newStakeE8s
                     */

                    /**
                     * Constructs a new MergeMaturityResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @classdesc Represents a MergeMaturityResponse.
                     * @implements IMergeMaturityResponse
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IMergeMaturityResponse=} [properties] Properties to set
                     */
                    function MergeMaturityResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MergeMaturityResponse mergedMaturityE8s.
                     * @member {number|Long} mergedMaturityE8s
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse
                     * @instance
                     */
                    MergeMaturityResponse.prototype.mergedMaturityE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * MergeMaturityResponse newStakeE8s.
                     * @member {number|Long} newStakeE8s
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse
                     * @instance
                     */
                    MergeMaturityResponse.prototype.newStakeE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new MergeMaturityResponse instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IMergeMaturityResponse=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse} MergeMaturityResponse instance
                     */
                    MergeMaturityResponse.create = function create(properties) {
                        return new MergeMaturityResponse(properties);
                    };

                    /**
                     * Encodes the specified MergeMaturityResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IMergeMaturityResponse} message MergeMaturityResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MergeMaturityResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.mergedMaturityE8s != null && Object.hasOwnProperty.call(message, "mergedMaturityE8s"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.mergedMaturityE8s);
                        if (message.newStakeE8s != null && Object.hasOwnProperty.call(message, "newStakeE8s"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.newStakeE8s);
                        return writer;
                    };

                    /**
                     * Encodes the specified MergeMaturityResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IMergeMaturityResponse} message MergeMaturityResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MergeMaturityResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MergeMaturityResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse} MergeMaturityResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MergeMaturityResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.mergedMaturityE8s = reader.uint64();
                                break;
                            case 2:
                                message.newStakeE8s = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MergeMaturityResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse} MergeMaturityResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MergeMaturityResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MergeMaturityResponse message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MergeMaturityResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.mergedMaturityE8s != null && message.hasOwnProperty("mergedMaturityE8s"))
                            if (!$util.isInteger(message.mergedMaturityE8s) && !(message.mergedMaturityE8s && $util.isInteger(message.mergedMaturityE8s.low) && $util.isInteger(message.mergedMaturityE8s.high)))
                                return "mergedMaturityE8s: integer|Long expected";
                        if (message.newStakeE8s != null && message.hasOwnProperty("newStakeE8s"))
                            if (!$util.isInteger(message.newStakeE8s) && !(message.newStakeE8s && $util.isInteger(message.newStakeE8s.low) && $util.isInteger(message.newStakeE8s.high)))
                                return "newStakeE8s: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a MergeMaturityResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse} MergeMaturityResponse
                     */
                    MergeMaturityResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse();
                        if (object.mergedMaturityE8s != null)
                            if ($util.Long)
                                (message.mergedMaturityE8s = $util.Long.fromValue(object.mergedMaturityE8s)).unsigned = true;
                            else if (typeof object.mergedMaturityE8s === "string")
                                message.mergedMaturityE8s = parseInt(object.mergedMaturityE8s, 10);
                            else if (typeof object.mergedMaturityE8s === "number")
                                message.mergedMaturityE8s = object.mergedMaturityE8s;
                            else if (typeof object.mergedMaturityE8s === "object")
                                message.mergedMaturityE8s = new $util.LongBits(object.mergedMaturityE8s.low >>> 0, object.mergedMaturityE8s.high >>> 0).toNumber(true);
                        if (object.newStakeE8s != null)
                            if ($util.Long)
                                (message.newStakeE8s = $util.Long.fromValue(object.newStakeE8s)).unsigned = true;
                            else if (typeof object.newStakeE8s === "string")
                                message.newStakeE8s = parseInt(object.newStakeE8s, 10);
                            else if (typeof object.newStakeE8s === "number")
                                message.newStakeE8s = object.newStakeE8s;
                            else if (typeof object.newStakeE8s === "object")
                                message.newStakeE8s = new $util.LongBits(object.newStakeE8s.low >>> 0, object.newStakeE8s.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a MergeMaturityResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse} message MergeMaturityResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MergeMaturityResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.mergedMaturityE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.mergedMaturityE8s = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.newStakeE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.newStakeE8s = options.longs === String ? "0" : 0;
                        }
                        if (message.mergedMaturityE8s != null && message.hasOwnProperty("mergedMaturityE8s"))
                            if (typeof message.mergedMaturityE8s === "number")
                                object.mergedMaturityE8s = options.longs === String ? String(message.mergedMaturityE8s) : message.mergedMaturityE8s;
                            else
                                object.mergedMaturityE8s = options.longs === String ? $util.Long.prototype.toString.call(message.mergedMaturityE8s) : options.longs === Number ? new $util.LongBits(message.mergedMaturityE8s.low >>> 0, message.mergedMaturityE8s.high >>> 0).toNumber(true) : message.mergedMaturityE8s;
                        if (message.newStakeE8s != null && message.hasOwnProperty("newStakeE8s"))
                            if (typeof message.newStakeE8s === "number")
                                object.newStakeE8s = options.longs === String ? String(message.newStakeE8s) : message.newStakeE8s;
                            else
                                object.newStakeE8s = options.longs === String ? $util.Long.prototype.toString.call(message.newStakeE8s) : options.longs === Number ? new $util.LongBits(message.newStakeE8s.low >>> 0, message.newStakeE8s.high >>> 0).toNumber(true) : message.newStakeE8s;
                        return object;
                    };

                    /**
                     * Converts this MergeMaturityResponse to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MergeMaturityResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MergeMaturityResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return MergeMaturityResponse;
                })();

                ManageNeuronResponse.FollowResponse = (function() {

                    /**
                     * Properties of a FollowResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @interface IFollowResponse
                     */

                    /**
                     * Constructs a new FollowResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @classdesc Represents a FollowResponse.
                     * @implements IFollowResponse
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IFollowResponse=} [properties] Properties to set
                     */
                    function FollowResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new FollowResponse instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IFollowResponse=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse} FollowResponse instance
                     */
                    FollowResponse.create = function create(properties) {
                        return new FollowResponse(properties);
                    };

                    /**
                     * Encodes the specified FollowResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IFollowResponse} message FollowResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FollowResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified FollowResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IFollowResponse} message FollowResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FollowResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a FollowResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse} FollowResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FollowResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a FollowResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse} FollowResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FollowResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a FollowResponse message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FollowResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a FollowResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse} FollowResponse
                     */
                    FollowResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse)
                            return object;
                        return new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse();
                    };

                    /**
                     * Creates a plain object from a FollowResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse} message FollowResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FollowResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this FollowResponse to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.FollowResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FollowResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return FollowResponse;
                })();

                ManageNeuronResponse.MakeProposalResponse = (function() {

                    /**
                     * Properties of a MakeProposalResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @interface IMakeProposalResponse
                     * @property {ic_nns_common.pb.v1.IProposalId|null} [proposalId] MakeProposalResponse proposalId
                     */

                    /**
                     * Constructs a new MakeProposalResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @classdesc Represents a MakeProposalResponse.
                     * @implements IMakeProposalResponse
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IMakeProposalResponse=} [properties] Properties to set
                     */
                    function MakeProposalResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MakeProposalResponse proposalId.
                     * @member {ic_nns_common.pb.v1.IProposalId|null|undefined} proposalId
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse
                     * @instance
                     */
                    MakeProposalResponse.prototype.proposalId = null;

                    /**
                     * Creates a new MakeProposalResponse instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IMakeProposalResponse=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse} MakeProposalResponse instance
                     */
                    MakeProposalResponse.create = function create(properties) {
                        return new MakeProposalResponse(properties);
                    };

                    /**
                     * Encodes the specified MakeProposalResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IMakeProposalResponse} message MakeProposalResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MakeProposalResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.proposalId != null && Object.hasOwnProperty.call(message, "proposalId"))
                            $root.ic_nns_common.pb.v1.ProposalId.encode(message.proposalId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified MakeProposalResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IMakeProposalResponse} message MakeProposalResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MakeProposalResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MakeProposalResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse} MakeProposalResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MakeProposalResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.proposalId = $root.ic_nns_common.pb.v1.ProposalId.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MakeProposalResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse} MakeProposalResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MakeProposalResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MakeProposalResponse message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    MakeProposalResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.proposalId != null && message.hasOwnProperty("proposalId")) {
                            let error = $root.ic_nns_common.pb.v1.ProposalId.verify(message.proposalId);
                            if (error)
                                return "proposalId." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a MakeProposalResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse} MakeProposalResponse
                     */
                    MakeProposalResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse();
                        if (object.proposalId != null) {
                            if (typeof object.proposalId !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse.proposalId: object expected");
                            message.proposalId = $root.ic_nns_common.pb.v1.ProposalId.fromObject(object.proposalId);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a MakeProposalResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse} message MakeProposalResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MakeProposalResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.proposalId = null;
                        if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                            object.proposalId = $root.ic_nns_common.pb.v1.ProposalId.toObject(message.proposalId, options);
                        return object;
                    };

                    /**
                     * Converts this MakeProposalResponse to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.MakeProposalResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    MakeProposalResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return MakeProposalResponse;
                })();

                ManageNeuronResponse.RegisterVoteResponse = (function() {

                    /**
                     * Properties of a RegisterVoteResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @interface IRegisterVoteResponse
                     */

                    /**
                     * Constructs a new RegisterVoteResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @classdesc Represents a RegisterVoteResponse.
                     * @implements IRegisterVoteResponse
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IRegisterVoteResponse=} [properties] Properties to set
                     */
                    function RegisterVoteResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new RegisterVoteResponse instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IRegisterVoteResponse=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse} RegisterVoteResponse instance
                     */
                    RegisterVoteResponse.create = function create(properties) {
                        return new RegisterVoteResponse(properties);
                    };

                    /**
                     * Encodes the specified RegisterVoteResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IRegisterVoteResponse} message RegisterVoteResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RegisterVoteResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified RegisterVoteResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IRegisterVoteResponse} message RegisterVoteResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    RegisterVoteResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a RegisterVoteResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse} RegisterVoteResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RegisterVoteResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a RegisterVoteResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse} RegisterVoteResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    RegisterVoteResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a RegisterVoteResponse message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RegisterVoteResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a RegisterVoteResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse} RegisterVoteResponse
                     */
                    RegisterVoteResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse)
                            return object;
                        return new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse();
                    };

                    /**
                     * Creates a plain object from a RegisterVoteResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse} message RegisterVoteResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RegisterVoteResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this RegisterVoteResponse to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.RegisterVoteResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RegisterVoteResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return RegisterVoteResponse;
                })();

                ManageNeuronResponse.SplitResponse = (function() {

                    /**
                     * Properties of a SplitResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @interface ISplitResponse
                     * @property {ic_nns_common.pb.v1.INeuronId|null} [createdNeuronId] SplitResponse createdNeuronId
                     */

                    /**
                     * Constructs a new SplitResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @classdesc Represents a SplitResponse.
                     * @implements ISplitResponse
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.ISplitResponse=} [properties] Properties to set
                     */
                    function SplitResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SplitResponse createdNeuronId.
                     * @member {ic_nns_common.pb.v1.INeuronId|null|undefined} createdNeuronId
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse
                     * @instance
                     */
                    SplitResponse.prototype.createdNeuronId = null;

                    /**
                     * Creates a new SplitResponse instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.ISplitResponse=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse} SplitResponse instance
                     */
                    SplitResponse.create = function create(properties) {
                        return new SplitResponse(properties);
                    };

                    /**
                     * Encodes the specified SplitResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.ISplitResponse} message SplitResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SplitResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.createdNeuronId != null && Object.hasOwnProperty.call(message, "createdNeuronId"))
                            $root.ic_nns_common.pb.v1.NeuronId.encode(message.createdNeuronId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified SplitResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.ISplitResponse} message SplitResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SplitResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SplitResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse} SplitResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SplitResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.createdNeuronId = $root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SplitResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse} SplitResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SplitResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a SplitResponse message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SplitResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.createdNeuronId != null && message.hasOwnProperty("createdNeuronId")) {
                            let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.createdNeuronId);
                            if (error)
                                return "createdNeuronId." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a SplitResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse} SplitResponse
                     */
                    SplitResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse();
                        if (object.createdNeuronId != null) {
                            if (typeof object.createdNeuronId !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse.createdNeuronId: object expected");
                            message.createdNeuronId = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.createdNeuronId);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a SplitResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse} message SplitResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SplitResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.createdNeuronId = null;
                        if (message.createdNeuronId != null && message.hasOwnProperty("createdNeuronId"))
                            object.createdNeuronId = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.createdNeuronId, options);
                        return object;
                    };

                    /**
                     * Converts this SplitResponse to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.SplitResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SplitResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SplitResponse;
                })();

                ManageNeuronResponse.DisburseToNeuronResponse = (function() {

                    /**
                     * Properties of a DisburseToNeuronResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @interface IDisburseToNeuronResponse
                     * @property {ic_nns_common.pb.v1.INeuronId|null} [createdNeuronId] DisburseToNeuronResponse createdNeuronId
                     */

                    /**
                     * Constructs a new DisburseToNeuronResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @classdesc Represents a DisburseToNeuronResponse.
                     * @implements IDisburseToNeuronResponse
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseToNeuronResponse=} [properties] Properties to set
                     */
                    function DisburseToNeuronResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * DisburseToNeuronResponse createdNeuronId.
                     * @member {ic_nns_common.pb.v1.INeuronId|null|undefined} createdNeuronId
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse
                     * @instance
                     */
                    DisburseToNeuronResponse.prototype.createdNeuronId = null;

                    /**
                     * Creates a new DisburseToNeuronResponse instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseToNeuronResponse=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse} DisburseToNeuronResponse instance
                     */
                    DisburseToNeuronResponse.create = function create(properties) {
                        return new DisburseToNeuronResponse(properties);
                    };

                    /**
                     * Encodes the specified DisburseToNeuronResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseToNeuronResponse} message DisburseToNeuronResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DisburseToNeuronResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.createdNeuronId != null && Object.hasOwnProperty.call(message, "createdNeuronId"))
                            $root.ic_nns_common.pb.v1.NeuronId.encode(message.createdNeuronId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified DisburseToNeuronResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IDisburseToNeuronResponse} message DisburseToNeuronResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DisburseToNeuronResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a DisburseToNeuronResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse} DisburseToNeuronResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DisburseToNeuronResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.createdNeuronId = $root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a DisburseToNeuronResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse} DisburseToNeuronResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DisburseToNeuronResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a DisburseToNeuronResponse message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DisburseToNeuronResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.createdNeuronId != null && message.hasOwnProperty("createdNeuronId")) {
                            let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.createdNeuronId);
                            if (error)
                                return "createdNeuronId." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a DisburseToNeuronResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse} DisburseToNeuronResponse
                     */
                    DisburseToNeuronResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse();
                        if (object.createdNeuronId != null) {
                            if (typeof object.createdNeuronId !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse.createdNeuronId: object expected");
                            message.createdNeuronId = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.createdNeuronId);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a DisburseToNeuronResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse} message DisburseToNeuronResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DisburseToNeuronResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.createdNeuronId = null;
                        if (message.createdNeuronId != null && message.hasOwnProperty("createdNeuronId"))
                            object.createdNeuronId = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.createdNeuronId, options);
                        return object;
                    };

                    /**
                     * Converts this DisburseToNeuronResponse to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.DisburseToNeuronResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DisburseToNeuronResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return DisburseToNeuronResponse;
                })();

                ManageNeuronResponse.ClaimOrRefreshResponse = (function() {

                    /**
                     * Properties of a ClaimOrRefreshResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @interface IClaimOrRefreshResponse
                     * @property {ic_nns_common.pb.v1.INeuronId|null} [refreshedNeuronId] ClaimOrRefreshResponse refreshedNeuronId
                     */

                    /**
                     * Constructs a new ClaimOrRefreshResponse.
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse
                     * @classdesc Represents a ClaimOrRefreshResponse.
                     * @implements IClaimOrRefreshResponse
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IClaimOrRefreshResponse=} [properties] Properties to set
                     */
                    function ClaimOrRefreshResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ClaimOrRefreshResponse refreshedNeuronId.
                     * @member {ic_nns_common.pb.v1.INeuronId|null|undefined} refreshedNeuronId
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse
                     * @instance
                     */
                    ClaimOrRefreshResponse.prototype.refreshedNeuronId = null;

                    /**
                     * Creates a new ClaimOrRefreshResponse instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IClaimOrRefreshResponse=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse} ClaimOrRefreshResponse instance
                     */
                    ClaimOrRefreshResponse.create = function create(properties) {
                        return new ClaimOrRefreshResponse(properties);
                    };

                    /**
                     * Encodes the specified ClaimOrRefreshResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IClaimOrRefreshResponse} message ClaimOrRefreshResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClaimOrRefreshResponse.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.refreshedNeuronId != null && Object.hasOwnProperty.call(message, "refreshedNeuronId"))
                            $root.ic_nns_common.pb.v1.NeuronId.encode(message.refreshedNeuronId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified ClaimOrRefreshResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.IClaimOrRefreshResponse} message ClaimOrRefreshResponse message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ClaimOrRefreshResponse.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ClaimOrRefreshResponse message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse} ClaimOrRefreshResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClaimOrRefreshResponse.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.refreshedNeuronId = $root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ClaimOrRefreshResponse message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse} ClaimOrRefreshResponse
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ClaimOrRefreshResponse.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ClaimOrRefreshResponse message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ClaimOrRefreshResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.refreshedNeuronId != null && message.hasOwnProperty("refreshedNeuronId")) {
                            let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.refreshedNeuronId);
                            if (error)
                                return "refreshedNeuronId." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a ClaimOrRefreshResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse} ClaimOrRefreshResponse
                     */
                    ClaimOrRefreshResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse();
                        if (object.refreshedNeuronId != null) {
                            if (typeof object.refreshedNeuronId !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse.refreshedNeuronId: object expected");
                            message.refreshedNeuronId = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.refreshedNeuronId);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ClaimOrRefreshResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse
                     * @static
                     * @param {ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse} message ClaimOrRefreshResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ClaimOrRefreshResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.refreshedNeuronId = null;
                        if (message.refreshedNeuronId != null && message.hasOwnProperty("refreshedNeuronId"))
                            object.refreshedNeuronId = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.refreshedNeuronId, options);
                        return object;
                    };

                    /**
                     * Converts this ClaimOrRefreshResponse to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.ManageNeuronResponse.ClaimOrRefreshResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ClaimOrRefreshResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ClaimOrRefreshResponse;
                })();

                return ManageNeuronResponse;
            })();

            v1.GovernanceError = (function() {

                /**
                 * Properties of a GovernanceError.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IGovernanceError
                 * @property {ic_nns_governance.pb.v1.GovernanceError.ErrorType|null} [errorType] GovernanceError errorType
                 * @property {string|null} [errorMessage] GovernanceError errorMessage
                 */

                /**
                 * Constructs a new GovernanceError.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a GovernanceError.
                 * @implements IGovernanceError
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IGovernanceError=} [properties] Properties to set
                 */
                function GovernanceError(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GovernanceError errorType.
                 * @member {ic_nns_governance.pb.v1.GovernanceError.ErrorType} errorType
                 * @memberof ic_nns_governance.pb.v1.GovernanceError
                 * @instance
                 */
                GovernanceError.prototype.errorType = 0;

                /**
                 * GovernanceError errorMessage.
                 * @member {string} errorMessage
                 * @memberof ic_nns_governance.pb.v1.GovernanceError
                 * @instance
                 */
                GovernanceError.prototype.errorMessage = "";

                /**
                 * Creates a new GovernanceError instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.GovernanceError
                 * @static
                 * @param {ic_nns_governance.pb.v1.IGovernanceError=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.GovernanceError} GovernanceError instance
                 */
                GovernanceError.create = function create(properties) {
                    return new GovernanceError(properties);
                };

                /**
                 * Encodes the specified GovernanceError message. Does not implicitly {@link ic_nns_governance.pb.v1.GovernanceError.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.GovernanceError
                 * @static
                 * @param {ic_nns_governance.pb.v1.IGovernanceError} message GovernanceError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GovernanceError.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.errorType != null && Object.hasOwnProperty.call(message, "errorType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errorType);
                    if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
                    return writer;
                };

                /**
                 * Encodes the specified GovernanceError message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.GovernanceError.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.GovernanceError
                 * @static
                 * @param {ic_nns_governance.pb.v1.IGovernanceError} message GovernanceError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GovernanceError.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GovernanceError message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.GovernanceError
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.GovernanceError} GovernanceError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GovernanceError.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.GovernanceError();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.errorType = reader.int32();
                            break;
                        case 2:
                            message.errorMessage = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GovernanceError message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.GovernanceError
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.GovernanceError} GovernanceError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GovernanceError.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GovernanceError message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.GovernanceError
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GovernanceError.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.errorType != null && message.hasOwnProperty("errorType"))
                        switch (message.errorType) {
                        default:
                            return "errorType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                            break;
                        }
                    if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                        if (!$util.isString(message.errorMessage))
                            return "errorMessage: string expected";
                    return null;
                };

                /**
                 * Creates a GovernanceError message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.GovernanceError
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.GovernanceError} GovernanceError
                 */
                GovernanceError.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.GovernanceError)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.GovernanceError();
                    switch (object.errorType) {
                    case "ERROR_TYPE_UNSPECIFIED":
                    case 0:
                        message.errorType = 0;
                        break;
                    case "ERROR_TYPE_OK":
                    case 1:
                        message.errorType = 1;
                        break;
                    case "ERROR_TYPE_UNAVAILABLE":
                    case 2:
                        message.errorType = 2;
                        break;
                    case "ERROR_TYPE_NOT_AUTHORIZED":
                    case 3:
                        message.errorType = 3;
                        break;
                    case "ERROR_TYPE_NOT_FOUND":
                    case 4:
                        message.errorType = 4;
                        break;
                    case "ERROR_TYPE_INVALID_COMMAND":
                    case 5:
                        message.errorType = 5;
                        break;
                    case "ERROR_TYPE_REQUIRES_NOT_DISSOLVING":
                    case 6:
                        message.errorType = 6;
                        break;
                    case "ERROR_TYPE_REQUIRES_DISSOLVING":
                    case 7:
                        message.errorType = 7;
                        break;
                    case "ERROR_TYPE_REQUIRES_DISSOLVED":
                    case 8:
                        message.errorType = 8;
                        break;
                    case "ERROR_TYPE_HOT_KEY":
                    case 9:
                        message.errorType = 9;
                        break;
                    case "ERROR_TYPE_RESOURCE_EXHAUSTED":
                    case 10:
                        message.errorType = 10;
                        break;
                    case "ERROR_TYPE_PRECONDITION_FAILED":
                    case 11:
                        message.errorType = 11;
                        break;
                    case "ERROR_TYPE_EXTERNAL":
                    case 12:
                        message.errorType = 12;
                        break;
                    case "ERROR_TYPE_LEDGER_UPDATE_ONGOING":
                    case 13:
                        message.errorType = 13;
                        break;
                    case "ERROR_TYPE_INSUFFICIENT_FUNDS":
                    case 14:
                        message.errorType = 14;
                        break;
                    case "ERROR_TYPE_INVALID_PRINCIPAL":
                    case 15:
                        message.errorType = 15;
                        break;
                    case "ERROR_TYPE_INVALID_PROPOSAL":
                    case 16:
                        message.errorType = 16;
                        break;
                    case "ERROR_TYPE_ALREADY_JOINED_COMMUNITY_FUND":
                    case 17:
                        message.errorType = 17;
                        break;
                    }
                    if (object.errorMessage != null)
                        message.errorMessage = String(object.errorMessage);
                    return message;
                };

                /**
                 * Creates a plain object from a GovernanceError message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.GovernanceError
                 * @static
                 * @param {ic_nns_governance.pb.v1.GovernanceError} message GovernanceError
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GovernanceError.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.errorType = options.enums === String ? "ERROR_TYPE_UNSPECIFIED" : 0;
                        object.errorMessage = "";
                    }
                    if (message.errorType != null && message.hasOwnProperty("errorType"))
                        object.errorType = options.enums === String ? $root.ic_nns_governance.pb.v1.GovernanceError.ErrorType[message.errorType] : message.errorType;
                    if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                        object.errorMessage = message.errorMessage;
                    return object;
                };

                /**
                 * Converts this GovernanceError to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.GovernanceError
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GovernanceError.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * ErrorType enum.
                 * @name ic_nns_governance.pb.v1.GovernanceError.ErrorType
                 * @enum {number}
                 * @property {number} ERROR_TYPE_UNSPECIFIED=0 ERROR_TYPE_UNSPECIFIED value
                 * @property {number} ERROR_TYPE_OK=1 ERROR_TYPE_OK value
                 * @property {number} ERROR_TYPE_UNAVAILABLE=2 ERROR_TYPE_UNAVAILABLE value
                 * @property {number} ERROR_TYPE_NOT_AUTHORIZED=3 ERROR_TYPE_NOT_AUTHORIZED value
                 * @property {number} ERROR_TYPE_NOT_FOUND=4 ERROR_TYPE_NOT_FOUND value
                 * @property {number} ERROR_TYPE_INVALID_COMMAND=5 ERROR_TYPE_INVALID_COMMAND value
                 * @property {number} ERROR_TYPE_REQUIRES_NOT_DISSOLVING=6 ERROR_TYPE_REQUIRES_NOT_DISSOLVING value
                 * @property {number} ERROR_TYPE_REQUIRES_DISSOLVING=7 ERROR_TYPE_REQUIRES_DISSOLVING value
                 * @property {number} ERROR_TYPE_REQUIRES_DISSOLVED=8 ERROR_TYPE_REQUIRES_DISSOLVED value
                 * @property {number} ERROR_TYPE_HOT_KEY=9 ERROR_TYPE_HOT_KEY value
                 * @property {number} ERROR_TYPE_RESOURCE_EXHAUSTED=10 ERROR_TYPE_RESOURCE_EXHAUSTED value
                 * @property {number} ERROR_TYPE_PRECONDITION_FAILED=11 ERROR_TYPE_PRECONDITION_FAILED value
                 * @property {number} ERROR_TYPE_EXTERNAL=12 ERROR_TYPE_EXTERNAL value
                 * @property {number} ERROR_TYPE_LEDGER_UPDATE_ONGOING=13 ERROR_TYPE_LEDGER_UPDATE_ONGOING value
                 * @property {number} ERROR_TYPE_INSUFFICIENT_FUNDS=14 ERROR_TYPE_INSUFFICIENT_FUNDS value
                 * @property {number} ERROR_TYPE_INVALID_PRINCIPAL=15 ERROR_TYPE_INVALID_PRINCIPAL value
                 * @property {number} ERROR_TYPE_INVALID_PROPOSAL=16 ERROR_TYPE_INVALID_PROPOSAL value
                 * @property {number} ERROR_TYPE_ALREADY_JOINED_COMMUNITY_FUND=17 ERROR_TYPE_ALREADY_JOINED_COMMUNITY_FUND value
                 */
                GovernanceError.ErrorType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ERROR_TYPE_UNSPECIFIED"] = 0;
                    values[valuesById[1] = "ERROR_TYPE_OK"] = 1;
                    values[valuesById[2] = "ERROR_TYPE_UNAVAILABLE"] = 2;
                    values[valuesById[3] = "ERROR_TYPE_NOT_AUTHORIZED"] = 3;
                    values[valuesById[4] = "ERROR_TYPE_NOT_FOUND"] = 4;
                    values[valuesById[5] = "ERROR_TYPE_INVALID_COMMAND"] = 5;
                    values[valuesById[6] = "ERROR_TYPE_REQUIRES_NOT_DISSOLVING"] = 6;
                    values[valuesById[7] = "ERROR_TYPE_REQUIRES_DISSOLVING"] = 7;
                    values[valuesById[8] = "ERROR_TYPE_REQUIRES_DISSOLVED"] = 8;
                    values[valuesById[9] = "ERROR_TYPE_HOT_KEY"] = 9;
                    values[valuesById[10] = "ERROR_TYPE_RESOURCE_EXHAUSTED"] = 10;
                    values[valuesById[11] = "ERROR_TYPE_PRECONDITION_FAILED"] = 11;
                    values[valuesById[12] = "ERROR_TYPE_EXTERNAL"] = 12;
                    values[valuesById[13] = "ERROR_TYPE_LEDGER_UPDATE_ONGOING"] = 13;
                    values[valuesById[14] = "ERROR_TYPE_INSUFFICIENT_FUNDS"] = 14;
                    values[valuesById[15] = "ERROR_TYPE_INVALID_PRINCIPAL"] = 15;
                    values[valuesById[16] = "ERROR_TYPE_INVALID_PROPOSAL"] = 16;
                    values[valuesById[17] = "ERROR_TYPE_ALREADY_JOINED_COMMUNITY_FUND"] = 17;
                    return values;
                })();

                return GovernanceError;
            })();

            v1.Ballot = (function() {

                /**
                 * Properties of a Ballot.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IBallot
                 * @property {ic_nns_governance.pb.v1.Vote|null} [vote] Ballot vote
                 * @property {number|Long|null} [votingPower] Ballot votingPower
                 */

                /**
                 * Constructs a new Ballot.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a Ballot.
                 * @implements IBallot
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IBallot=} [properties] Properties to set
                 */
                function Ballot(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Ballot vote.
                 * @member {ic_nns_governance.pb.v1.Vote} vote
                 * @memberof ic_nns_governance.pb.v1.Ballot
                 * @instance
                 */
                Ballot.prototype.vote = 0;

                /**
                 * Ballot votingPower.
                 * @member {number|Long} votingPower
                 * @memberof ic_nns_governance.pb.v1.Ballot
                 * @instance
                 */
                Ballot.prototype.votingPower = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new Ballot instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.Ballot
                 * @static
                 * @param {ic_nns_governance.pb.v1.IBallot=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.Ballot} Ballot instance
                 */
                Ballot.create = function create(properties) {
                    return new Ballot(properties);
                };

                /**
                 * Encodes the specified Ballot message. Does not implicitly {@link ic_nns_governance.pb.v1.Ballot.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.Ballot
                 * @static
                 * @param {ic_nns_governance.pb.v1.IBallot} message Ballot message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ballot.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.vote != null && Object.hasOwnProperty.call(message, "vote"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.vote);
                    if (message.votingPower != null && Object.hasOwnProperty.call(message, "votingPower"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.votingPower);
                    return writer;
                };

                /**
                 * Encodes the specified Ballot message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.Ballot.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Ballot
                 * @static
                 * @param {ic_nns_governance.pb.v1.IBallot} message Ballot message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ballot.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Ballot message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.Ballot
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.Ballot} Ballot
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ballot.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.Ballot();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.vote = reader.int32();
                            break;
                        case 2:
                            message.votingPower = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Ballot message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Ballot
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.Ballot} Ballot
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ballot.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Ballot message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.Ballot
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Ballot.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vote != null && message.hasOwnProperty("vote"))
                        switch (message.vote) {
                        default:
                            return "vote: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.votingPower != null && message.hasOwnProperty("votingPower"))
                        if (!$util.isInteger(message.votingPower) && !(message.votingPower && $util.isInteger(message.votingPower.low) && $util.isInteger(message.votingPower.high)))
                            return "votingPower: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a Ballot message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.Ballot
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.Ballot} Ballot
                 */
                Ballot.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.Ballot)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.Ballot();
                    switch (object.vote) {
                    case "VOTE_UNSPECIFIED":
                    case 0:
                        message.vote = 0;
                        break;
                    case "VOTE_YES":
                    case 1:
                        message.vote = 1;
                        break;
                    case "VOTE_NO":
                    case 2:
                        message.vote = 2;
                        break;
                    }
                    if (object.votingPower != null)
                        if ($util.Long)
                            (message.votingPower = $util.Long.fromValue(object.votingPower)).unsigned = true;
                        else if (typeof object.votingPower === "string")
                            message.votingPower = parseInt(object.votingPower, 10);
                        else if (typeof object.votingPower === "number")
                            message.votingPower = object.votingPower;
                        else if (typeof object.votingPower === "object")
                            message.votingPower = new $util.LongBits(object.votingPower.low >>> 0, object.votingPower.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a Ballot message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.Ballot
                 * @static
                 * @param {ic_nns_governance.pb.v1.Ballot} message Ballot
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Ballot.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.vote = options.enums === String ? "VOTE_UNSPECIFIED" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.votingPower = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.votingPower = options.longs === String ? "0" : 0;
                    }
                    if (message.vote != null && message.hasOwnProperty("vote"))
                        object.vote = options.enums === String ? $root.ic_nns_governance.pb.v1.Vote[message.vote] : message.vote;
                    if (message.votingPower != null && message.hasOwnProperty("votingPower"))
                        if (typeof message.votingPower === "number")
                            object.votingPower = options.longs === String ? String(message.votingPower) : message.votingPower;
                        else
                            object.votingPower = options.longs === String ? $util.Long.prototype.toString.call(message.votingPower) : options.longs === Number ? new $util.LongBits(message.votingPower.low >>> 0, message.votingPower.high >>> 0).toNumber(true) : message.votingPower;
                    return object;
                };

                /**
                 * Converts this Ballot to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.Ballot
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Ballot.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Ballot;
            })();

            /**
             * ProposalStatus enum.
             * @name ic_nns_governance.pb.v1.ProposalStatus
             * @enum {number}
             * @property {number} PROPOSAL_STATUS_UNSPECIFIED=0 PROPOSAL_STATUS_UNSPECIFIED value
             * @property {number} PROPOSAL_STATUS_OPEN=1 PROPOSAL_STATUS_OPEN value
             * @property {number} PROPOSAL_STATUS_REJECTED=2 PROPOSAL_STATUS_REJECTED value
             * @property {number} PROPOSAL_STATUS_ADOPTED=3 PROPOSAL_STATUS_ADOPTED value
             * @property {number} PROPOSAL_STATUS_EXECUTED=4 PROPOSAL_STATUS_EXECUTED value
             * @property {number} PROPOSAL_STATUS_FAILED=5 PROPOSAL_STATUS_FAILED value
             */
            v1.ProposalStatus = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "PROPOSAL_STATUS_UNSPECIFIED"] = 0;
                values[valuesById[1] = "PROPOSAL_STATUS_OPEN"] = 1;
                values[valuesById[2] = "PROPOSAL_STATUS_REJECTED"] = 2;
                values[valuesById[3] = "PROPOSAL_STATUS_ADOPTED"] = 3;
                values[valuesById[4] = "PROPOSAL_STATUS_EXECUTED"] = 4;
                values[valuesById[5] = "PROPOSAL_STATUS_FAILED"] = 5;
                return values;
            })();

            /**
             * ProposalRewardStatus enum.
             * @name ic_nns_governance.pb.v1.ProposalRewardStatus
             * @enum {number}
             * @property {number} PROPOSAL_REWARD_STATUS_UNSPECIFIED=0 PROPOSAL_REWARD_STATUS_UNSPECIFIED value
             * @property {number} PROPOSAL_REWARD_STATUS_ACCEPT_VOTES=1 PROPOSAL_REWARD_STATUS_ACCEPT_VOTES value
             * @property {number} PROPOSAL_REWARD_STATUS_READY_TO_SETTLE=2 PROPOSAL_REWARD_STATUS_READY_TO_SETTLE value
             * @property {number} PROPOSAL_REWARD_STATUS_SETTLED=3 PROPOSAL_REWARD_STATUS_SETTLED value
             * @property {number} PROPOSAL_REWARD_STATUS_INELIGIBLE=4 PROPOSAL_REWARD_STATUS_INELIGIBLE value
             */
            v1.ProposalRewardStatus = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "PROPOSAL_REWARD_STATUS_UNSPECIFIED"] = 0;
                values[valuesById[1] = "PROPOSAL_REWARD_STATUS_ACCEPT_VOTES"] = 1;
                values[valuesById[2] = "PROPOSAL_REWARD_STATUS_READY_TO_SETTLE"] = 2;
                values[valuesById[3] = "PROPOSAL_REWARD_STATUS_SETTLED"] = 3;
                values[valuesById[4] = "PROPOSAL_REWARD_STATUS_INELIGIBLE"] = 4;
                return values;
            })();

            v1.Tally = (function() {

                /**
                 * Properties of a Tally.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface ITally
                 * @property {number|Long|null} [timestampSeconds] Tally timestampSeconds
                 * @property {number|Long|null} [yes] Tally yes
                 * @property {number|Long|null} [no] Tally no
                 * @property {number|Long|null} [total] Tally total
                 */

                /**
                 * Constructs a new Tally.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a Tally.
                 * @implements ITally
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.ITally=} [properties] Properties to set
                 */
                function Tally(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Tally timestampSeconds.
                 * @member {number|Long} timestampSeconds
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @instance
                 */
                Tally.prototype.timestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Tally yes.
                 * @member {number|Long} yes
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @instance
                 */
                Tally.prototype.yes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Tally no.
                 * @member {number|Long} no
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @instance
                 */
                Tally.prototype.no = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Tally total.
                 * @member {number|Long} total
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @instance
                 */
                Tally.prototype.total = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new Tally instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @static
                 * @param {ic_nns_governance.pb.v1.ITally=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.Tally} Tally instance
                 */
                Tally.create = function create(properties) {
                    return new Tally(properties);
                };

                /**
                 * Encodes the specified Tally message. Does not implicitly {@link ic_nns_governance.pb.v1.Tally.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @static
                 * @param {ic_nns_governance.pb.v1.ITally} message Tally message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Tally.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestampSeconds != null && Object.hasOwnProperty.call(message, "timestampSeconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestampSeconds);
                    if (message.yes != null && Object.hasOwnProperty.call(message, "yes"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.yes);
                    if (message.no != null && Object.hasOwnProperty.call(message, "no"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.no);
                    if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.total);
                    return writer;
                };

                /**
                 * Encodes the specified Tally message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.Tally.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @static
                 * @param {ic_nns_governance.pb.v1.ITally} message Tally message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Tally.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Tally message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.Tally} Tally
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Tally.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.Tally();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestampSeconds = reader.uint64();
                            break;
                        case 2:
                            message.yes = reader.uint64();
                            break;
                        case 3:
                            message.no = reader.uint64();
                            break;
                        case 4:
                            message.total = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Tally message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.Tally} Tally
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Tally.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Tally message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Tally.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestampSeconds != null && message.hasOwnProperty("timestampSeconds"))
                        if (!$util.isInteger(message.timestampSeconds) && !(message.timestampSeconds && $util.isInteger(message.timestampSeconds.low) && $util.isInteger(message.timestampSeconds.high)))
                            return "timestampSeconds: integer|Long expected";
                    if (message.yes != null && message.hasOwnProperty("yes"))
                        if (!$util.isInteger(message.yes) && !(message.yes && $util.isInteger(message.yes.low) && $util.isInteger(message.yes.high)))
                            return "yes: integer|Long expected";
                    if (message.no != null && message.hasOwnProperty("no"))
                        if (!$util.isInteger(message.no) && !(message.no && $util.isInteger(message.no.low) && $util.isInteger(message.no.high)))
                            return "no: integer|Long expected";
                    if (message.total != null && message.hasOwnProperty("total"))
                        if (!$util.isInteger(message.total) && !(message.total && $util.isInteger(message.total.low) && $util.isInteger(message.total.high)))
                            return "total: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a Tally message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.Tally} Tally
                 */
                Tally.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.Tally)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.Tally();
                    if (object.timestampSeconds != null)
                        if ($util.Long)
                            (message.timestampSeconds = $util.Long.fromValue(object.timestampSeconds)).unsigned = true;
                        else if (typeof object.timestampSeconds === "string")
                            message.timestampSeconds = parseInt(object.timestampSeconds, 10);
                        else if (typeof object.timestampSeconds === "number")
                            message.timestampSeconds = object.timestampSeconds;
                        else if (typeof object.timestampSeconds === "object")
                            message.timestampSeconds = new $util.LongBits(object.timestampSeconds.low >>> 0, object.timestampSeconds.high >>> 0).toNumber(true);
                    if (object.yes != null)
                        if ($util.Long)
                            (message.yes = $util.Long.fromValue(object.yes)).unsigned = true;
                        else if (typeof object.yes === "string")
                            message.yes = parseInt(object.yes, 10);
                        else if (typeof object.yes === "number")
                            message.yes = object.yes;
                        else if (typeof object.yes === "object")
                            message.yes = new $util.LongBits(object.yes.low >>> 0, object.yes.high >>> 0).toNumber(true);
                    if (object.no != null)
                        if ($util.Long)
                            (message.no = $util.Long.fromValue(object.no)).unsigned = true;
                        else if (typeof object.no === "string")
                            message.no = parseInt(object.no, 10);
                        else if (typeof object.no === "number")
                            message.no = object.no;
                        else if (typeof object.no === "object")
                            message.no = new $util.LongBits(object.no.low >>> 0, object.no.high >>> 0).toNumber(true);
                    if (object.total != null)
                        if ($util.Long)
                            (message.total = $util.Long.fromValue(object.total)).unsigned = true;
                        else if (typeof object.total === "string")
                            message.total = parseInt(object.total, 10);
                        else if (typeof object.total === "number")
                            message.total = object.total;
                        else if (typeof object.total === "object")
                            message.total = new $util.LongBits(object.total.low >>> 0, object.total.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a Tally message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @static
                 * @param {ic_nns_governance.pb.v1.Tally} message Tally
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Tally.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.timestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestampSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.yes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.yes = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.no = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.no = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.total = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.total = options.longs === String ? "0" : 0;
                    }
                    if (message.timestampSeconds != null && message.hasOwnProperty("timestampSeconds"))
                        if (typeof message.timestampSeconds === "number")
                            object.timestampSeconds = options.longs === String ? String(message.timestampSeconds) : message.timestampSeconds;
                        else
                            object.timestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.timestampSeconds) : options.longs === Number ? new $util.LongBits(message.timestampSeconds.low >>> 0, message.timestampSeconds.high >>> 0).toNumber(true) : message.timestampSeconds;
                    if (message.yes != null && message.hasOwnProperty("yes"))
                        if (typeof message.yes === "number")
                            object.yes = options.longs === String ? String(message.yes) : message.yes;
                        else
                            object.yes = options.longs === String ? $util.Long.prototype.toString.call(message.yes) : options.longs === Number ? new $util.LongBits(message.yes.low >>> 0, message.yes.high >>> 0).toNumber(true) : message.yes;
                    if (message.no != null && message.hasOwnProperty("no"))
                        if (typeof message.no === "number")
                            object.no = options.longs === String ? String(message.no) : message.no;
                        else
                            object.no = options.longs === String ? $util.Long.prototype.toString.call(message.no) : options.longs === Number ? new $util.LongBits(message.no.low >>> 0, message.no.high >>> 0).toNumber(true) : message.no;
                    if (message.total != null && message.hasOwnProperty("total"))
                        if (typeof message.total === "number")
                            object.total = options.longs === String ? String(message.total) : message.total;
                        else
                            object.total = options.longs === String ? $util.Long.prototype.toString.call(message.total) : options.longs === Number ? new $util.LongBits(message.total.low >>> 0, message.total.high >>> 0).toNumber(true) : message.total;
                    return object;
                };

                /**
                 * Converts this Tally to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.Tally
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Tally.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Tally;
            })();

            v1.ProposalData = (function() {

                /**
                 * Properties of a ProposalData.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IProposalData
                 * @property {ic_nns_common.pb.v1.IProposalId|null} [id] ProposalData id
                 * @property {ic_nns_common.pb.v1.INeuronId|null} [proposer] ProposalData proposer
                 * @property {number|Long|null} [rejectCostE8s] ProposalData rejectCostE8s
                 * @property {ic_nns_governance.pb.v1.IProposal|null} [proposal] ProposalData proposal
                 * @property {number|Long|null} [proposalTimestampSeconds] ProposalData proposalTimestampSeconds
                 * @property {Object.<string,ic_nns_governance.pb.v1.IBallot>|null} [ballots] ProposalData ballots
                 * @property {ic_nns_governance.pb.v1.ITally|null} [latestTally] ProposalData latestTally
                 * @property {number|Long|null} [decidedTimestampSeconds] ProposalData decidedTimestampSeconds
                 * @property {number|Long|null} [executedTimestampSeconds] ProposalData executedTimestampSeconds
                 * @property {number|Long|null} [failedTimestampSeconds] ProposalData failedTimestampSeconds
                 * @property {ic_nns_governance.pb.v1.IGovernanceError|null} [failureReason] ProposalData failureReason
                 * @property {number|Long|null} [rewardEventRound] ProposalData rewardEventRound
                 * @property {ic_nns_governance.pb.v1.IWaitForQuietState|null} [waitForQuietState] ProposalData waitForQuietState
                 */

                /**
                 * Constructs a new ProposalData.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a ProposalData.
                 * @implements IProposalData
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IProposalData=} [properties] Properties to set
                 */
                function ProposalData(properties) {
                    this.ballots = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ProposalData id.
                 * @member {ic_nns_common.pb.v1.IProposalId|null|undefined} id
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.id = null;

                /**
                 * ProposalData proposer.
                 * @member {ic_nns_common.pb.v1.INeuronId|null|undefined} proposer
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.proposer = null;

                /**
                 * ProposalData rejectCostE8s.
                 * @member {number|Long} rejectCostE8s
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.rejectCostE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalData proposal.
                 * @member {ic_nns_governance.pb.v1.IProposal|null|undefined} proposal
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.proposal = null;

                /**
                 * ProposalData proposalTimestampSeconds.
                 * @member {number|Long} proposalTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.proposalTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalData ballots.
                 * @member {Object.<string,ic_nns_governance.pb.v1.IBallot>} ballots
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.ballots = $util.emptyObject;

                /**
                 * ProposalData latestTally.
                 * @member {ic_nns_governance.pb.v1.ITally|null|undefined} latestTally
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.latestTally = null;

                /**
                 * ProposalData decidedTimestampSeconds.
                 * @member {number|Long} decidedTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.decidedTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalData executedTimestampSeconds.
                 * @member {number|Long} executedTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.executedTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalData failedTimestampSeconds.
                 * @member {number|Long} failedTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.failedTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalData failureReason.
                 * @member {ic_nns_governance.pb.v1.IGovernanceError|null|undefined} failureReason
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.failureReason = null;

                /**
                 * ProposalData rewardEventRound.
                 * @member {number|Long} rewardEventRound
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.rewardEventRound = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalData waitForQuietState.
                 * @member {ic_nns_governance.pb.v1.IWaitForQuietState|null|undefined} waitForQuietState
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 */
                ProposalData.prototype.waitForQuietState = null;

                /**
                 * Creates a new ProposalData instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @static
                 * @param {ic_nns_governance.pb.v1.IProposalData=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ProposalData} ProposalData instance
                 */
                ProposalData.create = function create(properties) {
                    return new ProposalData(properties);
                };

                /**
                 * Encodes the specified ProposalData message. Does not implicitly {@link ic_nns_governance.pb.v1.ProposalData.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @static
                 * @param {ic_nns_governance.pb.v1.IProposalData} message ProposalData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProposalData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        $root.ic_nns_common.pb.v1.ProposalId.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.proposer != null && Object.hasOwnProperty.call(message, "proposer"))
                        $root.ic_nns_common.pb.v1.NeuronId.encode(message.proposer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.rejectCostE8s != null && Object.hasOwnProperty.call(message, "rejectCostE8s"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.rejectCostE8s);
                    if (message.proposal != null && Object.hasOwnProperty.call(message, "proposal"))
                        $root.ic_nns_governance.pb.v1.Proposal.encode(message.proposal, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.proposalTimestampSeconds != null && Object.hasOwnProperty.call(message, "proposalTimestampSeconds"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.proposalTimestampSeconds);
                    if (message.ballots != null && Object.hasOwnProperty.call(message, "ballots"))
                        for (let keys = Object.keys(message.ballots), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 1 =*/9).fixed64(keys[i]);
                            $root.ic_nns_governance.pb.v1.Ballot.encode(message.ballots[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.latestTally != null && Object.hasOwnProperty.call(message, "latestTally"))
                        $root.ic_nns_governance.pb.v1.Tally.encode(message.latestTally, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.decidedTimestampSeconds != null && Object.hasOwnProperty.call(message, "decidedTimestampSeconds"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.decidedTimestampSeconds);
                    if (message.executedTimestampSeconds != null && Object.hasOwnProperty.call(message, "executedTimestampSeconds"))
                        writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.executedTimestampSeconds);
                    if (message.failedTimestampSeconds != null && Object.hasOwnProperty.call(message, "failedTimestampSeconds"))
                        writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.failedTimestampSeconds);
                    if (message.rewardEventRound != null && Object.hasOwnProperty.call(message, "rewardEventRound"))
                        writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.rewardEventRound);
                    if (message.failureReason != null && Object.hasOwnProperty.call(message, "failureReason"))
                        $root.ic_nns_governance.pb.v1.GovernanceError.encode(message.failureReason, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.waitForQuietState != null && Object.hasOwnProperty.call(message, "waitForQuietState"))
                        $root.ic_nns_governance.pb.v1.WaitForQuietState.encode(message.waitForQuietState, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ProposalData message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ProposalData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @static
                 * @param {ic_nns_governance.pb.v1.IProposalData} message ProposalData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProposalData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ProposalData message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ProposalData} ProposalData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProposalData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ProposalData(), key, value;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.ic_nns_common.pb.v1.ProposalId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.proposer = $root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.rejectCostE8s = reader.uint64();
                            break;
                        case 4:
                            message.proposal = $root.ic_nns_governance.pb.v1.Proposal.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.proposalTimestampSeconds = reader.uint64();
                            break;
                        case 6:
                            if (message.ballots === $util.emptyObject)
                                message.ballots = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.fixed64();
                                    break;
                                case 2:
                                    value = $root.ic_nns_governance.pb.v1.Ballot.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.ballots[typeof key === "object" ? $util.longToHash(key) : key] = value;
                            break;
                        case 7:
                            message.latestTally = $root.ic_nns_governance.pb.v1.Tally.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.decidedTimestampSeconds = reader.uint64();
                            break;
                        case 12:
                            message.executedTimestampSeconds = reader.uint64();
                            break;
                        case 13:
                            message.failedTimestampSeconds = reader.uint64();
                            break;
                        case 15:
                            message.failureReason = $root.ic_nns_governance.pb.v1.GovernanceError.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.rewardEventRound = reader.uint64();
                            break;
                        case 16:
                            message.waitForQuietState = $root.ic_nns_governance.pb.v1.WaitForQuietState.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ProposalData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ProposalData} ProposalData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProposalData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ProposalData message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProposalData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id")) {
                        let error = $root.ic_nns_common.pb.v1.ProposalId.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.proposer != null && message.hasOwnProperty("proposer")) {
                        let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.proposer);
                        if (error)
                            return "proposer." + error;
                    }
                    if (message.rejectCostE8s != null && message.hasOwnProperty("rejectCostE8s"))
                        if (!$util.isInteger(message.rejectCostE8s) && !(message.rejectCostE8s && $util.isInteger(message.rejectCostE8s.low) && $util.isInteger(message.rejectCostE8s.high)))
                            return "rejectCostE8s: integer|Long expected";
                    if (message.proposal != null && message.hasOwnProperty("proposal")) {
                        let error = $root.ic_nns_governance.pb.v1.Proposal.verify(message.proposal);
                        if (error)
                            return "proposal." + error;
                    }
                    if (message.proposalTimestampSeconds != null && message.hasOwnProperty("proposalTimestampSeconds"))
                        if (!$util.isInteger(message.proposalTimestampSeconds) && !(message.proposalTimestampSeconds && $util.isInteger(message.proposalTimestampSeconds.low) && $util.isInteger(message.proposalTimestampSeconds.high)))
                            return "proposalTimestampSeconds: integer|Long expected";
                    if (message.ballots != null && message.hasOwnProperty("ballots")) {
                        if (!$util.isObject(message.ballots))
                            return "ballots: object expected";
                        let key = Object.keys(message.ballots);
                        for (let i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "ballots: integer|Long key{k:fixed64} expected";
                            {
                                let error = $root.ic_nns_governance.pb.v1.Ballot.verify(message.ballots[key[i]]);
                                if (error)
                                    return "ballots." + error;
                            }
                        }
                    }
                    if (message.latestTally != null && message.hasOwnProperty("latestTally")) {
                        let error = $root.ic_nns_governance.pb.v1.Tally.verify(message.latestTally);
                        if (error)
                            return "latestTally." + error;
                    }
                    if (message.decidedTimestampSeconds != null && message.hasOwnProperty("decidedTimestampSeconds"))
                        if (!$util.isInteger(message.decidedTimestampSeconds) && !(message.decidedTimestampSeconds && $util.isInteger(message.decidedTimestampSeconds.low) && $util.isInteger(message.decidedTimestampSeconds.high)))
                            return "decidedTimestampSeconds: integer|Long expected";
                    if (message.executedTimestampSeconds != null && message.hasOwnProperty("executedTimestampSeconds"))
                        if (!$util.isInteger(message.executedTimestampSeconds) && !(message.executedTimestampSeconds && $util.isInteger(message.executedTimestampSeconds.low) && $util.isInteger(message.executedTimestampSeconds.high)))
                            return "executedTimestampSeconds: integer|Long expected";
                    if (message.failedTimestampSeconds != null && message.hasOwnProperty("failedTimestampSeconds"))
                        if (!$util.isInteger(message.failedTimestampSeconds) && !(message.failedTimestampSeconds && $util.isInteger(message.failedTimestampSeconds.low) && $util.isInteger(message.failedTimestampSeconds.high)))
                            return "failedTimestampSeconds: integer|Long expected";
                    if (message.failureReason != null && message.hasOwnProperty("failureReason")) {
                        let error = $root.ic_nns_governance.pb.v1.GovernanceError.verify(message.failureReason);
                        if (error)
                            return "failureReason." + error;
                    }
                    if (message.rewardEventRound != null && message.hasOwnProperty("rewardEventRound"))
                        if (!$util.isInteger(message.rewardEventRound) && !(message.rewardEventRound && $util.isInteger(message.rewardEventRound.low) && $util.isInteger(message.rewardEventRound.high)))
                            return "rewardEventRound: integer|Long expected";
                    if (message.waitForQuietState != null && message.hasOwnProperty("waitForQuietState")) {
                        let error = $root.ic_nns_governance.pb.v1.WaitForQuietState.verify(message.waitForQuietState);
                        if (error)
                            return "waitForQuietState." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ProposalData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ProposalData} ProposalData
                 */
                ProposalData.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ProposalData)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ProposalData();
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalData.id: object expected");
                        message.id = $root.ic_nns_common.pb.v1.ProposalId.fromObject(object.id);
                    }
                    if (object.proposer != null) {
                        if (typeof object.proposer !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalData.proposer: object expected");
                        message.proposer = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.proposer);
                    }
                    if (object.rejectCostE8s != null)
                        if ($util.Long)
                            (message.rejectCostE8s = $util.Long.fromValue(object.rejectCostE8s)).unsigned = true;
                        else if (typeof object.rejectCostE8s === "string")
                            message.rejectCostE8s = parseInt(object.rejectCostE8s, 10);
                        else if (typeof object.rejectCostE8s === "number")
                            message.rejectCostE8s = object.rejectCostE8s;
                        else if (typeof object.rejectCostE8s === "object")
                            message.rejectCostE8s = new $util.LongBits(object.rejectCostE8s.low >>> 0, object.rejectCostE8s.high >>> 0).toNumber(true);
                    if (object.proposal != null) {
                        if (typeof object.proposal !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalData.proposal: object expected");
                        message.proposal = $root.ic_nns_governance.pb.v1.Proposal.fromObject(object.proposal);
                    }
                    if (object.proposalTimestampSeconds != null)
                        if ($util.Long)
                            (message.proposalTimestampSeconds = $util.Long.fromValue(object.proposalTimestampSeconds)).unsigned = true;
                        else if (typeof object.proposalTimestampSeconds === "string")
                            message.proposalTimestampSeconds = parseInt(object.proposalTimestampSeconds, 10);
                        else if (typeof object.proposalTimestampSeconds === "number")
                            message.proposalTimestampSeconds = object.proposalTimestampSeconds;
                        else if (typeof object.proposalTimestampSeconds === "object")
                            message.proposalTimestampSeconds = new $util.LongBits(object.proposalTimestampSeconds.low >>> 0, object.proposalTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.ballots) {
                        if (typeof object.ballots !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalData.ballots: object expected");
                        message.ballots = {};
                        for (let keys = Object.keys(object.ballots), i = 0; i < keys.length; ++i) {
                            if (typeof object.ballots[keys[i]] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ProposalData.ballots: object expected");
                            message.ballots[keys[i]] = $root.ic_nns_governance.pb.v1.Ballot.fromObject(object.ballots[keys[i]]);
                        }
                    }
                    if (object.latestTally != null) {
                        if (typeof object.latestTally !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalData.latestTally: object expected");
                        message.latestTally = $root.ic_nns_governance.pb.v1.Tally.fromObject(object.latestTally);
                    }
                    if (object.decidedTimestampSeconds != null)
                        if ($util.Long)
                            (message.decidedTimestampSeconds = $util.Long.fromValue(object.decidedTimestampSeconds)).unsigned = true;
                        else if (typeof object.decidedTimestampSeconds === "string")
                            message.decidedTimestampSeconds = parseInt(object.decidedTimestampSeconds, 10);
                        else if (typeof object.decidedTimestampSeconds === "number")
                            message.decidedTimestampSeconds = object.decidedTimestampSeconds;
                        else if (typeof object.decidedTimestampSeconds === "object")
                            message.decidedTimestampSeconds = new $util.LongBits(object.decidedTimestampSeconds.low >>> 0, object.decidedTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.executedTimestampSeconds != null)
                        if ($util.Long)
                            (message.executedTimestampSeconds = $util.Long.fromValue(object.executedTimestampSeconds)).unsigned = true;
                        else if (typeof object.executedTimestampSeconds === "string")
                            message.executedTimestampSeconds = parseInt(object.executedTimestampSeconds, 10);
                        else if (typeof object.executedTimestampSeconds === "number")
                            message.executedTimestampSeconds = object.executedTimestampSeconds;
                        else if (typeof object.executedTimestampSeconds === "object")
                            message.executedTimestampSeconds = new $util.LongBits(object.executedTimestampSeconds.low >>> 0, object.executedTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.failedTimestampSeconds != null)
                        if ($util.Long)
                            (message.failedTimestampSeconds = $util.Long.fromValue(object.failedTimestampSeconds)).unsigned = true;
                        else if (typeof object.failedTimestampSeconds === "string")
                            message.failedTimestampSeconds = parseInt(object.failedTimestampSeconds, 10);
                        else if (typeof object.failedTimestampSeconds === "number")
                            message.failedTimestampSeconds = object.failedTimestampSeconds;
                        else if (typeof object.failedTimestampSeconds === "object")
                            message.failedTimestampSeconds = new $util.LongBits(object.failedTimestampSeconds.low >>> 0, object.failedTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.failureReason != null) {
                        if (typeof object.failureReason !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalData.failureReason: object expected");
                        message.failureReason = $root.ic_nns_governance.pb.v1.GovernanceError.fromObject(object.failureReason);
                    }
                    if (object.rewardEventRound != null)
                        if ($util.Long)
                            (message.rewardEventRound = $util.Long.fromValue(object.rewardEventRound)).unsigned = true;
                        else if (typeof object.rewardEventRound === "string")
                            message.rewardEventRound = parseInt(object.rewardEventRound, 10);
                        else if (typeof object.rewardEventRound === "number")
                            message.rewardEventRound = object.rewardEventRound;
                        else if (typeof object.rewardEventRound === "object")
                            message.rewardEventRound = new $util.LongBits(object.rewardEventRound.low >>> 0, object.rewardEventRound.high >>> 0).toNumber(true);
                    if (object.waitForQuietState != null) {
                        if (typeof object.waitForQuietState !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalData.waitForQuietState: object expected");
                        message.waitForQuietState = $root.ic_nns_governance.pb.v1.WaitForQuietState.fromObject(object.waitForQuietState);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ProposalData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @static
                 * @param {ic_nns_governance.pb.v1.ProposalData} message ProposalData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProposalData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.ballots = {};
                    if (options.defaults) {
                        object.id = null;
                        object.proposer = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.rejectCostE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rejectCostE8s = options.longs === String ? "0" : 0;
                        object.proposal = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.proposalTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.proposalTimestampSeconds = options.longs === String ? "0" : 0;
                        object.latestTally = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.decidedTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.decidedTimestampSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.executedTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.executedTimestampSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.failedTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.failedTimestampSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.rewardEventRound = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rewardEventRound = options.longs === String ? "0" : 0;
                        object.failureReason = null;
                        object.waitForQuietState = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.ic_nns_common.pb.v1.ProposalId.toObject(message.id, options);
                    if (message.proposer != null && message.hasOwnProperty("proposer"))
                        object.proposer = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.proposer, options);
                    if (message.rejectCostE8s != null && message.hasOwnProperty("rejectCostE8s"))
                        if (typeof message.rejectCostE8s === "number")
                            object.rejectCostE8s = options.longs === String ? String(message.rejectCostE8s) : message.rejectCostE8s;
                        else
                            object.rejectCostE8s = options.longs === String ? $util.Long.prototype.toString.call(message.rejectCostE8s) : options.longs === Number ? new $util.LongBits(message.rejectCostE8s.low >>> 0, message.rejectCostE8s.high >>> 0).toNumber(true) : message.rejectCostE8s;
                    if (message.proposal != null && message.hasOwnProperty("proposal"))
                        object.proposal = $root.ic_nns_governance.pb.v1.Proposal.toObject(message.proposal, options);
                    if (message.proposalTimestampSeconds != null && message.hasOwnProperty("proposalTimestampSeconds"))
                        if (typeof message.proposalTimestampSeconds === "number")
                            object.proposalTimestampSeconds = options.longs === String ? String(message.proposalTimestampSeconds) : message.proposalTimestampSeconds;
                        else
                            object.proposalTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.proposalTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.proposalTimestampSeconds.low >>> 0, message.proposalTimestampSeconds.high >>> 0).toNumber(true) : message.proposalTimestampSeconds;
                    let keys2;
                    if (message.ballots && (keys2 = Object.keys(message.ballots)).length) {
                        object.ballots = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.ballots[keys2[j]] = $root.ic_nns_governance.pb.v1.Ballot.toObject(message.ballots[keys2[j]], options);
                    }
                    if (message.latestTally != null && message.hasOwnProperty("latestTally"))
                        object.latestTally = $root.ic_nns_governance.pb.v1.Tally.toObject(message.latestTally, options);
                    if (message.decidedTimestampSeconds != null && message.hasOwnProperty("decidedTimestampSeconds"))
                        if (typeof message.decidedTimestampSeconds === "number")
                            object.decidedTimestampSeconds = options.longs === String ? String(message.decidedTimestampSeconds) : message.decidedTimestampSeconds;
                        else
                            object.decidedTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.decidedTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.decidedTimestampSeconds.low >>> 0, message.decidedTimestampSeconds.high >>> 0).toNumber(true) : message.decidedTimestampSeconds;
                    if (message.executedTimestampSeconds != null && message.hasOwnProperty("executedTimestampSeconds"))
                        if (typeof message.executedTimestampSeconds === "number")
                            object.executedTimestampSeconds = options.longs === String ? String(message.executedTimestampSeconds) : message.executedTimestampSeconds;
                        else
                            object.executedTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.executedTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.executedTimestampSeconds.low >>> 0, message.executedTimestampSeconds.high >>> 0).toNumber(true) : message.executedTimestampSeconds;
                    if (message.failedTimestampSeconds != null && message.hasOwnProperty("failedTimestampSeconds"))
                        if (typeof message.failedTimestampSeconds === "number")
                            object.failedTimestampSeconds = options.longs === String ? String(message.failedTimestampSeconds) : message.failedTimestampSeconds;
                        else
                            object.failedTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.failedTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.failedTimestampSeconds.low >>> 0, message.failedTimestampSeconds.high >>> 0).toNumber(true) : message.failedTimestampSeconds;
                    if (message.rewardEventRound != null && message.hasOwnProperty("rewardEventRound"))
                        if (typeof message.rewardEventRound === "number")
                            object.rewardEventRound = options.longs === String ? String(message.rewardEventRound) : message.rewardEventRound;
                        else
                            object.rewardEventRound = options.longs === String ? $util.Long.prototype.toString.call(message.rewardEventRound) : options.longs === Number ? new $util.LongBits(message.rewardEventRound.low >>> 0, message.rewardEventRound.high >>> 0).toNumber(true) : message.rewardEventRound;
                    if (message.failureReason != null && message.hasOwnProperty("failureReason"))
                        object.failureReason = $root.ic_nns_governance.pb.v1.GovernanceError.toObject(message.failureReason, options);
                    if (message.waitForQuietState != null && message.hasOwnProperty("waitForQuietState"))
                        object.waitForQuietState = $root.ic_nns_governance.pb.v1.WaitForQuietState.toObject(message.waitForQuietState, options);
                    return object;
                };

                /**
                 * Converts this ProposalData to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ProposalData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProposalData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ProposalData;
            })();

            v1.WaitForQuietState = (function() {

                /**
                 * Properties of a WaitForQuietState.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IWaitForQuietState
                 * @property {number|Long|null} [currentDeadlineTimestampSeconds] WaitForQuietState currentDeadlineTimestampSeconds
                 */

                /**
                 * Constructs a new WaitForQuietState.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a WaitForQuietState.
                 * @implements IWaitForQuietState
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IWaitForQuietState=} [properties] Properties to set
                 */
                function WaitForQuietState(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * WaitForQuietState currentDeadlineTimestampSeconds.
                 * @member {number|Long} currentDeadlineTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.WaitForQuietState
                 * @instance
                 */
                WaitForQuietState.prototype.currentDeadlineTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new WaitForQuietState instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.WaitForQuietState
                 * @static
                 * @param {ic_nns_governance.pb.v1.IWaitForQuietState=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.WaitForQuietState} WaitForQuietState instance
                 */
                WaitForQuietState.create = function create(properties) {
                    return new WaitForQuietState(properties);
                };

                /**
                 * Encodes the specified WaitForQuietState message. Does not implicitly {@link ic_nns_governance.pb.v1.WaitForQuietState.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.WaitForQuietState
                 * @static
                 * @param {ic_nns_governance.pb.v1.IWaitForQuietState} message WaitForQuietState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WaitForQuietState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.currentDeadlineTimestampSeconds != null && Object.hasOwnProperty.call(message, "currentDeadlineTimestampSeconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.currentDeadlineTimestampSeconds);
                    return writer;
                };

                /**
                 * Encodes the specified WaitForQuietState message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.WaitForQuietState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.WaitForQuietState
                 * @static
                 * @param {ic_nns_governance.pb.v1.IWaitForQuietState} message WaitForQuietState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WaitForQuietState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a WaitForQuietState message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.WaitForQuietState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.WaitForQuietState} WaitForQuietState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WaitForQuietState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.WaitForQuietState();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.currentDeadlineTimestampSeconds = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a WaitForQuietState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.WaitForQuietState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.WaitForQuietState} WaitForQuietState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WaitForQuietState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a WaitForQuietState message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.WaitForQuietState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WaitForQuietState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.currentDeadlineTimestampSeconds != null && message.hasOwnProperty("currentDeadlineTimestampSeconds"))
                        if (!$util.isInteger(message.currentDeadlineTimestampSeconds) && !(message.currentDeadlineTimestampSeconds && $util.isInteger(message.currentDeadlineTimestampSeconds.low) && $util.isInteger(message.currentDeadlineTimestampSeconds.high)))
                            return "currentDeadlineTimestampSeconds: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a WaitForQuietState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.WaitForQuietState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.WaitForQuietState} WaitForQuietState
                 */
                WaitForQuietState.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.WaitForQuietState)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.WaitForQuietState();
                    if (object.currentDeadlineTimestampSeconds != null)
                        if ($util.Long)
                            (message.currentDeadlineTimestampSeconds = $util.Long.fromValue(object.currentDeadlineTimestampSeconds)).unsigned = true;
                        else if (typeof object.currentDeadlineTimestampSeconds === "string")
                            message.currentDeadlineTimestampSeconds = parseInt(object.currentDeadlineTimestampSeconds, 10);
                        else if (typeof object.currentDeadlineTimestampSeconds === "number")
                            message.currentDeadlineTimestampSeconds = object.currentDeadlineTimestampSeconds;
                        else if (typeof object.currentDeadlineTimestampSeconds === "object")
                            message.currentDeadlineTimestampSeconds = new $util.LongBits(object.currentDeadlineTimestampSeconds.low >>> 0, object.currentDeadlineTimestampSeconds.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a WaitForQuietState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.WaitForQuietState
                 * @static
                 * @param {ic_nns_governance.pb.v1.WaitForQuietState} message WaitForQuietState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WaitForQuietState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.currentDeadlineTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.currentDeadlineTimestampSeconds = options.longs === String ? "0" : 0;
                    if (message.currentDeadlineTimestampSeconds != null && message.hasOwnProperty("currentDeadlineTimestampSeconds"))
                        if (typeof message.currentDeadlineTimestampSeconds === "number")
                            object.currentDeadlineTimestampSeconds = options.longs === String ? String(message.currentDeadlineTimestampSeconds) : message.currentDeadlineTimestampSeconds;
                        else
                            object.currentDeadlineTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.currentDeadlineTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.currentDeadlineTimestampSeconds.low >>> 0, message.currentDeadlineTimestampSeconds.high >>> 0).toNumber(true) : message.currentDeadlineTimestampSeconds;
                    return object;
                };

                /**
                 * Converts this WaitForQuietState to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.WaitForQuietState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                WaitForQuietState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return WaitForQuietState;
            })();

            v1.ProposalInfo = (function() {

                /**
                 * Properties of a ProposalInfo.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IProposalInfo
                 * @property {ic_nns_common.pb.v1.IProposalId|null} [id] ProposalInfo id
                 * @property {ic_nns_common.pb.v1.INeuronId|null} [proposer] ProposalInfo proposer
                 * @property {number|Long|null} [rejectCostE8s] ProposalInfo rejectCostE8s
                 * @property {ic_nns_governance.pb.v1.IProposal|null} [proposal] ProposalInfo proposal
                 * @property {number|Long|null} [proposalTimestampSeconds] ProposalInfo proposalTimestampSeconds
                 * @property {Object.<string,ic_nns_governance.pb.v1.IBallot>|null} [ballots] ProposalInfo ballots
                 * @property {ic_nns_governance.pb.v1.ITally|null} [latestTally] ProposalInfo latestTally
                 * @property {number|Long|null} [decidedTimestampSeconds] ProposalInfo decidedTimestampSeconds
                 * @property {number|Long|null} [executedTimestampSeconds] ProposalInfo executedTimestampSeconds
                 * @property {number|Long|null} [failedTimestampSeconds] ProposalInfo failedTimestampSeconds
                 * @property {ic_nns_governance.pb.v1.IGovernanceError|null} [failureReason] ProposalInfo failureReason
                 * @property {number|Long|null} [rewardEventRound] ProposalInfo rewardEventRound
                 * @property {ic_nns_governance.pb.v1.Topic|null} [topic] ProposalInfo topic
                 * @property {ic_nns_governance.pb.v1.ProposalStatus|null} [status] ProposalInfo status
                 * @property {ic_nns_governance.pb.v1.ProposalRewardStatus|null} [rewardStatus] ProposalInfo rewardStatus
                 * @property {number|Long|null} [deadlineTimestampSeconds] ProposalInfo deadlineTimestampSeconds
                 */

                /**
                 * Constructs a new ProposalInfo.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a ProposalInfo.
                 * @implements IProposalInfo
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IProposalInfo=} [properties] Properties to set
                 */
                function ProposalInfo(properties) {
                    this.ballots = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ProposalInfo id.
                 * @member {ic_nns_common.pb.v1.IProposalId|null|undefined} id
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.id = null;

                /**
                 * ProposalInfo proposer.
                 * @member {ic_nns_common.pb.v1.INeuronId|null|undefined} proposer
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.proposer = null;

                /**
                 * ProposalInfo rejectCostE8s.
                 * @member {number|Long} rejectCostE8s
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.rejectCostE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalInfo proposal.
                 * @member {ic_nns_governance.pb.v1.IProposal|null|undefined} proposal
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.proposal = null;

                /**
                 * ProposalInfo proposalTimestampSeconds.
                 * @member {number|Long} proposalTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.proposalTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalInfo ballots.
                 * @member {Object.<string,ic_nns_governance.pb.v1.IBallot>} ballots
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.ballots = $util.emptyObject;

                /**
                 * ProposalInfo latestTally.
                 * @member {ic_nns_governance.pb.v1.ITally|null|undefined} latestTally
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.latestTally = null;

                /**
                 * ProposalInfo decidedTimestampSeconds.
                 * @member {number|Long} decidedTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.decidedTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalInfo executedTimestampSeconds.
                 * @member {number|Long} executedTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.executedTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalInfo failedTimestampSeconds.
                 * @member {number|Long} failedTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.failedTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalInfo failureReason.
                 * @member {ic_nns_governance.pb.v1.IGovernanceError|null|undefined} failureReason
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.failureReason = null;

                /**
                 * ProposalInfo rewardEventRound.
                 * @member {number|Long} rewardEventRound
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.rewardEventRound = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ProposalInfo topic.
                 * @member {ic_nns_governance.pb.v1.Topic} topic
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.topic = 0;

                /**
                 * ProposalInfo status.
                 * @member {ic_nns_governance.pb.v1.ProposalStatus} status
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.status = 0;

                /**
                 * ProposalInfo rewardStatus.
                 * @member {ic_nns_governance.pb.v1.ProposalRewardStatus} rewardStatus
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.rewardStatus = 0;

                /**
                 * ProposalInfo deadlineTimestampSeconds.
                 * @member {number|Long|null|undefined} deadlineTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                ProposalInfo.prototype.deadlineTimestampSeconds = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * ProposalInfo _deadlineTimestampSeconds.
                 * @member {"deadlineTimestampSeconds"|undefined} _deadlineTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 */
                Object.defineProperty(ProposalInfo.prototype, "_deadlineTimestampSeconds", {
                    get: $util.oneOfGetter($oneOfFields = ["deadlineTimestampSeconds"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new ProposalInfo instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.IProposalInfo=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ProposalInfo} ProposalInfo instance
                 */
                ProposalInfo.create = function create(properties) {
                    return new ProposalInfo(properties);
                };

                /**
                 * Encodes the specified ProposalInfo message. Does not implicitly {@link ic_nns_governance.pb.v1.ProposalInfo.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.IProposalInfo} message ProposalInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProposalInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        $root.ic_nns_common.pb.v1.ProposalId.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.proposer != null && Object.hasOwnProperty.call(message, "proposer"))
                        $root.ic_nns_common.pb.v1.NeuronId.encode(message.proposer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.rejectCostE8s != null && Object.hasOwnProperty.call(message, "rejectCostE8s"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.rejectCostE8s);
                    if (message.proposal != null && Object.hasOwnProperty.call(message, "proposal"))
                        $root.ic_nns_governance.pb.v1.Proposal.encode(message.proposal, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.proposalTimestampSeconds != null && Object.hasOwnProperty.call(message, "proposalTimestampSeconds"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.proposalTimestampSeconds);
                    if (message.ballots != null && Object.hasOwnProperty.call(message, "ballots"))
                        for (let keys = Object.keys(message.ballots), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 1 =*/9).fixed64(keys[i]);
                            $root.ic_nns_governance.pb.v1.Ballot.encode(message.ballots[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.latestTally != null && Object.hasOwnProperty.call(message, "latestTally"))
                        $root.ic_nns_governance.pb.v1.Tally.encode(message.latestTally, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.decidedTimestampSeconds != null && Object.hasOwnProperty.call(message, "decidedTimestampSeconds"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.decidedTimestampSeconds);
                    if (message.executedTimestampSeconds != null && Object.hasOwnProperty.call(message, "executedTimestampSeconds"))
                        writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.executedTimestampSeconds);
                    if (message.failedTimestampSeconds != null && Object.hasOwnProperty.call(message, "failedTimestampSeconds"))
                        writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.failedTimestampSeconds);
                    if (message.rewardEventRound != null && Object.hasOwnProperty.call(message, "rewardEventRound"))
                        writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.rewardEventRound);
                    if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                        writer.uint32(/* id 15, wireType 0 =*/120).int32(message.topic);
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.status);
                    if (message.rewardStatus != null && Object.hasOwnProperty.call(message, "rewardStatus"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int32(message.rewardStatus);
                    if (message.failureReason != null && Object.hasOwnProperty.call(message, "failureReason"))
                        $root.ic_nns_governance.pb.v1.GovernanceError.encode(message.failureReason, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    if (message.deadlineTimestampSeconds != null && Object.hasOwnProperty.call(message, "deadlineTimestampSeconds"))
                        writer.uint32(/* id 19, wireType 0 =*/152).uint64(message.deadlineTimestampSeconds);
                    return writer;
                };

                /**
                 * Encodes the specified ProposalInfo message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ProposalInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.IProposalInfo} message ProposalInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProposalInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ProposalInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ProposalInfo} ProposalInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProposalInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ProposalInfo(), key, value;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = $root.ic_nns_common.pb.v1.ProposalId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.proposer = $root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.rejectCostE8s = reader.uint64();
                            break;
                        case 4:
                            message.proposal = $root.ic_nns_governance.pb.v1.Proposal.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.proposalTimestampSeconds = reader.uint64();
                            break;
                        case 6:
                            if (message.ballots === $util.emptyObject)
                                message.ballots = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.fixed64();
                                    break;
                                case 2:
                                    value = $root.ic_nns_governance.pb.v1.Ballot.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.ballots[typeof key === "object" ? $util.longToHash(key) : key] = value;
                            break;
                        case 7:
                            message.latestTally = $root.ic_nns_governance.pb.v1.Tally.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.decidedTimestampSeconds = reader.uint64();
                            break;
                        case 12:
                            message.executedTimestampSeconds = reader.uint64();
                            break;
                        case 13:
                            message.failedTimestampSeconds = reader.uint64();
                            break;
                        case 18:
                            message.failureReason = $root.ic_nns_governance.pb.v1.GovernanceError.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.rewardEventRound = reader.uint64();
                            break;
                        case 15:
                            message.topic = reader.int32();
                            break;
                        case 16:
                            message.status = reader.int32();
                            break;
                        case 17:
                            message.rewardStatus = reader.int32();
                            break;
                        case 19:
                            message.deadlineTimestampSeconds = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ProposalInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ProposalInfo} ProposalInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProposalInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ProposalInfo message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProposalInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.id != null && message.hasOwnProperty("id")) {
                        let error = $root.ic_nns_common.pb.v1.ProposalId.verify(message.id);
                        if (error)
                            return "id." + error;
                    }
                    if (message.proposer != null && message.hasOwnProperty("proposer")) {
                        let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.proposer);
                        if (error)
                            return "proposer." + error;
                    }
                    if (message.rejectCostE8s != null && message.hasOwnProperty("rejectCostE8s"))
                        if (!$util.isInteger(message.rejectCostE8s) && !(message.rejectCostE8s && $util.isInteger(message.rejectCostE8s.low) && $util.isInteger(message.rejectCostE8s.high)))
                            return "rejectCostE8s: integer|Long expected";
                    if (message.proposal != null && message.hasOwnProperty("proposal")) {
                        let error = $root.ic_nns_governance.pb.v1.Proposal.verify(message.proposal);
                        if (error)
                            return "proposal." + error;
                    }
                    if (message.proposalTimestampSeconds != null && message.hasOwnProperty("proposalTimestampSeconds"))
                        if (!$util.isInteger(message.proposalTimestampSeconds) && !(message.proposalTimestampSeconds && $util.isInteger(message.proposalTimestampSeconds.low) && $util.isInteger(message.proposalTimestampSeconds.high)))
                            return "proposalTimestampSeconds: integer|Long expected";
                    if (message.ballots != null && message.hasOwnProperty("ballots")) {
                        if (!$util.isObject(message.ballots))
                            return "ballots: object expected";
                        let key = Object.keys(message.ballots);
                        for (let i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "ballots: integer|Long key{k:fixed64} expected";
                            {
                                let error = $root.ic_nns_governance.pb.v1.Ballot.verify(message.ballots[key[i]]);
                                if (error)
                                    return "ballots." + error;
                            }
                        }
                    }
                    if (message.latestTally != null && message.hasOwnProperty("latestTally")) {
                        let error = $root.ic_nns_governance.pb.v1.Tally.verify(message.latestTally);
                        if (error)
                            return "latestTally." + error;
                    }
                    if (message.decidedTimestampSeconds != null && message.hasOwnProperty("decidedTimestampSeconds"))
                        if (!$util.isInteger(message.decidedTimestampSeconds) && !(message.decidedTimestampSeconds && $util.isInteger(message.decidedTimestampSeconds.low) && $util.isInteger(message.decidedTimestampSeconds.high)))
                            return "decidedTimestampSeconds: integer|Long expected";
                    if (message.executedTimestampSeconds != null && message.hasOwnProperty("executedTimestampSeconds"))
                        if (!$util.isInteger(message.executedTimestampSeconds) && !(message.executedTimestampSeconds && $util.isInteger(message.executedTimestampSeconds.low) && $util.isInteger(message.executedTimestampSeconds.high)))
                            return "executedTimestampSeconds: integer|Long expected";
                    if (message.failedTimestampSeconds != null && message.hasOwnProperty("failedTimestampSeconds"))
                        if (!$util.isInteger(message.failedTimestampSeconds) && !(message.failedTimestampSeconds && $util.isInteger(message.failedTimestampSeconds.low) && $util.isInteger(message.failedTimestampSeconds.high)))
                            return "failedTimestampSeconds: integer|Long expected";
                    if (message.failureReason != null && message.hasOwnProperty("failureReason")) {
                        let error = $root.ic_nns_governance.pb.v1.GovernanceError.verify(message.failureReason);
                        if (error)
                            return "failureReason." + error;
                    }
                    if (message.rewardEventRound != null && message.hasOwnProperty("rewardEventRound"))
                        if (!$util.isInteger(message.rewardEventRound) && !(message.rewardEventRound && $util.isInteger(message.rewardEventRound.low) && $util.isInteger(message.rewardEventRound.high)))
                            return "rewardEventRound: integer|Long expected";
                    if (message.topic != null && message.hasOwnProperty("topic"))
                        switch (message.topic) {
                        default:
                            return "topic: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                            break;
                        }
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.rewardStatus != null && message.hasOwnProperty("rewardStatus"))
                        switch (message.rewardStatus) {
                        default:
                            return "rewardStatus: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.deadlineTimestampSeconds != null && message.hasOwnProperty("deadlineTimestampSeconds")) {
                        properties._deadlineTimestampSeconds = 1;
                        if (!$util.isInteger(message.deadlineTimestampSeconds) && !(message.deadlineTimestampSeconds && $util.isInteger(message.deadlineTimestampSeconds.low) && $util.isInteger(message.deadlineTimestampSeconds.high)))
                            return "deadlineTimestampSeconds: integer|Long expected";
                    }
                    return null;
                };

                /**
                 * Creates a ProposalInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ProposalInfo} ProposalInfo
                 */
                ProposalInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ProposalInfo)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ProposalInfo();
                    if (object.id != null) {
                        if (typeof object.id !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalInfo.id: object expected");
                        message.id = $root.ic_nns_common.pb.v1.ProposalId.fromObject(object.id);
                    }
                    if (object.proposer != null) {
                        if (typeof object.proposer !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalInfo.proposer: object expected");
                        message.proposer = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.proposer);
                    }
                    if (object.rejectCostE8s != null)
                        if ($util.Long)
                            (message.rejectCostE8s = $util.Long.fromValue(object.rejectCostE8s)).unsigned = true;
                        else if (typeof object.rejectCostE8s === "string")
                            message.rejectCostE8s = parseInt(object.rejectCostE8s, 10);
                        else if (typeof object.rejectCostE8s === "number")
                            message.rejectCostE8s = object.rejectCostE8s;
                        else if (typeof object.rejectCostE8s === "object")
                            message.rejectCostE8s = new $util.LongBits(object.rejectCostE8s.low >>> 0, object.rejectCostE8s.high >>> 0).toNumber(true);
                    if (object.proposal != null) {
                        if (typeof object.proposal !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalInfo.proposal: object expected");
                        message.proposal = $root.ic_nns_governance.pb.v1.Proposal.fromObject(object.proposal);
                    }
                    if (object.proposalTimestampSeconds != null)
                        if ($util.Long)
                            (message.proposalTimestampSeconds = $util.Long.fromValue(object.proposalTimestampSeconds)).unsigned = true;
                        else if (typeof object.proposalTimestampSeconds === "string")
                            message.proposalTimestampSeconds = parseInt(object.proposalTimestampSeconds, 10);
                        else if (typeof object.proposalTimestampSeconds === "number")
                            message.proposalTimestampSeconds = object.proposalTimestampSeconds;
                        else if (typeof object.proposalTimestampSeconds === "object")
                            message.proposalTimestampSeconds = new $util.LongBits(object.proposalTimestampSeconds.low >>> 0, object.proposalTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.ballots) {
                        if (typeof object.ballots !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalInfo.ballots: object expected");
                        message.ballots = {};
                        for (let keys = Object.keys(object.ballots), i = 0; i < keys.length; ++i) {
                            if (typeof object.ballots[keys[i]] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ProposalInfo.ballots: object expected");
                            message.ballots[keys[i]] = $root.ic_nns_governance.pb.v1.Ballot.fromObject(object.ballots[keys[i]]);
                        }
                    }
                    if (object.latestTally != null) {
                        if (typeof object.latestTally !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalInfo.latestTally: object expected");
                        message.latestTally = $root.ic_nns_governance.pb.v1.Tally.fromObject(object.latestTally);
                    }
                    if (object.decidedTimestampSeconds != null)
                        if ($util.Long)
                            (message.decidedTimestampSeconds = $util.Long.fromValue(object.decidedTimestampSeconds)).unsigned = true;
                        else if (typeof object.decidedTimestampSeconds === "string")
                            message.decidedTimestampSeconds = parseInt(object.decidedTimestampSeconds, 10);
                        else if (typeof object.decidedTimestampSeconds === "number")
                            message.decidedTimestampSeconds = object.decidedTimestampSeconds;
                        else if (typeof object.decidedTimestampSeconds === "object")
                            message.decidedTimestampSeconds = new $util.LongBits(object.decidedTimestampSeconds.low >>> 0, object.decidedTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.executedTimestampSeconds != null)
                        if ($util.Long)
                            (message.executedTimestampSeconds = $util.Long.fromValue(object.executedTimestampSeconds)).unsigned = true;
                        else if (typeof object.executedTimestampSeconds === "string")
                            message.executedTimestampSeconds = parseInt(object.executedTimestampSeconds, 10);
                        else if (typeof object.executedTimestampSeconds === "number")
                            message.executedTimestampSeconds = object.executedTimestampSeconds;
                        else if (typeof object.executedTimestampSeconds === "object")
                            message.executedTimestampSeconds = new $util.LongBits(object.executedTimestampSeconds.low >>> 0, object.executedTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.failedTimestampSeconds != null)
                        if ($util.Long)
                            (message.failedTimestampSeconds = $util.Long.fromValue(object.failedTimestampSeconds)).unsigned = true;
                        else if (typeof object.failedTimestampSeconds === "string")
                            message.failedTimestampSeconds = parseInt(object.failedTimestampSeconds, 10);
                        else if (typeof object.failedTimestampSeconds === "number")
                            message.failedTimestampSeconds = object.failedTimestampSeconds;
                        else if (typeof object.failedTimestampSeconds === "object")
                            message.failedTimestampSeconds = new $util.LongBits(object.failedTimestampSeconds.low >>> 0, object.failedTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.failureReason != null) {
                        if (typeof object.failureReason !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ProposalInfo.failureReason: object expected");
                        message.failureReason = $root.ic_nns_governance.pb.v1.GovernanceError.fromObject(object.failureReason);
                    }
                    if (object.rewardEventRound != null)
                        if ($util.Long)
                            (message.rewardEventRound = $util.Long.fromValue(object.rewardEventRound)).unsigned = true;
                        else if (typeof object.rewardEventRound === "string")
                            message.rewardEventRound = parseInt(object.rewardEventRound, 10);
                        else if (typeof object.rewardEventRound === "number")
                            message.rewardEventRound = object.rewardEventRound;
                        else if (typeof object.rewardEventRound === "object")
                            message.rewardEventRound = new $util.LongBits(object.rewardEventRound.low >>> 0, object.rewardEventRound.high >>> 0).toNumber(true);
                    switch (object.topic) {
                    case "TOPIC_UNSPECIFIED":
                    case 0:
                        message.topic = 0;
                        break;
                    case "TOPIC_NEURON_MANAGEMENT":
                    case 1:
                        message.topic = 1;
                        break;
                    case "TOPIC_EXCHANGE_RATE":
                    case 2:
                        message.topic = 2;
                        break;
                    case "TOPIC_NETWORK_ECONOMICS":
                    case 3:
                        message.topic = 3;
                        break;
                    case "TOPIC_GOVERNANCE":
                    case 4:
                        message.topic = 4;
                        break;
                    case "TOPIC_NODE_ADMIN":
                    case 5:
                        message.topic = 5;
                        break;
                    case "TOPIC_PARTICIPANT_MANAGEMENT":
                    case 6:
                        message.topic = 6;
                        break;
                    case "TOPIC_SUBNET_MANAGEMENT":
                    case 7:
                        message.topic = 7;
                        break;
                    case "TOPIC_NETWORK_CANISTER_MANAGEMENT":
                    case 8:
                        message.topic = 8;
                        break;
                    case "TOPIC_KYC":
                    case 9:
                        message.topic = 9;
                        break;
                    case "TOPIC_NODE_PROVIDER_REWARDS":
                    case 10:
                        message.topic = 10;
                        break;
                    }
                    switch (object.status) {
                    case "PROPOSAL_STATUS_UNSPECIFIED":
                    case 0:
                        message.status = 0;
                        break;
                    case "PROPOSAL_STATUS_OPEN":
                    case 1:
                        message.status = 1;
                        break;
                    case "PROPOSAL_STATUS_REJECTED":
                    case 2:
                        message.status = 2;
                        break;
                    case "PROPOSAL_STATUS_ADOPTED":
                    case 3:
                        message.status = 3;
                        break;
                    case "PROPOSAL_STATUS_EXECUTED":
                    case 4:
                        message.status = 4;
                        break;
                    case "PROPOSAL_STATUS_FAILED":
                    case 5:
                        message.status = 5;
                        break;
                    }
                    switch (object.rewardStatus) {
                    case "PROPOSAL_REWARD_STATUS_UNSPECIFIED":
                    case 0:
                        message.rewardStatus = 0;
                        break;
                    case "PROPOSAL_REWARD_STATUS_ACCEPT_VOTES":
                    case 1:
                        message.rewardStatus = 1;
                        break;
                    case "PROPOSAL_REWARD_STATUS_READY_TO_SETTLE":
                    case 2:
                        message.rewardStatus = 2;
                        break;
                    case "PROPOSAL_REWARD_STATUS_SETTLED":
                    case 3:
                        message.rewardStatus = 3;
                        break;
                    case "PROPOSAL_REWARD_STATUS_INELIGIBLE":
                    case 4:
                        message.rewardStatus = 4;
                        break;
                    }
                    if (object.deadlineTimestampSeconds != null)
                        if ($util.Long)
                            (message.deadlineTimestampSeconds = $util.Long.fromValue(object.deadlineTimestampSeconds)).unsigned = true;
                        else if (typeof object.deadlineTimestampSeconds === "string")
                            message.deadlineTimestampSeconds = parseInt(object.deadlineTimestampSeconds, 10);
                        else if (typeof object.deadlineTimestampSeconds === "number")
                            message.deadlineTimestampSeconds = object.deadlineTimestampSeconds;
                        else if (typeof object.deadlineTimestampSeconds === "object")
                            message.deadlineTimestampSeconds = new $util.LongBits(object.deadlineTimestampSeconds.low >>> 0, object.deadlineTimestampSeconds.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a ProposalInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.ProposalInfo} message ProposalInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProposalInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.ballots = {};
                    if (options.defaults) {
                        object.id = null;
                        object.proposer = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.rejectCostE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rejectCostE8s = options.longs === String ? "0" : 0;
                        object.proposal = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.proposalTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.proposalTimestampSeconds = options.longs === String ? "0" : 0;
                        object.latestTally = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.decidedTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.decidedTimestampSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.executedTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.executedTimestampSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.failedTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.failedTimestampSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.rewardEventRound = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rewardEventRound = options.longs === String ? "0" : 0;
                        object.topic = options.enums === String ? "TOPIC_UNSPECIFIED" : 0;
                        object.status = options.enums === String ? "PROPOSAL_STATUS_UNSPECIFIED" : 0;
                        object.rewardStatus = options.enums === String ? "PROPOSAL_REWARD_STATUS_UNSPECIFIED" : 0;
                        object.failureReason = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = $root.ic_nns_common.pb.v1.ProposalId.toObject(message.id, options);
                    if (message.proposer != null && message.hasOwnProperty("proposer"))
                        object.proposer = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.proposer, options);
                    if (message.rejectCostE8s != null && message.hasOwnProperty("rejectCostE8s"))
                        if (typeof message.rejectCostE8s === "number")
                            object.rejectCostE8s = options.longs === String ? String(message.rejectCostE8s) : message.rejectCostE8s;
                        else
                            object.rejectCostE8s = options.longs === String ? $util.Long.prototype.toString.call(message.rejectCostE8s) : options.longs === Number ? new $util.LongBits(message.rejectCostE8s.low >>> 0, message.rejectCostE8s.high >>> 0).toNumber(true) : message.rejectCostE8s;
                    if (message.proposal != null && message.hasOwnProperty("proposal"))
                        object.proposal = $root.ic_nns_governance.pb.v1.Proposal.toObject(message.proposal, options);
                    if (message.proposalTimestampSeconds != null && message.hasOwnProperty("proposalTimestampSeconds"))
                        if (typeof message.proposalTimestampSeconds === "number")
                            object.proposalTimestampSeconds = options.longs === String ? String(message.proposalTimestampSeconds) : message.proposalTimestampSeconds;
                        else
                            object.proposalTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.proposalTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.proposalTimestampSeconds.low >>> 0, message.proposalTimestampSeconds.high >>> 0).toNumber(true) : message.proposalTimestampSeconds;
                    let keys2;
                    if (message.ballots && (keys2 = Object.keys(message.ballots)).length) {
                        object.ballots = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.ballots[keys2[j]] = $root.ic_nns_governance.pb.v1.Ballot.toObject(message.ballots[keys2[j]], options);
                    }
                    if (message.latestTally != null && message.hasOwnProperty("latestTally"))
                        object.latestTally = $root.ic_nns_governance.pb.v1.Tally.toObject(message.latestTally, options);
                    if (message.decidedTimestampSeconds != null && message.hasOwnProperty("decidedTimestampSeconds"))
                        if (typeof message.decidedTimestampSeconds === "number")
                            object.decidedTimestampSeconds = options.longs === String ? String(message.decidedTimestampSeconds) : message.decidedTimestampSeconds;
                        else
                            object.decidedTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.decidedTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.decidedTimestampSeconds.low >>> 0, message.decidedTimestampSeconds.high >>> 0).toNumber(true) : message.decidedTimestampSeconds;
                    if (message.executedTimestampSeconds != null && message.hasOwnProperty("executedTimestampSeconds"))
                        if (typeof message.executedTimestampSeconds === "number")
                            object.executedTimestampSeconds = options.longs === String ? String(message.executedTimestampSeconds) : message.executedTimestampSeconds;
                        else
                            object.executedTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.executedTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.executedTimestampSeconds.low >>> 0, message.executedTimestampSeconds.high >>> 0).toNumber(true) : message.executedTimestampSeconds;
                    if (message.failedTimestampSeconds != null && message.hasOwnProperty("failedTimestampSeconds"))
                        if (typeof message.failedTimestampSeconds === "number")
                            object.failedTimestampSeconds = options.longs === String ? String(message.failedTimestampSeconds) : message.failedTimestampSeconds;
                        else
                            object.failedTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.failedTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.failedTimestampSeconds.low >>> 0, message.failedTimestampSeconds.high >>> 0).toNumber(true) : message.failedTimestampSeconds;
                    if (message.rewardEventRound != null && message.hasOwnProperty("rewardEventRound"))
                        if (typeof message.rewardEventRound === "number")
                            object.rewardEventRound = options.longs === String ? String(message.rewardEventRound) : message.rewardEventRound;
                        else
                            object.rewardEventRound = options.longs === String ? $util.Long.prototype.toString.call(message.rewardEventRound) : options.longs === Number ? new $util.LongBits(message.rewardEventRound.low >>> 0, message.rewardEventRound.high >>> 0).toNumber(true) : message.rewardEventRound;
                    if (message.topic != null && message.hasOwnProperty("topic"))
                        object.topic = options.enums === String ? $root.ic_nns_governance.pb.v1.Topic[message.topic] : message.topic;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.ic_nns_governance.pb.v1.ProposalStatus[message.status] : message.status;
                    if (message.rewardStatus != null && message.hasOwnProperty("rewardStatus"))
                        object.rewardStatus = options.enums === String ? $root.ic_nns_governance.pb.v1.ProposalRewardStatus[message.rewardStatus] : message.rewardStatus;
                    if (message.failureReason != null && message.hasOwnProperty("failureReason"))
                        object.failureReason = $root.ic_nns_governance.pb.v1.GovernanceError.toObject(message.failureReason, options);
                    if (message.deadlineTimestampSeconds != null && message.hasOwnProperty("deadlineTimestampSeconds")) {
                        if (typeof message.deadlineTimestampSeconds === "number")
                            object.deadlineTimestampSeconds = options.longs === String ? String(message.deadlineTimestampSeconds) : message.deadlineTimestampSeconds;
                        else
                            object.deadlineTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.deadlineTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.deadlineTimestampSeconds.low >>> 0, message.deadlineTimestampSeconds.high >>> 0).toNumber(true) : message.deadlineTimestampSeconds;
                        if (options.oneofs)
                            object._deadlineTimestampSeconds = "deadlineTimestampSeconds";
                    }
                    return object;
                };

                /**
                 * Converts this ProposalInfo to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ProposalInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProposalInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ProposalInfo;
            })();

            v1.NetworkEconomics = (function() {

                /**
                 * Properties of a NetworkEconomics.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface INetworkEconomics
                 * @property {number|Long|null} [rejectCostE8s] NetworkEconomics rejectCostE8s
                 * @property {number|Long|null} [neuronMinimumStakeE8s] NetworkEconomics neuronMinimumStakeE8s
                 * @property {number|Long|null} [neuronManagementFeePerProposalE8s] NetworkEconomics neuronManagementFeePerProposalE8s
                 * @property {number|Long|null} [minimumIcpXdrRate] NetworkEconomics minimumIcpXdrRate
                 * @property {number|Long|null} [neuronSpawnDissolveDelaySeconds] NetworkEconomics neuronSpawnDissolveDelaySeconds
                 * @property {number|Long|null} [maximumNodeProviderRewardsE8s] NetworkEconomics maximumNodeProviderRewardsE8s
                 * @property {number|Long|null} [transactionFeeE8s] NetworkEconomics transactionFeeE8s
                 * @property {number|null} [maxProposalsToKeepPerTopic] NetworkEconomics maxProposalsToKeepPerTopic
                 */

                /**
                 * Constructs a new NetworkEconomics.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a NetworkEconomics.
                 * @implements INetworkEconomics
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.INetworkEconomics=} [properties] Properties to set
                 */
                function NetworkEconomics(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NetworkEconomics rejectCostE8s.
                 * @member {number|Long} rejectCostE8s
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @instance
                 */
                NetworkEconomics.prototype.rejectCostE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NetworkEconomics neuronMinimumStakeE8s.
                 * @member {number|Long} neuronMinimumStakeE8s
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @instance
                 */
                NetworkEconomics.prototype.neuronMinimumStakeE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NetworkEconomics neuronManagementFeePerProposalE8s.
                 * @member {number|Long} neuronManagementFeePerProposalE8s
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @instance
                 */
                NetworkEconomics.prototype.neuronManagementFeePerProposalE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NetworkEconomics minimumIcpXdrRate.
                 * @member {number|Long} minimumIcpXdrRate
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @instance
                 */
                NetworkEconomics.prototype.minimumIcpXdrRate = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NetworkEconomics neuronSpawnDissolveDelaySeconds.
                 * @member {number|Long} neuronSpawnDissolveDelaySeconds
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @instance
                 */
                NetworkEconomics.prototype.neuronSpawnDissolveDelaySeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NetworkEconomics maximumNodeProviderRewardsE8s.
                 * @member {number|Long} maximumNodeProviderRewardsE8s
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @instance
                 */
                NetworkEconomics.prototype.maximumNodeProviderRewardsE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NetworkEconomics transactionFeeE8s.
                 * @member {number|Long} transactionFeeE8s
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @instance
                 */
                NetworkEconomics.prototype.transactionFeeE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * NetworkEconomics maxProposalsToKeepPerTopic.
                 * @member {number} maxProposalsToKeepPerTopic
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @instance
                 */
                NetworkEconomics.prototype.maxProposalsToKeepPerTopic = 0;

                /**
                 * Creates a new NetworkEconomics instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @static
                 * @param {ic_nns_governance.pb.v1.INetworkEconomics=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.NetworkEconomics} NetworkEconomics instance
                 */
                NetworkEconomics.create = function create(properties) {
                    return new NetworkEconomics(properties);
                };

                /**
                 * Encodes the specified NetworkEconomics message. Does not implicitly {@link ic_nns_governance.pb.v1.NetworkEconomics.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @static
                 * @param {ic_nns_governance.pb.v1.INetworkEconomics} message NetworkEconomics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkEconomics.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rejectCostE8s != null && Object.hasOwnProperty.call(message, "rejectCostE8s"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.rejectCostE8s);
                    if (message.neuronMinimumStakeE8s != null && Object.hasOwnProperty.call(message, "neuronMinimumStakeE8s"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.neuronMinimumStakeE8s);
                    if (message.neuronManagementFeePerProposalE8s != null && Object.hasOwnProperty.call(message, "neuronManagementFeePerProposalE8s"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.neuronManagementFeePerProposalE8s);
                    if (message.minimumIcpXdrRate != null && Object.hasOwnProperty.call(message, "minimumIcpXdrRate"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.minimumIcpXdrRate);
                    if (message.neuronSpawnDissolveDelaySeconds != null && Object.hasOwnProperty.call(message, "neuronSpawnDissolveDelaySeconds"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.neuronSpawnDissolveDelaySeconds);
                    if (message.maximumNodeProviderRewardsE8s != null && Object.hasOwnProperty.call(message, "maximumNodeProviderRewardsE8s"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.maximumNodeProviderRewardsE8s);
                    if (message.transactionFeeE8s != null && Object.hasOwnProperty.call(message, "transactionFeeE8s"))
                        writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.transactionFeeE8s);
                    if (message.maxProposalsToKeepPerTopic != null && Object.hasOwnProperty.call(message, "maxProposalsToKeepPerTopic"))
                        writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.maxProposalsToKeepPerTopic);
                    return writer;
                };

                /**
                 * Encodes the specified NetworkEconomics message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.NetworkEconomics.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @static
                 * @param {ic_nns_governance.pb.v1.INetworkEconomics} message NetworkEconomics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NetworkEconomics.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NetworkEconomics message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.NetworkEconomics} NetworkEconomics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkEconomics.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.NetworkEconomics();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.rejectCostE8s = reader.uint64();
                            break;
                        case 2:
                            message.neuronMinimumStakeE8s = reader.uint64();
                            break;
                        case 4:
                            message.neuronManagementFeePerProposalE8s = reader.uint64();
                            break;
                        case 5:
                            message.minimumIcpXdrRate = reader.uint64();
                            break;
                        case 6:
                            message.neuronSpawnDissolveDelaySeconds = reader.uint64();
                            break;
                        case 8:
                            message.maximumNodeProviderRewardsE8s = reader.uint64();
                            break;
                        case 9:
                            message.transactionFeeE8s = reader.uint64();
                            break;
                        case 10:
                            message.maxProposalsToKeepPerTopic = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NetworkEconomics message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.NetworkEconomics} NetworkEconomics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NetworkEconomics.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NetworkEconomics message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NetworkEconomics.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.rejectCostE8s != null && message.hasOwnProperty("rejectCostE8s"))
                        if (!$util.isInteger(message.rejectCostE8s) && !(message.rejectCostE8s && $util.isInteger(message.rejectCostE8s.low) && $util.isInteger(message.rejectCostE8s.high)))
                            return "rejectCostE8s: integer|Long expected";
                    if (message.neuronMinimumStakeE8s != null && message.hasOwnProperty("neuronMinimumStakeE8s"))
                        if (!$util.isInteger(message.neuronMinimumStakeE8s) && !(message.neuronMinimumStakeE8s && $util.isInteger(message.neuronMinimumStakeE8s.low) && $util.isInteger(message.neuronMinimumStakeE8s.high)))
                            return "neuronMinimumStakeE8s: integer|Long expected";
                    if (message.neuronManagementFeePerProposalE8s != null && message.hasOwnProperty("neuronManagementFeePerProposalE8s"))
                        if (!$util.isInteger(message.neuronManagementFeePerProposalE8s) && !(message.neuronManagementFeePerProposalE8s && $util.isInteger(message.neuronManagementFeePerProposalE8s.low) && $util.isInteger(message.neuronManagementFeePerProposalE8s.high)))
                            return "neuronManagementFeePerProposalE8s: integer|Long expected";
                    if (message.minimumIcpXdrRate != null && message.hasOwnProperty("minimumIcpXdrRate"))
                        if (!$util.isInteger(message.minimumIcpXdrRate) && !(message.minimumIcpXdrRate && $util.isInteger(message.minimumIcpXdrRate.low) && $util.isInteger(message.minimumIcpXdrRate.high)))
                            return "minimumIcpXdrRate: integer|Long expected";
                    if (message.neuronSpawnDissolveDelaySeconds != null && message.hasOwnProperty("neuronSpawnDissolveDelaySeconds"))
                        if (!$util.isInteger(message.neuronSpawnDissolveDelaySeconds) && !(message.neuronSpawnDissolveDelaySeconds && $util.isInteger(message.neuronSpawnDissolveDelaySeconds.low) && $util.isInteger(message.neuronSpawnDissolveDelaySeconds.high)))
                            return "neuronSpawnDissolveDelaySeconds: integer|Long expected";
                    if (message.maximumNodeProviderRewardsE8s != null && message.hasOwnProperty("maximumNodeProviderRewardsE8s"))
                        if (!$util.isInteger(message.maximumNodeProviderRewardsE8s) && !(message.maximumNodeProviderRewardsE8s && $util.isInteger(message.maximumNodeProviderRewardsE8s.low) && $util.isInteger(message.maximumNodeProviderRewardsE8s.high)))
                            return "maximumNodeProviderRewardsE8s: integer|Long expected";
                    if (message.transactionFeeE8s != null && message.hasOwnProperty("transactionFeeE8s"))
                        if (!$util.isInteger(message.transactionFeeE8s) && !(message.transactionFeeE8s && $util.isInteger(message.transactionFeeE8s.low) && $util.isInteger(message.transactionFeeE8s.high)))
                            return "transactionFeeE8s: integer|Long expected";
                    if (message.maxProposalsToKeepPerTopic != null && message.hasOwnProperty("maxProposalsToKeepPerTopic"))
                        if (!$util.isInteger(message.maxProposalsToKeepPerTopic))
                            return "maxProposalsToKeepPerTopic: integer expected";
                    return null;
                };

                /**
                 * Creates a NetworkEconomics message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.NetworkEconomics} NetworkEconomics
                 */
                NetworkEconomics.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.NetworkEconomics)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.NetworkEconomics();
                    if (object.rejectCostE8s != null)
                        if ($util.Long)
                            (message.rejectCostE8s = $util.Long.fromValue(object.rejectCostE8s)).unsigned = true;
                        else if (typeof object.rejectCostE8s === "string")
                            message.rejectCostE8s = parseInt(object.rejectCostE8s, 10);
                        else if (typeof object.rejectCostE8s === "number")
                            message.rejectCostE8s = object.rejectCostE8s;
                        else if (typeof object.rejectCostE8s === "object")
                            message.rejectCostE8s = new $util.LongBits(object.rejectCostE8s.low >>> 0, object.rejectCostE8s.high >>> 0).toNumber(true);
                    if (object.neuronMinimumStakeE8s != null)
                        if ($util.Long)
                            (message.neuronMinimumStakeE8s = $util.Long.fromValue(object.neuronMinimumStakeE8s)).unsigned = true;
                        else if (typeof object.neuronMinimumStakeE8s === "string")
                            message.neuronMinimumStakeE8s = parseInt(object.neuronMinimumStakeE8s, 10);
                        else if (typeof object.neuronMinimumStakeE8s === "number")
                            message.neuronMinimumStakeE8s = object.neuronMinimumStakeE8s;
                        else if (typeof object.neuronMinimumStakeE8s === "object")
                            message.neuronMinimumStakeE8s = new $util.LongBits(object.neuronMinimumStakeE8s.low >>> 0, object.neuronMinimumStakeE8s.high >>> 0).toNumber(true);
                    if (object.neuronManagementFeePerProposalE8s != null)
                        if ($util.Long)
                            (message.neuronManagementFeePerProposalE8s = $util.Long.fromValue(object.neuronManagementFeePerProposalE8s)).unsigned = true;
                        else if (typeof object.neuronManagementFeePerProposalE8s === "string")
                            message.neuronManagementFeePerProposalE8s = parseInt(object.neuronManagementFeePerProposalE8s, 10);
                        else if (typeof object.neuronManagementFeePerProposalE8s === "number")
                            message.neuronManagementFeePerProposalE8s = object.neuronManagementFeePerProposalE8s;
                        else if (typeof object.neuronManagementFeePerProposalE8s === "object")
                            message.neuronManagementFeePerProposalE8s = new $util.LongBits(object.neuronManagementFeePerProposalE8s.low >>> 0, object.neuronManagementFeePerProposalE8s.high >>> 0).toNumber(true);
                    if (object.minimumIcpXdrRate != null)
                        if ($util.Long)
                            (message.minimumIcpXdrRate = $util.Long.fromValue(object.minimumIcpXdrRate)).unsigned = true;
                        else if (typeof object.minimumIcpXdrRate === "string")
                            message.minimumIcpXdrRate = parseInt(object.minimumIcpXdrRate, 10);
                        else if (typeof object.minimumIcpXdrRate === "number")
                            message.minimumIcpXdrRate = object.minimumIcpXdrRate;
                        else if (typeof object.minimumIcpXdrRate === "object")
                            message.minimumIcpXdrRate = new $util.LongBits(object.minimumIcpXdrRate.low >>> 0, object.minimumIcpXdrRate.high >>> 0).toNumber(true);
                    if (object.neuronSpawnDissolveDelaySeconds != null)
                        if ($util.Long)
                            (message.neuronSpawnDissolveDelaySeconds = $util.Long.fromValue(object.neuronSpawnDissolveDelaySeconds)).unsigned = true;
                        else if (typeof object.neuronSpawnDissolveDelaySeconds === "string")
                            message.neuronSpawnDissolveDelaySeconds = parseInt(object.neuronSpawnDissolveDelaySeconds, 10);
                        else if (typeof object.neuronSpawnDissolveDelaySeconds === "number")
                            message.neuronSpawnDissolveDelaySeconds = object.neuronSpawnDissolveDelaySeconds;
                        else if (typeof object.neuronSpawnDissolveDelaySeconds === "object")
                            message.neuronSpawnDissolveDelaySeconds = new $util.LongBits(object.neuronSpawnDissolveDelaySeconds.low >>> 0, object.neuronSpawnDissolveDelaySeconds.high >>> 0).toNumber(true);
                    if (object.maximumNodeProviderRewardsE8s != null)
                        if ($util.Long)
                            (message.maximumNodeProviderRewardsE8s = $util.Long.fromValue(object.maximumNodeProviderRewardsE8s)).unsigned = true;
                        else if (typeof object.maximumNodeProviderRewardsE8s === "string")
                            message.maximumNodeProviderRewardsE8s = parseInt(object.maximumNodeProviderRewardsE8s, 10);
                        else if (typeof object.maximumNodeProviderRewardsE8s === "number")
                            message.maximumNodeProviderRewardsE8s = object.maximumNodeProviderRewardsE8s;
                        else if (typeof object.maximumNodeProviderRewardsE8s === "object")
                            message.maximumNodeProviderRewardsE8s = new $util.LongBits(object.maximumNodeProviderRewardsE8s.low >>> 0, object.maximumNodeProviderRewardsE8s.high >>> 0).toNumber(true);
                    if (object.transactionFeeE8s != null)
                        if ($util.Long)
                            (message.transactionFeeE8s = $util.Long.fromValue(object.transactionFeeE8s)).unsigned = true;
                        else if (typeof object.transactionFeeE8s === "string")
                            message.transactionFeeE8s = parseInt(object.transactionFeeE8s, 10);
                        else if (typeof object.transactionFeeE8s === "number")
                            message.transactionFeeE8s = object.transactionFeeE8s;
                        else if (typeof object.transactionFeeE8s === "object")
                            message.transactionFeeE8s = new $util.LongBits(object.transactionFeeE8s.low >>> 0, object.transactionFeeE8s.high >>> 0).toNumber(true);
                    if (object.maxProposalsToKeepPerTopic != null)
                        message.maxProposalsToKeepPerTopic = object.maxProposalsToKeepPerTopic >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a NetworkEconomics message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @static
                 * @param {ic_nns_governance.pb.v1.NetworkEconomics} message NetworkEconomics
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NetworkEconomics.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.rejectCostE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rejectCostE8s = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.neuronMinimumStakeE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.neuronMinimumStakeE8s = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.neuronManagementFeePerProposalE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.neuronManagementFeePerProposalE8s = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.minimumIcpXdrRate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.minimumIcpXdrRate = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.neuronSpawnDissolveDelaySeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.neuronSpawnDissolveDelaySeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.maximumNodeProviderRewardsE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.maximumNodeProviderRewardsE8s = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.transactionFeeE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.transactionFeeE8s = options.longs === String ? "0" : 0;
                        object.maxProposalsToKeepPerTopic = 0;
                    }
                    if (message.rejectCostE8s != null && message.hasOwnProperty("rejectCostE8s"))
                        if (typeof message.rejectCostE8s === "number")
                            object.rejectCostE8s = options.longs === String ? String(message.rejectCostE8s) : message.rejectCostE8s;
                        else
                            object.rejectCostE8s = options.longs === String ? $util.Long.prototype.toString.call(message.rejectCostE8s) : options.longs === Number ? new $util.LongBits(message.rejectCostE8s.low >>> 0, message.rejectCostE8s.high >>> 0).toNumber(true) : message.rejectCostE8s;
                    if (message.neuronMinimumStakeE8s != null && message.hasOwnProperty("neuronMinimumStakeE8s"))
                        if (typeof message.neuronMinimumStakeE8s === "number")
                            object.neuronMinimumStakeE8s = options.longs === String ? String(message.neuronMinimumStakeE8s) : message.neuronMinimumStakeE8s;
                        else
                            object.neuronMinimumStakeE8s = options.longs === String ? $util.Long.prototype.toString.call(message.neuronMinimumStakeE8s) : options.longs === Number ? new $util.LongBits(message.neuronMinimumStakeE8s.low >>> 0, message.neuronMinimumStakeE8s.high >>> 0).toNumber(true) : message.neuronMinimumStakeE8s;
                    if (message.neuronManagementFeePerProposalE8s != null && message.hasOwnProperty("neuronManagementFeePerProposalE8s"))
                        if (typeof message.neuronManagementFeePerProposalE8s === "number")
                            object.neuronManagementFeePerProposalE8s = options.longs === String ? String(message.neuronManagementFeePerProposalE8s) : message.neuronManagementFeePerProposalE8s;
                        else
                            object.neuronManagementFeePerProposalE8s = options.longs === String ? $util.Long.prototype.toString.call(message.neuronManagementFeePerProposalE8s) : options.longs === Number ? new $util.LongBits(message.neuronManagementFeePerProposalE8s.low >>> 0, message.neuronManagementFeePerProposalE8s.high >>> 0).toNumber(true) : message.neuronManagementFeePerProposalE8s;
                    if (message.minimumIcpXdrRate != null && message.hasOwnProperty("minimumIcpXdrRate"))
                        if (typeof message.minimumIcpXdrRate === "number")
                            object.minimumIcpXdrRate = options.longs === String ? String(message.minimumIcpXdrRate) : message.minimumIcpXdrRate;
                        else
                            object.minimumIcpXdrRate = options.longs === String ? $util.Long.prototype.toString.call(message.minimumIcpXdrRate) : options.longs === Number ? new $util.LongBits(message.minimumIcpXdrRate.low >>> 0, message.minimumIcpXdrRate.high >>> 0).toNumber(true) : message.minimumIcpXdrRate;
                    if (message.neuronSpawnDissolveDelaySeconds != null && message.hasOwnProperty("neuronSpawnDissolveDelaySeconds"))
                        if (typeof message.neuronSpawnDissolveDelaySeconds === "number")
                            object.neuronSpawnDissolveDelaySeconds = options.longs === String ? String(message.neuronSpawnDissolveDelaySeconds) : message.neuronSpawnDissolveDelaySeconds;
                        else
                            object.neuronSpawnDissolveDelaySeconds = options.longs === String ? $util.Long.prototype.toString.call(message.neuronSpawnDissolveDelaySeconds) : options.longs === Number ? new $util.LongBits(message.neuronSpawnDissolveDelaySeconds.low >>> 0, message.neuronSpawnDissolveDelaySeconds.high >>> 0).toNumber(true) : message.neuronSpawnDissolveDelaySeconds;
                    if (message.maximumNodeProviderRewardsE8s != null && message.hasOwnProperty("maximumNodeProviderRewardsE8s"))
                        if (typeof message.maximumNodeProviderRewardsE8s === "number")
                            object.maximumNodeProviderRewardsE8s = options.longs === String ? String(message.maximumNodeProviderRewardsE8s) : message.maximumNodeProviderRewardsE8s;
                        else
                            object.maximumNodeProviderRewardsE8s = options.longs === String ? $util.Long.prototype.toString.call(message.maximumNodeProviderRewardsE8s) : options.longs === Number ? new $util.LongBits(message.maximumNodeProviderRewardsE8s.low >>> 0, message.maximumNodeProviderRewardsE8s.high >>> 0).toNumber(true) : message.maximumNodeProviderRewardsE8s;
                    if (message.transactionFeeE8s != null && message.hasOwnProperty("transactionFeeE8s"))
                        if (typeof message.transactionFeeE8s === "number")
                            object.transactionFeeE8s = options.longs === String ? String(message.transactionFeeE8s) : message.transactionFeeE8s;
                        else
                            object.transactionFeeE8s = options.longs === String ? $util.Long.prototype.toString.call(message.transactionFeeE8s) : options.longs === Number ? new $util.LongBits(message.transactionFeeE8s.low >>> 0, message.transactionFeeE8s.high >>> 0).toNumber(true) : message.transactionFeeE8s;
                    if (message.maxProposalsToKeepPerTopic != null && message.hasOwnProperty("maxProposalsToKeepPerTopic"))
                        object.maxProposalsToKeepPerTopic = message.maxProposalsToKeepPerTopic;
                    return object;
                };

                /**
                 * Converts this NetworkEconomics to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.NetworkEconomics
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NetworkEconomics.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NetworkEconomics;
            })();

            v1.RewardEvent = (function() {

                /**
                 * Properties of a RewardEvent.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IRewardEvent
                 * @property {number|Long|null} [dayAfterGenesis] RewardEvent dayAfterGenesis
                 * @property {number|Long|null} [actualTimestampSeconds] RewardEvent actualTimestampSeconds
                 * @property {Array.<ic_nns_common.pb.v1.IProposalId>|null} [settledProposals] RewardEvent settledProposals
                 * @property {number|Long|null} [distributedE8sEquivalent] RewardEvent distributedE8sEquivalent
                 */

                /**
                 * Constructs a new RewardEvent.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a RewardEvent.
                 * @implements IRewardEvent
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IRewardEvent=} [properties] Properties to set
                 */
                function RewardEvent(properties) {
                    this.settledProposals = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RewardEvent dayAfterGenesis.
                 * @member {number|Long} dayAfterGenesis
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @instance
                 */
                RewardEvent.prototype.dayAfterGenesis = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * RewardEvent actualTimestampSeconds.
                 * @member {number|Long} actualTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @instance
                 */
                RewardEvent.prototype.actualTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * RewardEvent settledProposals.
                 * @member {Array.<ic_nns_common.pb.v1.IProposalId>} settledProposals
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @instance
                 */
                RewardEvent.prototype.settledProposals = $util.emptyArray;

                /**
                 * RewardEvent distributedE8sEquivalent.
                 * @member {number|Long} distributedE8sEquivalent
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @instance
                 */
                RewardEvent.prototype.distributedE8sEquivalent = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new RewardEvent instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @static
                 * @param {ic_nns_governance.pb.v1.IRewardEvent=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.RewardEvent} RewardEvent instance
                 */
                RewardEvent.create = function create(properties) {
                    return new RewardEvent(properties);
                };

                /**
                 * Encodes the specified RewardEvent message. Does not implicitly {@link ic_nns_governance.pb.v1.RewardEvent.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @static
                 * @param {ic_nns_governance.pb.v1.IRewardEvent} message RewardEvent message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardEvent.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.dayAfterGenesis != null && Object.hasOwnProperty.call(message, "dayAfterGenesis"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.dayAfterGenesis);
                    if (message.actualTimestampSeconds != null && Object.hasOwnProperty.call(message, "actualTimestampSeconds"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.actualTimestampSeconds);
                    if (message.settledProposals != null && message.settledProposals.length)
                        for (let i = 0; i < message.settledProposals.length; ++i)
                            $root.ic_nns_common.pb.v1.ProposalId.encode(message.settledProposals[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.distributedE8sEquivalent != null && Object.hasOwnProperty.call(message, "distributedE8sEquivalent"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.distributedE8sEquivalent);
                    return writer;
                };

                /**
                 * Encodes the specified RewardEvent message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.RewardEvent.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @static
                 * @param {ic_nns_governance.pb.v1.IRewardEvent} message RewardEvent message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RewardEvent.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RewardEvent message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.RewardEvent} RewardEvent
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardEvent.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.RewardEvent();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.dayAfterGenesis = reader.uint64();
                            break;
                        case 2:
                            message.actualTimestampSeconds = reader.uint64();
                            break;
                        case 3:
                            if (!(message.settledProposals && message.settledProposals.length))
                                message.settledProposals = [];
                            message.settledProposals.push($root.ic_nns_common.pb.v1.ProposalId.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.distributedE8sEquivalent = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RewardEvent message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.RewardEvent} RewardEvent
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RewardEvent.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RewardEvent message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RewardEvent.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.dayAfterGenesis != null && message.hasOwnProperty("dayAfterGenesis"))
                        if (!$util.isInteger(message.dayAfterGenesis) && !(message.dayAfterGenesis && $util.isInteger(message.dayAfterGenesis.low) && $util.isInteger(message.dayAfterGenesis.high)))
                            return "dayAfterGenesis: integer|Long expected";
                    if (message.actualTimestampSeconds != null && message.hasOwnProperty("actualTimestampSeconds"))
                        if (!$util.isInteger(message.actualTimestampSeconds) && !(message.actualTimestampSeconds && $util.isInteger(message.actualTimestampSeconds.low) && $util.isInteger(message.actualTimestampSeconds.high)))
                            return "actualTimestampSeconds: integer|Long expected";
                    if (message.settledProposals != null && message.hasOwnProperty("settledProposals")) {
                        if (!Array.isArray(message.settledProposals))
                            return "settledProposals: array expected";
                        for (let i = 0; i < message.settledProposals.length; ++i) {
                            let error = $root.ic_nns_common.pb.v1.ProposalId.verify(message.settledProposals[i]);
                            if (error)
                                return "settledProposals." + error;
                        }
                    }
                    if (message.distributedE8sEquivalent != null && message.hasOwnProperty("distributedE8sEquivalent"))
                        if (!$util.isInteger(message.distributedE8sEquivalent) && !(message.distributedE8sEquivalent && $util.isInteger(message.distributedE8sEquivalent.low) && $util.isInteger(message.distributedE8sEquivalent.high)))
                            return "distributedE8sEquivalent: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a RewardEvent message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.RewardEvent} RewardEvent
                 */
                RewardEvent.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.RewardEvent)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.RewardEvent();
                    if (object.dayAfterGenesis != null)
                        if ($util.Long)
                            (message.dayAfterGenesis = $util.Long.fromValue(object.dayAfterGenesis)).unsigned = true;
                        else if (typeof object.dayAfterGenesis === "string")
                            message.dayAfterGenesis = parseInt(object.dayAfterGenesis, 10);
                        else if (typeof object.dayAfterGenesis === "number")
                            message.dayAfterGenesis = object.dayAfterGenesis;
                        else if (typeof object.dayAfterGenesis === "object")
                            message.dayAfterGenesis = new $util.LongBits(object.dayAfterGenesis.low >>> 0, object.dayAfterGenesis.high >>> 0).toNumber(true);
                    if (object.actualTimestampSeconds != null)
                        if ($util.Long)
                            (message.actualTimestampSeconds = $util.Long.fromValue(object.actualTimestampSeconds)).unsigned = true;
                        else if (typeof object.actualTimestampSeconds === "string")
                            message.actualTimestampSeconds = parseInt(object.actualTimestampSeconds, 10);
                        else if (typeof object.actualTimestampSeconds === "number")
                            message.actualTimestampSeconds = object.actualTimestampSeconds;
                        else if (typeof object.actualTimestampSeconds === "object")
                            message.actualTimestampSeconds = new $util.LongBits(object.actualTimestampSeconds.low >>> 0, object.actualTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.settledProposals) {
                        if (!Array.isArray(object.settledProposals))
                            throw TypeError(".ic_nns_governance.pb.v1.RewardEvent.settledProposals: array expected");
                        message.settledProposals = [];
                        for (let i = 0; i < object.settledProposals.length; ++i) {
                            if (typeof object.settledProposals[i] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.RewardEvent.settledProposals: object expected");
                            message.settledProposals[i] = $root.ic_nns_common.pb.v1.ProposalId.fromObject(object.settledProposals[i]);
                        }
                    }
                    if (object.distributedE8sEquivalent != null)
                        if ($util.Long)
                            (message.distributedE8sEquivalent = $util.Long.fromValue(object.distributedE8sEquivalent)).unsigned = true;
                        else if (typeof object.distributedE8sEquivalent === "string")
                            message.distributedE8sEquivalent = parseInt(object.distributedE8sEquivalent, 10);
                        else if (typeof object.distributedE8sEquivalent === "number")
                            message.distributedE8sEquivalent = object.distributedE8sEquivalent;
                        else if (typeof object.distributedE8sEquivalent === "object")
                            message.distributedE8sEquivalent = new $util.LongBits(object.distributedE8sEquivalent.low >>> 0, object.distributedE8sEquivalent.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a RewardEvent message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @static
                 * @param {ic_nns_governance.pb.v1.RewardEvent} message RewardEvent
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RewardEvent.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.settledProposals = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.dayAfterGenesis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.dayAfterGenesis = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.actualTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.actualTimestampSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.distributedE8sEquivalent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.distributedE8sEquivalent = options.longs === String ? "0" : 0;
                    }
                    if (message.dayAfterGenesis != null && message.hasOwnProperty("dayAfterGenesis"))
                        if (typeof message.dayAfterGenesis === "number")
                            object.dayAfterGenesis = options.longs === String ? String(message.dayAfterGenesis) : message.dayAfterGenesis;
                        else
                            object.dayAfterGenesis = options.longs === String ? $util.Long.prototype.toString.call(message.dayAfterGenesis) : options.longs === Number ? new $util.LongBits(message.dayAfterGenesis.low >>> 0, message.dayAfterGenesis.high >>> 0).toNumber(true) : message.dayAfterGenesis;
                    if (message.actualTimestampSeconds != null && message.hasOwnProperty("actualTimestampSeconds"))
                        if (typeof message.actualTimestampSeconds === "number")
                            object.actualTimestampSeconds = options.longs === String ? String(message.actualTimestampSeconds) : message.actualTimestampSeconds;
                        else
                            object.actualTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.actualTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.actualTimestampSeconds.low >>> 0, message.actualTimestampSeconds.high >>> 0).toNumber(true) : message.actualTimestampSeconds;
                    if (message.settledProposals && message.settledProposals.length) {
                        object.settledProposals = [];
                        for (let j = 0; j < message.settledProposals.length; ++j)
                            object.settledProposals[j] = $root.ic_nns_common.pb.v1.ProposalId.toObject(message.settledProposals[j], options);
                    }
                    if (message.distributedE8sEquivalent != null && message.hasOwnProperty("distributedE8sEquivalent"))
                        if (typeof message.distributedE8sEquivalent === "number")
                            object.distributedE8sEquivalent = options.longs === String ? String(message.distributedE8sEquivalent) : message.distributedE8sEquivalent;
                        else
                            object.distributedE8sEquivalent = options.longs === String ? $util.Long.prototype.toString.call(message.distributedE8sEquivalent) : options.longs === Number ? new $util.LongBits(message.distributedE8sEquivalent.low >>> 0, message.distributedE8sEquivalent.high >>> 0).toNumber(true) : message.distributedE8sEquivalent;
                    return object;
                };

                /**
                 * Converts this RewardEvent to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.RewardEvent
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RewardEvent.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RewardEvent;
            })();

            v1.Governance = (function() {

                /**
                 * Properties of a Governance.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IGovernance
                 * @property {Object.<string,ic_nns_governance.pb.v1.INeuron>|null} [neurons] Governance neurons
                 * @property {Object.<string,ic_nns_governance.pb.v1.IProposalData>|null} [proposals] Governance proposals
                 * @property {Array.<ic_nns_governance.pb.v1.INeuronStakeTransfer>|null} [toClaimTransfers] Governance toClaimTransfers
                 * @property {number|Long|null} [waitForQuietThresholdSeconds] Governance waitForQuietThresholdSeconds
                 * @property {ic_nns_governance.pb.v1.INetworkEconomics|null} [economics] Governance economics
                 * @property {ic_nns_governance.pb.v1.IRewardEvent|null} [latestRewardEvent] Governance latestRewardEvent
                 * @property {Object.<string,ic_nns_governance.pb.v1.Governance.INeuronInFlightCommand>|null} [inFlightCommands] Governance inFlightCommands
                 * @property {number|Long|null} [genesisTimestampSeconds] Governance genesisTimestampSeconds
                 * @property {Array.<ic_nns_governance.pb.v1.INodeProvider>|null} [nodeProviders] Governance nodeProviders
                 * @property {Object.<string,ic_nns_governance.pb.v1.Neuron.IFollowees>|null} [defaultFollowees] Governance defaultFollowees
                 * @property {number|Long|null} [shortVotingPeriodSeconds] Governance shortVotingPeriodSeconds
                 * @property {ic_nns_governance.pb.v1.Governance.IGovernanceCachedMetrics|null} [metrics] Governance metrics
                 */

                /**
                 * Constructs a new Governance.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a Governance.
                 * @implements IGovernance
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IGovernance=} [properties] Properties to set
                 */
                function Governance(properties) {
                    this.neurons = {};
                    this.proposals = {};
                    this.toClaimTransfers = [];
                    this.inFlightCommands = {};
                    this.nodeProviders = [];
                    this.defaultFollowees = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Governance neurons.
                 * @member {Object.<string,ic_nns_governance.pb.v1.INeuron>} neurons
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.neurons = $util.emptyObject;

                /**
                 * Governance proposals.
                 * @member {Object.<string,ic_nns_governance.pb.v1.IProposalData>} proposals
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.proposals = $util.emptyObject;

                /**
                 * Governance toClaimTransfers.
                 * @member {Array.<ic_nns_governance.pb.v1.INeuronStakeTransfer>} toClaimTransfers
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.toClaimTransfers = $util.emptyArray;

                /**
                 * Governance waitForQuietThresholdSeconds.
                 * @member {number|Long} waitForQuietThresholdSeconds
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.waitForQuietThresholdSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Governance economics.
                 * @member {ic_nns_governance.pb.v1.INetworkEconomics|null|undefined} economics
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.economics = null;

                /**
                 * Governance latestRewardEvent.
                 * @member {ic_nns_governance.pb.v1.IRewardEvent|null|undefined} latestRewardEvent
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.latestRewardEvent = null;

                /**
                 * Governance inFlightCommands.
                 * @member {Object.<string,ic_nns_governance.pb.v1.Governance.INeuronInFlightCommand>} inFlightCommands
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.inFlightCommands = $util.emptyObject;

                /**
                 * Governance genesisTimestampSeconds.
                 * @member {number|Long} genesisTimestampSeconds
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.genesisTimestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Governance nodeProviders.
                 * @member {Array.<ic_nns_governance.pb.v1.INodeProvider>} nodeProviders
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.nodeProviders = $util.emptyArray;

                /**
                 * Governance defaultFollowees.
                 * @member {Object.<string,ic_nns_governance.pb.v1.Neuron.IFollowees>} defaultFollowees
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.defaultFollowees = $util.emptyObject;

                /**
                 * Governance shortVotingPeriodSeconds.
                 * @member {number|Long} shortVotingPeriodSeconds
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.shortVotingPeriodSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Governance metrics.
                 * @member {ic_nns_governance.pb.v1.Governance.IGovernanceCachedMetrics|null|undefined} metrics
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 */
                Governance.prototype.metrics = null;

                /**
                 * Creates a new Governance instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @static
                 * @param {ic_nns_governance.pb.v1.IGovernance=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.Governance} Governance instance
                 */
                Governance.create = function create(properties) {
                    return new Governance(properties);
                };

                /**
                 * Encodes the specified Governance message. Does not implicitly {@link ic_nns_governance.pb.v1.Governance.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @static
                 * @param {ic_nns_governance.pb.v1.IGovernance} message Governance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Governance.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.neurons != null && Object.hasOwnProperty.call(message, "neurons"))
                        for (let keys = Object.keys(message.neurons), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 1 =*/9).fixed64(keys[i]);
                            $root.ic_nns_governance.pb.v1.Neuron.encode(message.neurons[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.proposals != null && Object.hasOwnProperty.call(message, "proposals"))
                        for (let keys = Object.keys(message.proposals), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]);
                            $root.ic_nns_governance.pb.v1.ProposalData.encode(message.proposals[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.toClaimTransfers != null && message.toClaimTransfers.length)
                        for (let i = 0; i < message.toClaimTransfers.length; ++i)
                            $root.ic_nns_governance.pb.v1.NeuronStakeTransfer.encode(message.toClaimTransfers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.waitForQuietThresholdSeconds != null && Object.hasOwnProperty.call(message, "waitForQuietThresholdSeconds"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.waitForQuietThresholdSeconds);
                    if (message.economics != null && Object.hasOwnProperty.call(message, "economics"))
                        $root.ic_nns_governance.pb.v1.NetworkEconomics.encode(message.economics, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.latestRewardEvent != null && Object.hasOwnProperty.call(message, "latestRewardEvent"))
                        $root.ic_nns_governance.pb.v1.RewardEvent.encode(message.latestRewardEvent, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.inFlightCommands != null && Object.hasOwnProperty.call(message, "inFlightCommands"))
                        for (let keys = Object.keys(message.inFlightCommands), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 1 =*/9).fixed64(keys[i]);
                            $root.ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.encode(message.inFlightCommands[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.genesisTimestampSeconds != null && Object.hasOwnProperty.call(message, "genesisTimestampSeconds"))
                        writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.genesisTimestampSeconds);
                    if (message.nodeProviders != null && message.nodeProviders.length)
                        for (let i = 0; i < message.nodeProviders.length; ++i)
                            $root.ic_nns_governance.pb.v1.NodeProvider.encode(message.nodeProviders[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.defaultFollowees != null && Object.hasOwnProperty.call(message, "defaultFollowees"))
                        for (let keys = Object.keys(message.defaultFollowees), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 13, wireType 2 =*/106).fork().uint32(/* id 1, wireType 0 =*/8).int32(keys[i]);
                            $root.ic_nns_governance.pb.v1.Neuron.Followees.encode(message.defaultFollowees[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.shortVotingPeriodSeconds != null && Object.hasOwnProperty.call(message, "shortVotingPeriodSeconds"))
                        writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.shortVotingPeriodSeconds);
                    if (message.metrics != null && Object.hasOwnProperty.call(message, "metrics"))
                        $root.ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics.encode(message.metrics, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Governance message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.Governance.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @static
                 * @param {ic_nns_governance.pb.v1.IGovernance} message Governance message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Governance.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Governance message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.Governance} Governance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Governance.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.Governance(), key, value;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (message.neurons === $util.emptyObject)
                                message.neurons = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.fixed64();
                                    break;
                                case 2:
                                    value = $root.ic_nns_governance.pb.v1.Neuron.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.neurons[typeof key === "object" ? $util.longToHash(key) : key] = value;
                            break;
                        case 2:
                            if (message.proposals === $util.emptyObject)
                                message.proposals = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.uint64();
                                    break;
                                case 2:
                                    value = $root.ic_nns_governance.pb.v1.ProposalData.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.proposals[typeof key === "object" ? $util.longToHash(key) : key] = value;
                            break;
                        case 3:
                            if (!(message.toClaimTransfers && message.toClaimTransfers.length))
                                message.toClaimTransfers = [];
                            message.toClaimTransfers.push($root.ic_nns_governance.pb.v1.NeuronStakeTransfer.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            message.waitForQuietThresholdSeconds = reader.uint64();
                            break;
                        case 8:
                            message.economics = $root.ic_nns_governance.pb.v1.NetworkEconomics.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.latestRewardEvent = $root.ic_nns_governance.pb.v1.RewardEvent.decode(reader, reader.uint32());
                            break;
                        case 10:
                            if (message.inFlightCommands === $util.emptyObject)
                                message.inFlightCommands = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.fixed64();
                                    break;
                                case 2:
                                    value = $root.ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.inFlightCommands[typeof key === "object" ? $util.longToHash(key) : key] = value;
                            break;
                        case 11:
                            message.genesisTimestampSeconds = reader.uint64();
                            break;
                        case 12:
                            if (!(message.nodeProviders && message.nodeProviders.length))
                                message.nodeProviders = [];
                            message.nodeProviders.push($root.ic_nns_governance.pb.v1.NodeProvider.decode(reader, reader.uint32()));
                            break;
                        case 13:
                            if (message.defaultFollowees === $util.emptyObject)
                                message.defaultFollowees = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.int32();
                                    break;
                                case 2:
                                    value = $root.ic_nns_governance.pb.v1.Neuron.Followees.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.defaultFollowees[key] = value;
                            break;
                        case 14:
                            message.shortVotingPeriodSeconds = reader.uint64();
                            break;
                        case 15:
                            message.metrics = $root.ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Governance message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.Governance} Governance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Governance.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Governance message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Governance.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.neurons != null && message.hasOwnProperty("neurons")) {
                        if (!$util.isObject(message.neurons))
                            return "neurons: object expected";
                        let key = Object.keys(message.neurons);
                        for (let i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "neurons: integer|Long key{k:fixed64} expected";
                            {
                                let error = $root.ic_nns_governance.pb.v1.Neuron.verify(message.neurons[key[i]]);
                                if (error)
                                    return "neurons." + error;
                            }
                        }
                    }
                    if (message.proposals != null && message.hasOwnProperty("proposals")) {
                        if (!$util.isObject(message.proposals))
                            return "proposals: object expected";
                        let key = Object.keys(message.proposals);
                        for (let i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "proposals: integer|Long key{k:uint64} expected";
                            {
                                let error = $root.ic_nns_governance.pb.v1.ProposalData.verify(message.proposals[key[i]]);
                                if (error)
                                    return "proposals." + error;
                            }
                        }
                    }
                    if (message.toClaimTransfers != null && message.hasOwnProperty("toClaimTransfers")) {
                        if (!Array.isArray(message.toClaimTransfers))
                            return "toClaimTransfers: array expected";
                        for (let i = 0; i < message.toClaimTransfers.length; ++i) {
                            let error = $root.ic_nns_governance.pb.v1.NeuronStakeTransfer.verify(message.toClaimTransfers[i]);
                            if (error)
                                return "toClaimTransfers." + error;
                        }
                    }
                    if (message.waitForQuietThresholdSeconds != null && message.hasOwnProperty("waitForQuietThresholdSeconds"))
                        if (!$util.isInteger(message.waitForQuietThresholdSeconds) && !(message.waitForQuietThresholdSeconds && $util.isInteger(message.waitForQuietThresholdSeconds.low) && $util.isInteger(message.waitForQuietThresholdSeconds.high)))
                            return "waitForQuietThresholdSeconds: integer|Long expected";
                    if (message.economics != null && message.hasOwnProperty("economics")) {
                        let error = $root.ic_nns_governance.pb.v1.NetworkEconomics.verify(message.economics);
                        if (error)
                            return "economics." + error;
                    }
                    if (message.latestRewardEvent != null && message.hasOwnProperty("latestRewardEvent")) {
                        let error = $root.ic_nns_governance.pb.v1.RewardEvent.verify(message.latestRewardEvent);
                        if (error)
                            return "latestRewardEvent." + error;
                    }
                    if (message.inFlightCommands != null && message.hasOwnProperty("inFlightCommands")) {
                        if (!$util.isObject(message.inFlightCommands))
                            return "inFlightCommands: object expected";
                        let key = Object.keys(message.inFlightCommands);
                        for (let i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "inFlightCommands: integer|Long key{k:fixed64} expected";
                            {
                                let error = $root.ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.verify(message.inFlightCommands[key[i]]);
                                if (error)
                                    return "inFlightCommands." + error;
                            }
                        }
                    }
                    if (message.genesisTimestampSeconds != null && message.hasOwnProperty("genesisTimestampSeconds"))
                        if (!$util.isInteger(message.genesisTimestampSeconds) && !(message.genesisTimestampSeconds && $util.isInteger(message.genesisTimestampSeconds.low) && $util.isInteger(message.genesisTimestampSeconds.high)))
                            return "genesisTimestampSeconds: integer|Long expected";
                    if (message.nodeProviders != null && message.hasOwnProperty("nodeProviders")) {
                        if (!Array.isArray(message.nodeProviders))
                            return "nodeProviders: array expected";
                        for (let i = 0; i < message.nodeProviders.length; ++i) {
                            let error = $root.ic_nns_governance.pb.v1.NodeProvider.verify(message.nodeProviders[i]);
                            if (error)
                                return "nodeProviders." + error;
                        }
                    }
                    if (message.defaultFollowees != null && message.hasOwnProperty("defaultFollowees")) {
                        if (!$util.isObject(message.defaultFollowees))
                            return "defaultFollowees: object expected";
                        let key = Object.keys(message.defaultFollowees);
                        for (let i = 0; i < key.length; ++i) {
                            if (!$util.key32Re.test(key[i]))
                                return "defaultFollowees: integer key{k:int32} expected";
                            {
                                let error = $root.ic_nns_governance.pb.v1.Neuron.Followees.verify(message.defaultFollowees[key[i]]);
                                if (error)
                                    return "defaultFollowees." + error;
                            }
                        }
                    }
                    if (message.shortVotingPeriodSeconds != null && message.hasOwnProperty("shortVotingPeriodSeconds"))
                        if (!$util.isInteger(message.shortVotingPeriodSeconds) && !(message.shortVotingPeriodSeconds && $util.isInteger(message.shortVotingPeriodSeconds.low) && $util.isInteger(message.shortVotingPeriodSeconds.high)))
                            return "shortVotingPeriodSeconds: integer|Long expected";
                    if (message.metrics != null && message.hasOwnProperty("metrics")) {
                        let error = $root.ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics.verify(message.metrics);
                        if (error)
                            return "metrics." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Governance message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.Governance} Governance
                 */
                Governance.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.Governance)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.Governance();
                    if (object.neurons) {
                        if (typeof object.neurons !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Governance.neurons: object expected");
                        message.neurons = {};
                        for (let keys = Object.keys(object.neurons), i = 0; i < keys.length; ++i) {
                            if (typeof object.neurons[keys[i]] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.neurons: object expected");
                            message.neurons[keys[i]] = $root.ic_nns_governance.pb.v1.Neuron.fromObject(object.neurons[keys[i]]);
                        }
                    }
                    if (object.proposals) {
                        if (typeof object.proposals !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Governance.proposals: object expected");
                        message.proposals = {};
                        for (let keys = Object.keys(object.proposals), i = 0; i < keys.length; ++i) {
                            if (typeof object.proposals[keys[i]] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.proposals: object expected");
                            message.proposals[keys[i]] = $root.ic_nns_governance.pb.v1.ProposalData.fromObject(object.proposals[keys[i]]);
                        }
                    }
                    if (object.toClaimTransfers) {
                        if (!Array.isArray(object.toClaimTransfers))
                            throw TypeError(".ic_nns_governance.pb.v1.Governance.toClaimTransfers: array expected");
                        message.toClaimTransfers = [];
                        for (let i = 0; i < object.toClaimTransfers.length; ++i) {
                            if (typeof object.toClaimTransfers[i] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.toClaimTransfers: object expected");
                            message.toClaimTransfers[i] = $root.ic_nns_governance.pb.v1.NeuronStakeTransfer.fromObject(object.toClaimTransfers[i]);
                        }
                    }
                    if (object.waitForQuietThresholdSeconds != null)
                        if ($util.Long)
                            (message.waitForQuietThresholdSeconds = $util.Long.fromValue(object.waitForQuietThresholdSeconds)).unsigned = true;
                        else if (typeof object.waitForQuietThresholdSeconds === "string")
                            message.waitForQuietThresholdSeconds = parseInt(object.waitForQuietThresholdSeconds, 10);
                        else if (typeof object.waitForQuietThresholdSeconds === "number")
                            message.waitForQuietThresholdSeconds = object.waitForQuietThresholdSeconds;
                        else if (typeof object.waitForQuietThresholdSeconds === "object")
                            message.waitForQuietThresholdSeconds = new $util.LongBits(object.waitForQuietThresholdSeconds.low >>> 0, object.waitForQuietThresholdSeconds.high >>> 0).toNumber(true);
                    if (object.economics != null) {
                        if (typeof object.economics !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Governance.economics: object expected");
                        message.economics = $root.ic_nns_governance.pb.v1.NetworkEconomics.fromObject(object.economics);
                    }
                    if (object.latestRewardEvent != null) {
                        if (typeof object.latestRewardEvent !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Governance.latestRewardEvent: object expected");
                        message.latestRewardEvent = $root.ic_nns_governance.pb.v1.RewardEvent.fromObject(object.latestRewardEvent);
                    }
                    if (object.inFlightCommands) {
                        if (typeof object.inFlightCommands !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Governance.inFlightCommands: object expected");
                        message.inFlightCommands = {};
                        for (let keys = Object.keys(object.inFlightCommands), i = 0; i < keys.length; ++i) {
                            if (typeof object.inFlightCommands[keys[i]] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.inFlightCommands: object expected");
                            message.inFlightCommands[keys[i]] = $root.ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.fromObject(object.inFlightCommands[keys[i]]);
                        }
                    }
                    if (object.genesisTimestampSeconds != null)
                        if ($util.Long)
                            (message.genesisTimestampSeconds = $util.Long.fromValue(object.genesisTimestampSeconds)).unsigned = true;
                        else if (typeof object.genesisTimestampSeconds === "string")
                            message.genesisTimestampSeconds = parseInt(object.genesisTimestampSeconds, 10);
                        else if (typeof object.genesisTimestampSeconds === "number")
                            message.genesisTimestampSeconds = object.genesisTimestampSeconds;
                        else if (typeof object.genesisTimestampSeconds === "object")
                            message.genesisTimestampSeconds = new $util.LongBits(object.genesisTimestampSeconds.low >>> 0, object.genesisTimestampSeconds.high >>> 0).toNumber(true);
                    if (object.nodeProviders) {
                        if (!Array.isArray(object.nodeProviders))
                            throw TypeError(".ic_nns_governance.pb.v1.Governance.nodeProviders: array expected");
                        message.nodeProviders = [];
                        for (let i = 0; i < object.nodeProviders.length; ++i) {
                            if (typeof object.nodeProviders[i] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.nodeProviders: object expected");
                            message.nodeProviders[i] = $root.ic_nns_governance.pb.v1.NodeProvider.fromObject(object.nodeProviders[i]);
                        }
                    }
                    if (object.defaultFollowees) {
                        if (typeof object.defaultFollowees !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Governance.defaultFollowees: object expected");
                        message.defaultFollowees = {};
                        for (let keys = Object.keys(object.defaultFollowees), i = 0; i < keys.length; ++i) {
                            if (typeof object.defaultFollowees[keys[i]] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.defaultFollowees: object expected");
                            message.defaultFollowees[keys[i]] = $root.ic_nns_governance.pb.v1.Neuron.Followees.fromObject(object.defaultFollowees[keys[i]]);
                        }
                    }
                    if (object.shortVotingPeriodSeconds != null)
                        if ($util.Long)
                            (message.shortVotingPeriodSeconds = $util.Long.fromValue(object.shortVotingPeriodSeconds)).unsigned = true;
                        else if (typeof object.shortVotingPeriodSeconds === "string")
                            message.shortVotingPeriodSeconds = parseInt(object.shortVotingPeriodSeconds, 10);
                        else if (typeof object.shortVotingPeriodSeconds === "number")
                            message.shortVotingPeriodSeconds = object.shortVotingPeriodSeconds;
                        else if (typeof object.shortVotingPeriodSeconds === "object")
                            message.shortVotingPeriodSeconds = new $util.LongBits(object.shortVotingPeriodSeconds.low >>> 0, object.shortVotingPeriodSeconds.high >>> 0).toNumber(true);
                    if (object.metrics != null) {
                        if (typeof object.metrics !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.Governance.metrics: object expected");
                        message.metrics = $root.ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics.fromObject(object.metrics);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Governance message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @static
                 * @param {ic_nns_governance.pb.v1.Governance} message Governance
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Governance.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.toClaimTransfers = [];
                        object.nodeProviders = [];
                    }
                    if (options.objects || options.defaults) {
                        object.neurons = {};
                        object.proposals = {};
                        object.inFlightCommands = {};
                        object.defaultFollowees = {};
                    }
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.waitForQuietThresholdSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.waitForQuietThresholdSeconds = options.longs === String ? "0" : 0;
                        object.economics = null;
                        object.latestRewardEvent = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.genesisTimestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.genesisTimestampSeconds = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.shortVotingPeriodSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.shortVotingPeriodSeconds = options.longs === String ? "0" : 0;
                        object.metrics = null;
                    }
                    let keys2;
                    if (message.neurons && (keys2 = Object.keys(message.neurons)).length) {
                        object.neurons = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.neurons[keys2[j]] = $root.ic_nns_governance.pb.v1.Neuron.toObject(message.neurons[keys2[j]], options);
                    }
                    if (message.proposals && (keys2 = Object.keys(message.proposals)).length) {
                        object.proposals = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.proposals[keys2[j]] = $root.ic_nns_governance.pb.v1.ProposalData.toObject(message.proposals[keys2[j]], options);
                    }
                    if (message.toClaimTransfers && message.toClaimTransfers.length) {
                        object.toClaimTransfers = [];
                        for (let j = 0; j < message.toClaimTransfers.length; ++j)
                            object.toClaimTransfers[j] = $root.ic_nns_governance.pb.v1.NeuronStakeTransfer.toObject(message.toClaimTransfers[j], options);
                    }
                    if (message.waitForQuietThresholdSeconds != null && message.hasOwnProperty("waitForQuietThresholdSeconds"))
                        if (typeof message.waitForQuietThresholdSeconds === "number")
                            object.waitForQuietThresholdSeconds = options.longs === String ? String(message.waitForQuietThresholdSeconds) : message.waitForQuietThresholdSeconds;
                        else
                            object.waitForQuietThresholdSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.waitForQuietThresholdSeconds) : options.longs === Number ? new $util.LongBits(message.waitForQuietThresholdSeconds.low >>> 0, message.waitForQuietThresholdSeconds.high >>> 0).toNumber(true) : message.waitForQuietThresholdSeconds;
                    if (message.economics != null && message.hasOwnProperty("economics"))
                        object.economics = $root.ic_nns_governance.pb.v1.NetworkEconomics.toObject(message.economics, options);
                    if (message.latestRewardEvent != null && message.hasOwnProperty("latestRewardEvent"))
                        object.latestRewardEvent = $root.ic_nns_governance.pb.v1.RewardEvent.toObject(message.latestRewardEvent, options);
                    if (message.inFlightCommands && (keys2 = Object.keys(message.inFlightCommands)).length) {
                        object.inFlightCommands = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.inFlightCommands[keys2[j]] = $root.ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.toObject(message.inFlightCommands[keys2[j]], options);
                    }
                    if (message.genesisTimestampSeconds != null && message.hasOwnProperty("genesisTimestampSeconds"))
                        if (typeof message.genesisTimestampSeconds === "number")
                            object.genesisTimestampSeconds = options.longs === String ? String(message.genesisTimestampSeconds) : message.genesisTimestampSeconds;
                        else
                            object.genesisTimestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.genesisTimestampSeconds) : options.longs === Number ? new $util.LongBits(message.genesisTimestampSeconds.low >>> 0, message.genesisTimestampSeconds.high >>> 0).toNumber(true) : message.genesisTimestampSeconds;
                    if (message.nodeProviders && message.nodeProviders.length) {
                        object.nodeProviders = [];
                        for (let j = 0; j < message.nodeProviders.length; ++j)
                            object.nodeProviders[j] = $root.ic_nns_governance.pb.v1.NodeProvider.toObject(message.nodeProviders[j], options);
                    }
                    if (message.defaultFollowees && (keys2 = Object.keys(message.defaultFollowees)).length) {
                        object.defaultFollowees = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.defaultFollowees[keys2[j]] = $root.ic_nns_governance.pb.v1.Neuron.Followees.toObject(message.defaultFollowees[keys2[j]], options);
                    }
                    if (message.shortVotingPeriodSeconds != null && message.hasOwnProperty("shortVotingPeriodSeconds"))
                        if (typeof message.shortVotingPeriodSeconds === "number")
                            object.shortVotingPeriodSeconds = options.longs === String ? String(message.shortVotingPeriodSeconds) : message.shortVotingPeriodSeconds;
                        else
                            object.shortVotingPeriodSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.shortVotingPeriodSeconds) : options.longs === Number ? new $util.LongBits(message.shortVotingPeriodSeconds.low >>> 0, message.shortVotingPeriodSeconds.high >>> 0).toNumber(true) : message.shortVotingPeriodSeconds;
                    if (message.metrics != null && message.hasOwnProperty("metrics"))
                        object.metrics = $root.ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics.toObject(message.metrics, options);
                    return object;
                };

                /**
                 * Converts this Governance to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.Governance
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Governance.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Governance.NeuronInFlightCommand = (function() {

                    /**
                     * Properties of a NeuronInFlightCommand.
                     * @memberof ic_nns_governance.pb.v1.Governance
                     * @interface INeuronInFlightCommand
                     * @property {number|Long|null} [timestamp] NeuronInFlightCommand timestamp
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.IDisburse|null} [disburse] NeuronInFlightCommand disburse
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.ISplit|null} [split] NeuronInFlightCommand split
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.ISpawn|null} [spawn] NeuronInFlightCommand spawn
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.IDisburseToNeuron|null} [disburseToNeuron] NeuronInFlightCommand disburseToNeuron
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.IMergeMaturity|null} [mergeMaturity] NeuronInFlightCommand mergeMaturity
                     * @property {ic_nns_governance.pb.v1.ManageNeuron.IClaimOrRefresh|null} [claimOrRefreshNeuron] NeuronInFlightCommand claimOrRefreshNeuron
                     */

                    /**
                     * Constructs a new NeuronInFlightCommand.
                     * @memberof ic_nns_governance.pb.v1.Governance
                     * @classdesc Represents a NeuronInFlightCommand.
                     * @implements INeuronInFlightCommand
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.Governance.INeuronInFlightCommand=} [properties] Properties to set
                     */
                    function NeuronInFlightCommand(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * NeuronInFlightCommand timestamp.
                     * @member {number|Long} timestamp
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @instance
                     */
                    NeuronInFlightCommand.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * NeuronInFlightCommand disburse.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.IDisburse|null|undefined} disburse
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @instance
                     */
                    NeuronInFlightCommand.prototype.disburse = null;

                    /**
                     * NeuronInFlightCommand split.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.ISplit|null|undefined} split
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @instance
                     */
                    NeuronInFlightCommand.prototype.split = null;

                    /**
                     * NeuronInFlightCommand spawn.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.ISpawn|null|undefined} spawn
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @instance
                     */
                    NeuronInFlightCommand.prototype.spawn = null;

                    /**
                     * NeuronInFlightCommand disburseToNeuron.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.IDisburseToNeuron|null|undefined} disburseToNeuron
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @instance
                     */
                    NeuronInFlightCommand.prototype.disburseToNeuron = null;

                    /**
                     * NeuronInFlightCommand mergeMaturity.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.IMergeMaturity|null|undefined} mergeMaturity
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @instance
                     */
                    NeuronInFlightCommand.prototype.mergeMaturity = null;

                    /**
                     * NeuronInFlightCommand claimOrRefreshNeuron.
                     * @member {ic_nns_governance.pb.v1.ManageNeuron.IClaimOrRefresh|null|undefined} claimOrRefreshNeuron
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @instance
                     */
                    NeuronInFlightCommand.prototype.claimOrRefreshNeuron = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * NeuronInFlightCommand command.
                     * @member {"disburse"|"split"|"spawn"|"disburseToNeuron"|"mergeMaturity"|"claimOrRefreshNeuron"|undefined} command
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @instance
                     */
                    Object.defineProperty(NeuronInFlightCommand.prototype, "command", {
                        get: $util.oneOfGetter($oneOfFields = ["disburse", "split", "spawn", "disburseToNeuron", "mergeMaturity", "claimOrRefreshNeuron"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new NeuronInFlightCommand instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @static
                     * @param {ic_nns_governance.pb.v1.Governance.INeuronInFlightCommand=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand} NeuronInFlightCommand instance
                     */
                    NeuronInFlightCommand.create = function create(properties) {
                        return new NeuronInFlightCommand(properties);
                    };

                    /**
                     * Encodes the specified NeuronInFlightCommand message. Does not implicitly {@link ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @static
                     * @param {ic_nns_governance.pb.v1.Governance.INeuronInFlightCommand} message NeuronInFlightCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NeuronInFlightCommand.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestamp);
                        if (message.disburse != null && Object.hasOwnProperty.call(message, "disburse"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.encode(message.disburse, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.split != null && Object.hasOwnProperty.call(message, "split"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.Split.encode(message.split, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.spawn != null && Object.hasOwnProperty.call(message, "spawn"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn.encode(message.spawn, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.disburseToNeuron != null && Object.hasOwnProperty.call(message, "disburseToNeuron"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.encode(message.disburseToNeuron, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.mergeMaturity != null && Object.hasOwnProperty.call(message, "mergeMaturity"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.encode(message.mergeMaturity, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.claimOrRefreshNeuron != null && Object.hasOwnProperty.call(message, "claimOrRefreshNeuron"))
                            $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.encode(message.claimOrRefreshNeuron, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified NeuronInFlightCommand message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @static
                     * @param {ic_nns_governance.pb.v1.Governance.INeuronInFlightCommand} message NeuronInFlightCommand message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NeuronInFlightCommand.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a NeuronInFlightCommand message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand} NeuronInFlightCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NeuronInFlightCommand.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.timestamp = reader.uint64();
                                break;
                            case 2:
                                message.disburse = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.split = $root.ic_nns_governance.pb.v1.ManageNeuron.Split.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.spawn = $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.disburseToNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.mergeMaturity = $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.claimOrRefreshNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a NeuronInFlightCommand message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand} NeuronInFlightCommand
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NeuronInFlightCommand.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a NeuronInFlightCommand message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NeuronInFlightCommand.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                                return "timestamp: integer|Long expected";
                        if (message.disburse != null && message.hasOwnProperty("disburse")) {
                            properties.command = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.verify(message.disburse);
                                if (error)
                                    return "disburse." + error;
                            }
                        }
                        if (message.split != null && message.hasOwnProperty("split")) {
                            if (properties.command === 1)
                                return "command: multiple values";
                            properties.command = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.Split.verify(message.split);
                                if (error)
                                    return "split." + error;
                            }
                        }
                        if (message.spawn != null && message.hasOwnProperty("spawn")) {
                            if (properties.command === 1)
                                return "command: multiple values";
                            properties.command = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn.verify(message.spawn);
                                if (error)
                                    return "spawn." + error;
                            }
                        }
                        if (message.disburseToNeuron != null && message.hasOwnProperty("disburseToNeuron")) {
                            if (properties.command === 1)
                                return "command: multiple values";
                            properties.command = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.verify(message.disburseToNeuron);
                                if (error)
                                    return "disburseToNeuron." + error;
                            }
                        }
                        if (message.mergeMaturity != null && message.hasOwnProperty("mergeMaturity")) {
                            if (properties.command === 1)
                                return "command: multiple values";
                            properties.command = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.verify(message.mergeMaturity);
                                if (error)
                                    return "mergeMaturity." + error;
                            }
                        }
                        if (message.claimOrRefreshNeuron != null && message.hasOwnProperty("claimOrRefreshNeuron")) {
                            if (properties.command === 1)
                                return "command: multiple values";
                            properties.command = 1;
                            {
                                let error = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.verify(message.claimOrRefreshNeuron);
                                if (error)
                                    return "claimOrRefreshNeuron." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a NeuronInFlightCommand message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand} NeuronInFlightCommand
                     */
                    NeuronInFlightCommand.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand();
                        if (object.timestamp != null)
                            if ($util.Long)
                                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                            else if (typeof object.timestamp === "string")
                                message.timestamp = parseInt(object.timestamp, 10);
                            else if (typeof object.timestamp === "number")
                                message.timestamp = object.timestamp;
                            else if (typeof object.timestamp === "object")
                                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                        if (object.disburse != null) {
                            if (typeof object.disburse !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.disburse: object expected");
                            message.disburse = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.fromObject(object.disburse);
                        }
                        if (object.split != null) {
                            if (typeof object.split !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.split: object expected");
                            message.split = $root.ic_nns_governance.pb.v1.ManageNeuron.Split.fromObject(object.split);
                        }
                        if (object.spawn != null) {
                            if (typeof object.spawn !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.spawn: object expected");
                            message.spawn = $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn.fromObject(object.spawn);
                        }
                        if (object.disburseToNeuron != null) {
                            if (typeof object.disburseToNeuron !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.disburseToNeuron: object expected");
                            message.disburseToNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.fromObject(object.disburseToNeuron);
                        }
                        if (object.mergeMaturity != null) {
                            if (typeof object.mergeMaturity !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.mergeMaturity: object expected");
                            message.mergeMaturity = $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.fromObject(object.mergeMaturity);
                        }
                        if (object.claimOrRefreshNeuron != null) {
                            if (typeof object.claimOrRefreshNeuron !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand.claimOrRefreshNeuron: object expected");
                            message.claimOrRefreshNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.fromObject(object.claimOrRefreshNeuron);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a NeuronInFlightCommand message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @static
                     * @param {ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand} message NeuronInFlightCommand
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NeuronInFlightCommand.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestamp = options.longs === String ? "0" : 0;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            if (typeof message.timestamp === "number")
                                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                            else
                                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                        if (message.disburse != null && message.hasOwnProperty("disburse")) {
                            object.disburse = $root.ic_nns_governance.pb.v1.ManageNeuron.Disburse.toObject(message.disburse, options);
                            if (options.oneofs)
                                object.command = "disburse";
                        }
                        if (message.split != null && message.hasOwnProperty("split")) {
                            object.split = $root.ic_nns_governance.pb.v1.ManageNeuron.Split.toObject(message.split, options);
                            if (options.oneofs)
                                object.command = "split";
                        }
                        if (message.spawn != null && message.hasOwnProperty("spawn")) {
                            object.spawn = $root.ic_nns_governance.pb.v1.ManageNeuron.Spawn.toObject(message.spawn, options);
                            if (options.oneofs)
                                object.command = "spawn";
                        }
                        if (message.disburseToNeuron != null && message.hasOwnProperty("disburseToNeuron")) {
                            object.disburseToNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.DisburseToNeuron.toObject(message.disburseToNeuron, options);
                            if (options.oneofs)
                                object.command = "disburseToNeuron";
                        }
                        if (message.mergeMaturity != null && message.hasOwnProperty("mergeMaturity")) {
                            object.mergeMaturity = $root.ic_nns_governance.pb.v1.ManageNeuron.MergeMaturity.toObject(message.mergeMaturity, options);
                            if (options.oneofs)
                                object.command = "mergeMaturity";
                        }
                        if (message.claimOrRefreshNeuron != null && message.hasOwnProperty("claimOrRefreshNeuron")) {
                            object.claimOrRefreshNeuron = $root.ic_nns_governance.pb.v1.ManageNeuron.ClaimOrRefresh.toObject(message.claimOrRefreshNeuron, options);
                            if (options.oneofs)
                                object.command = "claimOrRefreshNeuron";
                        }
                        return object;
                    };

                    /**
                     * Converts this NeuronInFlightCommand to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.Governance.NeuronInFlightCommand
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NeuronInFlightCommand.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return NeuronInFlightCommand;
                })();

                Governance.GovernanceCachedMetrics = (function() {

                    /**
                     * Properties of a GovernanceCachedMetrics.
                     * @memberof ic_nns_governance.pb.v1.Governance
                     * @interface IGovernanceCachedMetrics
                     * @property {number|Long|null} [timestampSeconds] GovernanceCachedMetrics timestampSeconds
                     * @property {number|Long|null} [totalSupplyIcp] GovernanceCachedMetrics totalSupplyIcp
                     * @property {number|Long|null} [dissolvingNeuronsCount] GovernanceCachedMetrics dissolvingNeuronsCount
                     * @property {Object.<string,number>|null} [dissolvingNeuronsE8sBuckets] GovernanceCachedMetrics dissolvingNeuronsE8sBuckets
                     * @property {Object.<string,number|Long>|null} [dissolvingNeuronsCountBuckets] GovernanceCachedMetrics dissolvingNeuronsCountBuckets
                     * @property {number|Long|null} [notDissolvingNeuronsCount] GovernanceCachedMetrics notDissolvingNeuronsCount
                     * @property {Object.<string,number>|null} [notDissolvingNeuronsE8sBuckets] GovernanceCachedMetrics notDissolvingNeuronsE8sBuckets
                     * @property {Object.<string,number|Long>|null} [notDissolvingNeuronsCountBuckets] GovernanceCachedMetrics notDissolvingNeuronsCountBuckets
                     * @property {number|Long|null} [dissolvedNeuronsCount] GovernanceCachedMetrics dissolvedNeuronsCount
                     * @property {number|Long|null} [dissolvedNeuronsE8s] GovernanceCachedMetrics dissolvedNeuronsE8s
                     * @property {number|Long|null} [garbageCollectableNeuronsCount] GovernanceCachedMetrics garbageCollectableNeuronsCount
                     * @property {number|Long|null} [neuronsWithInvalidStakeCount] GovernanceCachedMetrics neuronsWithInvalidStakeCount
                     * @property {number|Long|null} [totalStakedE8s] GovernanceCachedMetrics totalStakedE8s
                     * @property {number|Long|null} [neuronsWithLessThan_6MonthsDissolveDelayCount] GovernanceCachedMetrics neuronsWithLessThan_6MonthsDissolveDelayCount
                     * @property {number|Long|null} [neuronsWithLessThan_6MonthsDissolveDelayE8s] GovernanceCachedMetrics neuronsWithLessThan_6MonthsDissolveDelayE8s
                     * @property {number|Long|null} [communityFundTotalStakedE8s] GovernanceCachedMetrics communityFundTotalStakedE8s
                     */

                    /**
                     * Constructs a new GovernanceCachedMetrics.
                     * @memberof ic_nns_governance.pb.v1.Governance
                     * @classdesc Represents a GovernanceCachedMetrics.
                     * @implements IGovernanceCachedMetrics
                     * @constructor
                     * @param {ic_nns_governance.pb.v1.Governance.IGovernanceCachedMetrics=} [properties] Properties to set
                     */
                    function GovernanceCachedMetrics(properties) {
                        this.dissolvingNeuronsE8sBuckets = {};
                        this.dissolvingNeuronsCountBuckets = {};
                        this.notDissolvingNeuronsE8sBuckets = {};
                        this.notDissolvingNeuronsCountBuckets = {};
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GovernanceCachedMetrics timestampSeconds.
                     * @member {number|Long} timestampSeconds
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.timestampSeconds = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * GovernanceCachedMetrics totalSupplyIcp.
                     * @member {number|Long} totalSupplyIcp
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.totalSupplyIcp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * GovernanceCachedMetrics dissolvingNeuronsCount.
                     * @member {number|Long} dissolvingNeuronsCount
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.dissolvingNeuronsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * GovernanceCachedMetrics dissolvingNeuronsE8sBuckets.
                     * @member {Object.<string,number>} dissolvingNeuronsE8sBuckets
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.dissolvingNeuronsE8sBuckets = $util.emptyObject;

                    /**
                     * GovernanceCachedMetrics dissolvingNeuronsCountBuckets.
                     * @member {Object.<string,number|Long>} dissolvingNeuronsCountBuckets
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.dissolvingNeuronsCountBuckets = $util.emptyObject;

                    /**
                     * GovernanceCachedMetrics notDissolvingNeuronsCount.
                     * @member {number|Long} notDissolvingNeuronsCount
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.notDissolvingNeuronsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * GovernanceCachedMetrics notDissolvingNeuronsE8sBuckets.
                     * @member {Object.<string,number>} notDissolvingNeuronsE8sBuckets
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.notDissolvingNeuronsE8sBuckets = $util.emptyObject;

                    /**
                     * GovernanceCachedMetrics notDissolvingNeuronsCountBuckets.
                     * @member {Object.<string,number|Long>} notDissolvingNeuronsCountBuckets
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.notDissolvingNeuronsCountBuckets = $util.emptyObject;

                    /**
                     * GovernanceCachedMetrics dissolvedNeuronsCount.
                     * @member {number|Long} dissolvedNeuronsCount
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.dissolvedNeuronsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * GovernanceCachedMetrics dissolvedNeuronsE8s.
                     * @member {number|Long} dissolvedNeuronsE8s
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.dissolvedNeuronsE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * GovernanceCachedMetrics garbageCollectableNeuronsCount.
                     * @member {number|Long} garbageCollectableNeuronsCount
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.garbageCollectableNeuronsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * GovernanceCachedMetrics neuronsWithInvalidStakeCount.
                     * @member {number|Long} neuronsWithInvalidStakeCount
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.neuronsWithInvalidStakeCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * GovernanceCachedMetrics totalStakedE8s.
                     * @member {number|Long} totalStakedE8s
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.totalStakedE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * GovernanceCachedMetrics neuronsWithLessThan_6MonthsDissolveDelayCount.
                     * @member {number|Long} neuronsWithLessThan_6MonthsDissolveDelayCount
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.neuronsWithLessThan_6MonthsDissolveDelayCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * GovernanceCachedMetrics neuronsWithLessThan_6MonthsDissolveDelayE8s.
                     * @member {number|Long} neuronsWithLessThan_6MonthsDissolveDelayE8s
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.neuronsWithLessThan_6MonthsDissolveDelayE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * GovernanceCachedMetrics communityFundTotalStakedE8s.
                     * @member {number|Long} communityFundTotalStakedE8s
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     */
                    GovernanceCachedMetrics.prototype.communityFundTotalStakedE8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new GovernanceCachedMetrics instance using the specified properties.
                     * @function create
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @static
                     * @param {ic_nns_governance.pb.v1.Governance.IGovernanceCachedMetrics=} [properties] Properties to set
                     * @returns {ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics} GovernanceCachedMetrics instance
                     */
                    GovernanceCachedMetrics.create = function create(properties) {
                        return new GovernanceCachedMetrics(properties);
                    };

                    /**
                     * Encodes the specified GovernanceCachedMetrics message. Does not implicitly {@link ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics.verify|verify} messages.
                     * @function encode
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @static
                     * @param {ic_nns_governance.pb.v1.Governance.IGovernanceCachedMetrics} message GovernanceCachedMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GovernanceCachedMetrics.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.timestampSeconds != null && Object.hasOwnProperty.call(message, "timestampSeconds"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestampSeconds);
                        if (message.totalSupplyIcp != null && Object.hasOwnProperty.call(message, "totalSupplyIcp"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.totalSupplyIcp);
                        if (message.dissolvingNeuronsCount != null && Object.hasOwnProperty.call(message, "dissolvingNeuronsCount"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.dissolvingNeuronsCount);
                        if (message.dissolvingNeuronsE8sBuckets != null && Object.hasOwnProperty.call(message, "dissolvingNeuronsE8sBuckets"))
                            for (let keys = Object.keys(message.dissolvingNeuronsE8sBuckets), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]).uint32(/* id 2, wireType 1 =*/17).double(message.dissolvingNeuronsE8sBuckets[keys[i]]).ldelim();
                        if (message.dissolvingNeuronsCountBuckets != null && Object.hasOwnProperty.call(message, "dissolvingNeuronsCountBuckets"))
                            for (let keys = Object.keys(message.dissolvingNeuronsCountBuckets), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint64(message.dissolvingNeuronsCountBuckets[keys[i]]).ldelim();
                        if (message.notDissolvingNeuronsCount != null && Object.hasOwnProperty.call(message, "notDissolvingNeuronsCount"))
                            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.notDissolvingNeuronsCount);
                        if (message.notDissolvingNeuronsE8sBuckets != null && Object.hasOwnProperty.call(message, "notDissolvingNeuronsE8sBuckets"))
                            for (let keys = Object.keys(message.notDissolvingNeuronsE8sBuckets), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]).uint32(/* id 2, wireType 1 =*/17).double(message.notDissolvingNeuronsE8sBuckets[keys[i]]).ldelim();
                        if (message.notDissolvingNeuronsCountBuckets != null && Object.hasOwnProperty.call(message, "notDissolvingNeuronsCountBuckets"))
                            for (let keys = Object.keys(message.notDissolvingNeuronsCountBuckets), i = 0; i < keys.length; ++i)
                                writer.uint32(/* id 8, wireType 2 =*/66).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint64(message.notDissolvingNeuronsCountBuckets[keys[i]]).ldelim();
                        if (message.dissolvedNeuronsCount != null && Object.hasOwnProperty.call(message, "dissolvedNeuronsCount"))
                            writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.dissolvedNeuronsCount);
                        if (message.dissolvedNeuronsE8s != null && Object.hasOwnProperty.call(message, "dissolvedNeuronsE8s"))
                            writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.dissolvedNeuronsE8s);
                        if (message.garbageCollectableNeuronsCount != null && Object.hasOwnProperty.call(message, "garbageCollectableNeuronsCount"))
                            writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.garbageCollectableNeuronsCount);
                        if (message.neuronsWithInvalidStakeCount != null && Object.hasOwnProperty.call(message, "neuronsWithInvalidStakeCount"))
                            writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.neuronsWithInvalidStakeCount);
                        if (message.totalStakedE8s != null && Object.hasOwnProperty.call(message, "totalStakedE8s"))
                            writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.totalStakedE8s);
                        if (message.neuronsWithLessThan_6MonthsDissolveDelayCount != null && Object.hasOwnProperty.call(message, "neuronsWithLessThan_6MonthsDissolveDelayCount"))
                            writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.neuronsWithLessThan_6MonthsDissolveDelayCount);
                        if (message.neuronsWithLessThan_6MonthsDissolveDelayE8s != null && Object.hasOwnProperty.call(message, "neuronsWithLessThan_6MonthsDissolveDelayE8s"))
                            writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.neuronsWithLessThan_6MonthsDissolveDelayE8s);
                        if (message.communityFundTotalStakedE8s != null && Object.hasOwnProperty.call(message, "communityFundTotalStakedE8s"))
                            writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.communityFundTotalStakedE8s);
                        return writer;
                    };

                    /**
                     * Encodes the specified GovernanceCachedMetrics message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @static
                     * @param {ic_nns_governance.pb.v1.Governance.IGovernanceCachedMetrics} message GovernanceCachedMetrics message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    GovernanceCachedMetrics.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a GovernanceCachedMetrics message from the specified reader or buffer.
                     * @function decode
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics} GovernanceCachedMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GovernanceCachedMetrics.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics(), key, value;
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.timestampSeconds = reader.uint64();
                                break;
                            case 2:
                                message.totalSupplyIcp = reader.uint64();
                                break;
                            case 3:
                                message.dissolvingNeuronsCount = reader.uint64();
                                break;
                            case 4:
                                if (message.dissolvingNeuronsE8sBuckets === $util.emptyObject)
                                    message.dissolvingNeuronsE8sBuckets = {};
                                let end2 = reader.uint32() + reader.pos;
                                key = 0;
                                value = 0;
                                while (reader.pos < end2) {
                                    let tag2 = reader.uint32();
                                    switch (tag2 >>> 3) {
                                    case 1:
                                        key = reader.uint64();
                                        break;
                                    case 2:
                                        value = reader.double();
                                        break;
                                    default:
                                        reader.skipType(tag2 & 7);
                                        break;
                                    }
                                }
                                message.dissolvingNeuronsE8sBuckets[typeof key === "object" ? $util.longToHash(key) : key] = value;
                                break;
                            case 5:
                                if (message.dissolvingNeuronsCountBuckets === $util.emptyObject)
                                    message.dissolvingNeuronsCountBuckets = {};
                                let end2 = reader.uint32() + reader.pos;
                                key = 0;
                                value = 0;
                                while (reader.pos < end2) {
                                    let tag2 = reader.uint32();
                                    switch (tag2 >>> 3) {
                                    case 1:
                                        key = reader.uint64();
                                        break;
                                    case 2:
                                        value = reader.uint64();
                                        break;
                                    default:
                                        reader.skipType(tag2 & 7);
                                        break;
                                    }
                                }
                                message.dissolvingNeuronsCountBuckets[typeof key === "object" ? $util.longToHash(key) : key] = value;
                                break;
                            case 6:
                                message.notDissolvingNeuronsCount = reader.uint64();
                                break;
                            case 7:
                                if (message.notDissolvingNeuronsE8sBuckets === $util.emptyObject)
                                    message.notDissolvingNeuronsE8sBuckets = {};
                                let end2 = reader.uint32() + reader.pos;
                                key = 0;
                                value = 0;
                                while (reader.pos < end2) {
                                    let tag2 = reader.uint32();
                                    switch (tag2 >>> 3) {
                                    case 1:
                                        key = reader.uint64();
                                        break;
                                    case 2:
                                        value = reader.double();
                                        break;
                                    default:
                                        reader.skipType(tag2 & 7);
                                        break;
                                    }
                                }
                                message.notDissolvingNeuronsE8sBuckets[typeof key === "object" ? $util.longToHash(key) : key] = value;
                                break;
                            case 8:
                                if (message.notDissolvingNeuronsCountBuckets === $util.emptyObject)
                                    message.notDissolvingNeuronsCountBuckets = {};
                                let end2 = reader.uint32() + reader.pos;
                                key = 0;
                                value = 0;
                                while (reader.pos < end2) {
                                    let tag2 = reader.uint32();
                                    switch (tag2 >>> 3) {
                                    case 1:
                                        key = reader.uint64();
                                        break;
                                    case 2:
                                        value = reader.uint64();
                                        break;
                                    default:
                                        reader.skipType(tag2 & 7);
                                        break;
                                    }
                                }
                                message.notDissolvingNeuronsCountBuckets[typeof key === "object" ? $util.longToHash(key) : key] = value;
                                break;
                            case 9:
                                message.dissolvedNeuronsCount = reader.uint64();
                                break;
                            case 10:
                                message.dissolvedNeuronsE8s = reader.uint64();
                                break;
                            case 11:
                                message.garbageCollectableNeuronsCount = reader.uint64();
                                break;
                            case 12:
                                message.neuronsWithInvalidStakeCount = reader.uint64();
                                break;
                            case 13:
                                message.totalStakedE8s = reader.uint64();
                                break;
                            case 14:
                                message.neuronsWithLessThan_6MonthsDissolveDelayCount = reader.uint64();
                                break;
                            case 15:
                                message.neuronsWithLessThan_6MonthsDissolveDelayE8s = reader.uint64();
                                break;
                            case 16:
                                message.communityFundTotalStakedE8s = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a GovernanceCachedMetrics message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics} GovernanceCachedMetrics
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    GovernanceCachedMetrics.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a GovernanceCachedMetrics message.
                     * @function verify
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GovernanceCachedMetrics.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.timestampSeconds != null && message.hasOwnProperty("timestampSeconds"))
                            if (!$util.isInteger(message.timestampSeconds) && !(message.timestampSeconds && $util.isInteger(message.timestampSeconds.low) && $util.isInteger(message.timestampSeconds.high)))
                                return "timestampSeconds: integer|Long expected";
                        if (message.totalSupplyIcp != null && message.hasOwnProperty("totalSupplyIcp"))
                            if (!$util.isInteger(message.totalSupplyIcp) && !(message.totalSupplyIcp && $util.isInteger(message.totalSupplyIcp.low) && $util.isInteger(message.totalSupplyIcp.high)))
                                return "totalSupplyIcp: integer|Long expected";
                        if (message.dissolvingNeuronsCount != null && message.hasOwnProperty("dissolvingNeuronsCount"))
                            if (!$util.isInteger(message.dissolvingNeuronsCount) && !(message.dissolvingNeuronsCount && $util.isInteger(message.dissolvingNeuronsCount.low) && $util.isInteger(message.dissolvingNeuronsCount.high)))
                                return "dissolvingNeuronsCount: integer|Long expected";
                        if (message.dissolvingNeuronsE8sBuckets != null && message.hasOwnProperty("dissolvingNeuronsE8sBuckets")) {
                            if (!$util.isObject(message.dissolvingNeuronsE8sBuckets))
                                return "dissolvingNeuronsE8sBuckets: object expected";
                            let key = Object.keys(message.dissolvingNeuronsE8sBuckets);
                            for (let i = 0; i < key.length; ++i) {
                                if (!$util.key64Re.test(key[i]))
                                    return "dissolvingNeuronsE8sBuckets: integer|Long key{k:uint64} expected";
                                if (typeof message.dissolvingNeuronsE8sBuckets[key[i]] !== "number")
                                    return "dissolvingNeuronsE8sBuckets: number{k:uint64} expected";
                            }
                        }
                        if (message.dissolvingNeuronsCountBuckets != null && message.hasOwnProperty("dissolvingNeuronsCountBuckets")) {
                            if (!$util.isObject(message.dissolvingNeuronsCountBuckets))
                                return "dissolvingNeuronsCountBuckets: object expected";
                            let key = Object.keys(message.dissolvingNeuronsCountBuckets);
                            for (let i = 0; i < key.length; ++i) {
                                if (!$util.key64Re.test(key[i]))
                                    return "dissolvingNeuronsCountBuckets: integer|Long key{k:uint64} expected";
                                if (!$util.isInteger(message.dissolvingNeuronsCountBuckets[key[i]]) && !(message.dissolvingNeuronsCountBuckets[key[i]] && $util.isInteger(message.dissolvingNeuronsCountBuckets[key[i]].low) && $util.isInteger(message.dissolvingNeuronsCountBuckets[key[i]].high)))
                                    return "dissolvingNeuronsCountBuckets: integer|Long{k:uint64} expected";
                            }
                        }
                        if (message.notDissolvingNeuronsCount != null && message.hasOwnProperty("notDissolvingNeuronsCount"))
                            if (!$util.isInteger(message.notDissolvingNeuronsCount) && !(message.notDissolvingNeuronsCount && $util.isInteger(message.notDissolvingNeuronsCount.low) && $util.isInteger(message.notDissolvingNeuronsCount.high)))
                                return "notDissolvingNeuronsCount: integer|Long expected";
                        if (message.notDissolvingNeuronsE8sBuckets != null && message.hasOwnProperty("notDissolvingNeuronsE8sBuckets")) {
                            if (!$util.isObject(message.notDissolvingNeuronsE8sBuckets))
                                return "notDissolvingNeuronsE8sBuckets: object expected";
                            let key = Object.keys(message.notDissolvingNeuronsE8sBuckets);
                            for (let i = 0; i < key.length; ++i) {
                                if (!$util.key64Re.test(key[i]))
                                    return "notDissolvingNeuronsE8sBuckets: integer|Long key{k:uint64} expected";
                                if (typeof message.notDissolvingNeuronsE8sBuckets[key[i]] !== "number")
                                    return "notDissolvingNeuronsE8sBuckets: number{k:uint64} expected";
                            }
                        }
                        if (message.notDissolvingNeuronsCountBuckets != null && message.hasOwnProperty("notDissolvingNeuronsCountBuckets")) {
                            if (!$util.isObject(message.notDissolvingNeuronsCountBuckets))
                                return "notDissolvingNeuronsCountBuckets: object expected";
                            let key = Object.keys(message.notDissolvingNeuronsCountBuckets);
                            for (let i = 0; i < key.length; ++i) {
                                if (!$util.key64Re.test(key[i]))
                                    return "notDissolvingNeuronsCountBuckets: integer|Long key{k:uint64} expected";
                                if (!$util.isInteger(message.notDissolvingNeuronsCountBuckets[key[i]]) && !(message.notDissolvingNeuronsCountBuckets[key[i]] && $util.isInteger(message.notDissolvingNeuronsCountBuckets[key[i]].low) && $util.isInteger(message.notDissolvingNeuronsCountBuckets[key[i]].high)))
                                    return "notDissolvingNeuronsCountBuckets: integer|Long{k:uint64} expected";
                            }
                        }
                        if (message.dissolvedNeuronsCount != null && message.hasOwnProperty("dissolvedNeuronsCount"))
                            if (!$util.isInteger(message.dissolvedNeuronsCount) && !(message.dissolvedNeuronsCount && $util.isInteger(message.dissolvedNeuronsCount.low) && $util.isInteger(message.dissolvedNeuronsCount.high)))
                                return "dissolvedNeuronsCount: integer|Long expected";
                        if (message.dissolvedNeuronsE8s != null && message.hasOwnProperty("dissolvedNeuronsE8s"))
                            if (!$util.isInteger(message.dissolvedNeuronsE8s) && !(message.dissolvedNeuronsE8s && $util.isInteger(message.dissolvedNeuronsE8s.low) && $util.isInteger(message.dissolvedNeuronsE8s.high)))
                                return "dissolvedNeuronsE8s: integer|Long expected";
                        if (message.garbageCollectableNeuronsCount != null && message.hasOwnProperty("garbageCollectableNeuronsCount"))
                            if (!$util.isInteger(message.garbageCollectableNeuronsCount) && !(message.garbageCollectableNeuronsCount && $util.isInteger(message.garbageCollectableNeuronsCount.low) && $util.isInteger(message.garbageCollectableNeuronsCount.high)))
                                return "garbageCollectableNeuronsCount: integer|Long expected";
                        if (message.neuronsWithInvalidStakeCount != null && message.hasOwnProperty("neuronsWithInvalidStakeCount"))
                            if (!$util.isInteger(message.neuronsWithInvalidStakeCount) && !(message.neuronsWithInvalidStakeCount && $util.isInteger(message.neuronsWithInvalidStakeCount.low) && $util.isInteger(message.neuronsWithInvalidStakeCount.high)))
                                return "neuronsWithInvalidStakeCount: integer|Long expected";
                        if (message.totalStakedE8s != null && message.hasOwnProperty("totalStakedE8s"))
                            if (!$util.isInteger(message.totalStakedE8s) && !(message.totalStakedE8s && $util.isInteger(message.totalStakedE8s.low) && $util.isInteger(message.totalStakedE8s.high)))
                                return "totalStakedE8s: integer|Long expected";
                        if (message.neuronsWithLessThan_6MonthsDissolveDelayCount != null && message.hasOwnProperty("neuronsWithLessThan_6MonthsDissolveDelayCount"))
                            if (!$util.isInteger(message.neuronsWithLessThan_6MonthsDissolveDelayCount) && !(message.neuronsWithLessThan_6MonthsDissolveDelayCount && $util.isInteger(message.neuronsWithLessThan_6MonthsDissolveDelayCount.low) && $util.isInteger(message.neuronsWithLessThan_6MonthsDissolveDelayCount.high)))
                                return "neuronsWithLessThan_6MonthsDissolveDelayCount: integer|Long expected";
                        if (message.neuronsWithLessThan_6MonthsDissolveDelayE8s != null && message.hasOwnProperty("neuronsWithLessThan_6MonthsDissolveDelayE8s"))
                            if (!$util.isInteger(message.neuronsWithLessThan_6MonthsDissolveDelayE8s) && !(message.neuronsWithLessThan_6MonthsDissolveDelayE8s && $util.isInteger(message.neuronsWithLessThan_6MonthsDissolveDelayE8s.low) && $util.isInteger(message.neuronsWithLessThan_6MonthsDissolveDelayE8s.high)))
                                return "neuronsWithLessThan_6MonthsDissolveDelayE8s: integer|Long expected";
                        if (message.communityFundTotalStakedE8s != null && message.hasOwnProperty("communityFundTotalStakedE8s"))
                            if (!$util.isInteger(message.communityFundTotalStakedE8s) && !(message.communityFundTotalStakedE8s && $util.isInteger(message.communityFundTotalStakedE8s.low) && $util.isInteger(message.communityFundTotalStakedE8s.high)))
                                return "communityFundTotalStakedE8s: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a GovernanceCachedMetrics message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics} GovernanceCachedMetrics
                     */
                    GovernanceCachedMetrics.fromObject = function fromObject(object) {
                        if (object instanceof $root.ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics)
                            return object;
                        let message = new $root.ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics();
                        if (object.timestampSeconds != null)
                            if ($util.Long)
                                (message.timestampSeconds = $util.Long.fromValue(object.timestampSeconds)).unsigned = true;
                            else if (typeof object.timestampSeconds === "string")
                                message.timestampSeconds = parseInt(object.timestampSeconds, 10);
                            else if (typeof object.timestampSeconds === "number")
                                message.timestampSeconds = object.timestampSeconds;
                            else if (typeof object.timestampSeconds === "object")
                                message.timestampSeconds = new $util.LongBits(object.timestampSeconds.low >>> 0, object.timestampSeconds.high >>> 0).toNumber(true);
                        if (object.totalSupplyIcp != null)
                            if ($util.Long)
                                (message.totalSupplyIcp = $util.Long.fromValue(object.totalSupplyIcp)).unsigned = true;
                            else if (typeof object.totalSupplyIcp === "string")
                                message.totalSupplyIcp = parseInt(object.totalSupplyIcp, 10);
                            else if (typeof object.totalSupplyIcp === "number")
                                message.totalSupplyIcp = object.totalSupplyIcp;
                            else if (typeof object.totalSupplyIcp === "object")
                                message.totalSupplyIcp = new $util.LongBits(object.totalSupplyIcp.low >>> 0, object.totalSupplyIcp.high >>> 0).toNumber(true);
                        if (object.dissolvingNeuronsCount != null)
                            if ($util.Long)
                                (message.dissolvingNeuronsCount = $util.Long.fromValue(object.dissolvingNeuronsCount)).unsigned = true;
                            else if (typeof object.dissolvingNeuronsCount === "string")
                                message.dissolvingNeuronsCount = parseInt(object.dissolvingNeuronsCount, 10);
                            else if (typeof object.dissolvingNeuronsCount === "number")
                                message.dissolvingNeuronsCount = object.dissolvingNeuronsCount;
                            else if (typeof object.dissolvingNeuronsCount === "object")
                                message.dissolvingNeuronsCount = new $util.LongBits(object.dissolvingNeuronsCount.low >>> 0, object.dissolvingNeuronsCount.high >>> 0).toNumber(true);
                        if (object.dissolvingNeuronsE8sBuckets) {
                            if (typeof object.dissolvingNeuronsE8sBuckets !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics.dissolvingNeuronsE8sBuckets: object expected");
                            message.dissolvingNeuronsE8sBuckets = {};
                            for (let keys = Object.keys(object.dissolvingNeuronsE8sBuckets), i = 0; i < keys.length; ++i)
                                message.dissolvingNeuronsE8sBuckets[keys[i]] = Number(object.dissolvingNeuronsE8sBuckets[keys[i]]);
                        }
                        if (object.dissolvingNeuronsCountBuckets) {
                            if (typeof object.dissolvingNeuronsCountBuckets !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics.dissolvingNeuronsCountBuckets: object expected");
                            message.dissolvingNeuronsCountBuckets = {};
                            for (let keys = Object.keys(object.dissolvingNeuronsCountBuckets), i = 0; i < keys.length; ++i)
                                if ($util.Long)
                                    (message.dissolvingNeuronsCountBuckets[keys[i]] = $util.Long.fromValue(object.dissolvingNeuronsCountBuckets[keys[i]])).unsigned = true;
                                else if (typeof object.dissolvingNeuronsCountBuckets[keys[i]] === "string")
                                    message.dissolvingNeuronsCountBuckets[keys[i]] = parseInt(object.dissolvingNeuronsCountBuckets[keys[i]], 10);
                                else if (typeof object.dissolvingNeuronsCountBuckets[keys[i]] === "number")
                                    message.dissolvingNeuronsCountBuckets[keys[i]] = object.dissolvingNeuronsCountBuckets[keys[i]];
                                else if (typeof object.dissolvingNeuronsCountBuckets[keys[i]] === "object")
                                    message.dissolvingNeuronsCountBuckets[keys[i]] = new $util.LongBits(object.dissolvingNeuronsCountBuckets[keys[i]].low >>> 0, object.dissolvingNeuronsCountBuckets[keys[i]].high >>> 0).toNumber(true);
                        }
                        if (object.notDissolvingNeuronsCount != null)
                            if ($util.Long)
                                (message.notDissolvingNeuronsCount = $util.Long.fromValue(object.notDissolvingNeuronsCount)).unsigned = true;
                            else if (typeof object.notDissolvingNeuronsCount === "string")
                                message.notDissolvingNeuronsCount = parseInt(object.notDissolvingNeuronsCount, 10);
                            else if (typeof object.notDissolvingNeuronsCount === "number")
                                message.notDissolvingNeuronsCount = object.notDissolvingNeuronsCount;
                            else if (typeof object.notDissolvingNeuronsCount === "object")
                                message.notDissolvingNeuronsCount = new $util.LongBits(object.notDissolvingNeuronsCount.low >>> 0, object.notDissolvingNeuronsCount.high >>> 0).toNumber(true);
                        if (object.notDissolvingNeuronsE8sBuckets) {
                            if (typeof object.notDissolvingNeuronsE8sBuckets !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics.notDissolvingNeuronsE8sBuckets: object expected");
                            message.notDissolvingNeuronsE8sBuckets = {};
                            for (let keys = Object.keys(object.notDissolvingNeuronsE8sBuckets), i = 0; i < keys.length; ++i)
                                message.notDissolvingNeuronsE8sBuckets[keys[i]] = Number(object.notDissolvingNeuronsE8sBuckets[keys[i]]);
                        }
                        if (object.notDissolvingNeuronsCountBuckets) {
                            if (typeof object.notDissolvingNeuronsCountBuckets !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics.notDissolvingNeuronsCountBuckets: object expected");
                            message.notDissolvingNeuronsCountBuckets = {};
                            for (let keys = Object.keys(object.notDissolvingNeuronsCountBuckets), i = 0; i < keys.length; ++i)
                                if ($util.Long)
                                    (message.notDissolvingNeuronsCountBuckets[keys[i]] = $util.Long.fromValue(object.notDissolvingNeuronsCountBuckets[keys[i]])).unsigned = true;
                                else if (typeof object.notDissolvingNeuronsCountBuckets[keys[i]] === "string")
                                    message.notDissolvingNeuronsCountBuckets[keys[i]] = parseInt(object.notDissolvingNeuronsCountBuckets[keys[i]], 10);
                                else if (typeof object.notDissolvingNeuronsCountBuckets[keys[i]] === "number")
                                    message.notDissolvingNeuronsCountBuckets[keys[i]] = object.notDissolvingNeuronsCountBuckets[keys[i]];
                                else if (typeof object.notDissolvingNeuronsCountBuckets[keys[i]] === "object")
                                    message.notDissolvingNeuronsCountBuckets[keys[i]] = new $util.LongBits(object.notDissolvingNeuronsCountBuckets[keys[i]].low >>> 0, object.notDissolvingNeuronsCountBuckets[keys[i]].high >>> 0).toNumber(true);
                        }
                        if (object.dissolvedNeuronsCount != null)
                            if ($util.Long)
                                (message.dissolvedNeuronsCount = $util.Long.fromValue(object.dissolvedNeuronsCount)).unsigned = true;
                            else if (typeof object.dissolvedNeuronsCount === "string")
                                message.dissolvedNeuronsCount = parseInt(object.dissolvedNeuronsCount, 10);
                            else if (typeof object.dissolvedNeuronsCount === "number")
                                message.dissolvedNeuronsCount = object.dissolvedNeuronsCount;
                            else if (typeof object.dissolvedNeuronsCount === "object")
                                message.dissolvedNeuronsCount = new $util.LongBits(object.dissolvedNeuronsCount.low >>> 0, object.dissolvedNeuronsCount.high >>> 0).toNumber(true);
                        if (object.dissolvedNeuronsE8s != null)
                            if ($util.Long)
                                (message.dissolvedNeuronsE8s = $util.Long.fromValue(object.dissolvedNeuronsE8s)).unsigned = true;
                            else if (typeof object.dissolvedNeuronsE8s === "string")
                                message.dissolvedNeuronsE8s = parseInt(object.dissolvedNeuronsE8s, 10);
                            else if (typeof object.dissolvedNeuronsE8s === "number")
                                message.dissolvedNeuronsE8s = object.dissolvedNeuronsE8s;
                            else if (typeof object.dissolvedNeuronsE8s === "object")
                                message.dissolvedNeuronsE8s = new $util.LongBits(object.dissolvedNeuronsE8s.low >>> 0, object.dissolvedNeuronsE8s.high >>> 0).toNumber(true);
                        if (object.garbageCollectableNeuronsCount != null)
                            if ($util.Long)
                                (message.garbageCollectableNeuronsCount = $util.Long.fromValue(object.garbageCollectableNeuronsCount)).unsigned = true;
                            else if (typeof object.garbageCollectableNeuronsCount === "string")
                                message.garbageCollectableNeuronsCount = parseInt(object.garbageCollectableNeuronsCount, 10);
                            else if (typeof object.garbageCollectableNeuronsCount === "number")
                                message.garbageCollectableNeuronsCount = object.garbageCollectableNeuronsCount;
                            else if (typeof object.garbageCollectableNeuronsCount === "object")
                                message.garbageCollectableNeuronsCount = new $util.LongBits(object.garbageCollectableNeuronsCount.low >>> 0, object.garbageCollectableNeuronsCount.high >>> 0).toNumber(true);
                        if (object.neuronsWithInvalidStakeCount != null)
                            if ($util.Long)
                                (message.neuronsWithInvalidStakeCount = $util.Long.fromValue(object.neuronsWithInvalidStakeCount)).unsigned = true;
                            else if (typeof object.neuronsWithInvalidStakeCount === "string")
                                message.neuronsWithInvalidStakeCount = parseInt(object.neuronsWithInvalidStakeCount, 10);
                            else if (typeof object.neuronsWithInvalidStakeCount === "number")
                                message.neuronsWithInvalidStakeCount = object.neuronsWithInvalidStakeCount;
                            else if (typeof object.neuronsWithInvalidStakeCount === "object")
                                message.neuronsWithInvalidStakeCount = new $util.LongBits(object.neuronsWithInvalidStakeCount.low >>> 0, object.neuronsWithInvalidStakeCount.high >>> 0).toNumber(true);
                        if (object.totalStakedE8s != null)
                            if ($util.Long)
                                (message.totalStakedE8s = $util.Long.fromValue(object.totalStakedE8s)).unsigned = true;
                            else if (typeof object.totalStakedE8s === "string")
                                message.totalStakedE8s = parseInt(object.totalStakedE8s, 10);
                            else if (typeof object.totalStakedE8s === "number")
                                message.totalStakedE8s = object.totalStakedE8s;
                            else if (typeof object.totalStakedE8s === "object")
                                message.totalStakedE8s = new $util.LongBits(object.totalStakedE8s.low >>> 0, object.totalStakedE8s.high >>> 0).toNumber(true);
                        if (object.neuronsWithLessThan_6MonthsDissolveDelayCount != null)
                            if ($util.Long)
                                (message.neuronsWithLessThan_6MonthsDissolveDelayCount = $util.Long.fromValue(object.neuronsWithLessThan_6MonthsDissolveDelayCount)).unsigned = true;
                            else if (typeof object.neuronsWithLessThan_6MonthsDissolveDelayCount === "string")
                                message.neuronsWithLessThan_6MonthsDissolveDelayCount = parseInt(object.neuronsWithLessThan_6MonthsDissolveDelayCount, 10);
                            else if (typeof object.neuronsWithLessThan_6MonthsDissolveDelayCount === "number")
                                message.neuronsWithLessThan_6MonthsDissolveDelayCount = object.neuronsWithLessThan_6MonthsDissolveDelayCount;
                            else if (typeof object.neuronsWithLessThan_6MonthsDissolveDelayCount === "object")
                                message.neuronsWithLessThan_6MonthsDissolveDelayCount = new $util.LongBits(object.neuronsWithLessThan_6MonthsDissolveDelayCount.low >>> 0, object.neuronsWithLessThan_6MonthsDissolveDelayCount.high >>> 0).toNumber(true);
                        if (object.neuronsWithLessThan_6MonthsDissolveDelayE8s != null)
                            if ($util.Long)
                                (message.neuronsWithLessThan_6MonthsDissolveDelayE8s = $util.Long.fromValue(object.neuronsWithLessThan_6MonthsDissolveDelayE8s)).unsigned = true;
                            else if (typeof object.neuronsWithLessThan_6MonthsDissolveDelayE8s === "string")
                                message.neuronsWithLessThan_6MonthsDissolveDelayE8s = parseInt(object.neuronsWithLessThan_6MonthsDissolveDelayE8s, 10);
                            else if (typeof object.neuronsWithLessThan_6MonthsDissolveDelayE8s === "number")
                                message.neuronsWithLessThan_6MonthsDissolveDelayE8s = object.neuronsWithLessThan_6MonthsDissolveDelayE8s;
                            else if (typeof object.neuronsWithLessThan_6MonthsDissolveDelayE8s === "object")
                                message.neuronsWithLessThan_6MonthsDissolveDelayE8s = new $util.LongBits(object.neuronsWithLessThan_6MonthsDissolveDelayE8s.low >>> 0, object.neuronsWithLessThan_6MonthsDissolveDelayE8s.high >>> 0).toNumber(true);
                        if (object.communityFundTotalStakedE8s != null)
                            if ($util.Long)
                                (message.communityFundTotalStakedE8s = $util.Long.fromValue(object.communityFundTotalStakedE8s)).unsigned = true;
                            else if (typeof object.communityFundTotalStakedE8s === "string")
                                message.communityFundTotalStakedE8s = parseInt(object.communityFundTotalStakedE8s, 10);
                            else if (typeof object.communityFundTotalStakedE8s === "number")
                                message.communityFundTotalStakedE8s = object.communityFundTotalStakedE8s;
                            else if (typeof object.communityFundTotalStakedE8s === "object")
                                message.communityFundTotalStakedE8s = new $util.LongBits(object.communityFundTotalStakedE8s.low >>> 0, object.communityFundTotalStakedE8s.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GovernanceCachedMetrics message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @static
                     * @param {ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics} message GovernanceCachedMetrics
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GovernanceCachedMetrics.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.objects || options.defaults) {
                            object.dissolvingNeuronsE8sBuckets = {};
                            object.dissolvingNeuronsCountBuckets = {};
                            object.notDissolvingNeuronsE8sBuckets = {};
                            object.notDissolvingNeuronsCountBuckets = {};
                        }
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.timestampSeconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.timestampSeconds = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.totalSupplyIcp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.totalSupplyIcp = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.dissolvingNeuronsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.dissolvingNeuronsCount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.notDissolvingNeuronsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.notDissolvingNeuronsCount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.dissolvedNeuronsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.dissolvedNeuronsCount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.dissolvedNeuronsE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.dissolvedNeuronsE8s = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.garbageCollectableNeuronsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.garbageCollectableNeuronsCount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.neuronsWithInvalidStakeCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.neuronsWithInvalidStakeCount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.totalStakedE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.totalStakedE8s = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.neuronsWithLessThan_6MonthsDissolveDelayCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.neuronsWithLessThan_6MonthsDissolveDelayCount = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.neuronsWithLessThan_6MonthsDissolveDelayE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.neuronsWithLessThan_6MonthsDissolveDelayE8s = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.communityFundTotalStakedE8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.communityFundTotalStakedE8s = options.longs === String ? "0" : 0;
                        }
                        if (message.timestampSeconds != null && message.hasOwnProperty("timestampSeconds"))
                            if (typeof message.timestampSeconds === "number")
                                object.timestampSeconds = options.longs === String ? String(message.timestampSeconds) : message.timestampSeconds;
                            else
                                object.timestampSeconds = options.longs === String ? $util.Long.prototype.toString.call(message.timestampSeconds) : options.longs === Number ? new $util.LongBits(message.timestampSeconds.low >>> 0, message.timestampSeconds.high >>> 0).toNumber(true) : message.timestampSeconds;
                        if (message.totalSupplyIcp != null && message.hasOwnProperty("totalSupplyIcp"))
                            if (typeof message.totalSupplyIcp === "number")
                                object.totalSupplyIcp = options.longs === String ? String(message.totalSupplyIcp) : message.totalSupplyIcp;
                            else
                                object.totalSupplyIcp = options.longs === String ? $util.Long.prototype.toString.call(message.totalSupplyIcp) : options.longs === Number ? new $util.LongBits(message.totalSupplyIcp.low >>> 0, message.totalSupplyIcp.high >>> 0).toNumber(true) : message.totalSupplyIcp;
                        if (message.dissolvingNeuronsCount != null && message.hasOwnProperty("dissolvingNeuronsCount"))
                            if (typeof message.dissolvingNeuronsCount === "number")
                                object.dissolvingNeuronsCount = options.longs === String ? String(message.dissolvingNeuronsCount) : message.dissolvingNeuronsCount;
                            else
                                object.dissolvingNeuronsCount = options.longs === String ? $util.Long.prototype.toString.call(message.dissolvingNeuronsCount) : options.longs === Number ? new $util.LongBits(message.dissolvingNeuronsCount.low >>> 0, message.dissolvingNeuronsCount.high >>> 0).toNumber(true) : message.dissolvingNeuronsCount;
                        let keys2;
                        if (message.dissolvingNeuronsE8sBuckets && (keys2 = Object.keys(message.dissolvingNeuronsE8sBuckets)).length) {
                            object.dissolvingNeuronsE8sBuckets = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.dissolvingNeuronsE8sBuckets[keys2[j]] = options.json && !isFinite(message.dissolvingNeuronsE8sBuckets[keys2[j]]) ? String(message.dissolvingNeuronsE8sBuckets[keys2[j]]) : message.dissolvingNeuronsE8sBuckets[keys2[j]];
                        }
                        if (message.dissolvingNeuronsCountBuckets && (keys2 = Object.keys(message.dissolvingNeuronsCountBuckets)).length) {
                            object.dissolvingNeuronsCountBuckets = {};
                            for (let j = 0; j < keys2.length; ++j)
                                if (typeof message.dissolvingNeuronsCountBuckets[keys2[j]] === "number")
                                    object.dissolvingNeuronsCountBuckets[keys2[j]] = options.longs === String ? String(message.dissolvingNeuronsCountBuckets[keys2[j]]) : message.dissolvingNeuronsCountBuckets[keys2[j]];
                                else
                                    object.dissolvingNeuronsCountBuckets[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.dissolvingNeuronsCountBuckets[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.dissolvingNeuronsCountBuckets[keys2[j]].low >>> 0, message.dissolvingNeuronsCountBuckets[keys2[j]].high >>> 0).toNumber(true) : message.dissolvingNeuronsCountBuckets[keys2[j]];
                        }
                        if (message.notDissolvingNeuronsCount != null && message.hasOwnProperty("notDissolvingNeuronsCount"))
                            if (typeof message.notDissolvingNeuronsCount === "number")
                                object.notDissolvingNeuronsCount = options.longs === String ? String(message.notDissolvingNeuronsCount) : message.notDissolvingNeuronsCount;
                            else
                                object.notDissolvingNeuronsCount = options.longs === String ? $util.Long.prototype.toString.call(message.notDissolvingNeuronsCount) : options.longs === Number ? new $util.LongBits(message.notDissolvingNeuronsCount.low >>> 0, message.notDissolvingNeuronsCount.high >>> 0).toNumber(true) : message.notDissolvingNeuronsCount;
                        if (message.notDissolvingNeuronsE8sBuckets && (keys2 = Object.keys(message.notDissolvingNeuronsE8sBuckets)).length) {
                            object.notDissolvingNeuronsE8sBuckets = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.notDissolvingNeuronsE8sBuckets[keys2[j]] = options.json && !isFinite(message.notDissolvingNeuronsE8sBuckets[keys2[j]]) ? String(message.notDissolvingNeuronsE8sBuckets[keys2[j]]) : message.notDissolvingNeuronsE8sBuckets[keys2[j]];
                        }
                        if (message.notDissolvingNeuronsCountBuckets && (keys2 = Object.keys(message.notDissolvingNeuronsCountBuckets)).length) {
                            object.notDissolvingNeuronsCountBuckets = {};
                            for (let j = 0; j < keys2.length; ++j)
                                if (typeof message.notDissolvingNeuronsCountBuckets[keys2[j]] === "number")
                                    object.notDissolvingNeuronsCountBuckets[keys2[j]] = options.longs === String ? String(message.notDissolvingNeuronsCountBuckets[keys2[j]]) : message.notDissolvingNeuronsCountBuckets[keys2[j]];
                                else
                                    object.notDissolvingNeuronsCountBuckets[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.notDissolvingNeuronsCountBuckets[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.notDissolvingNeuronsCountBuckets[keys2[j]].low >>> 0, message.notDissolvingNeuronsCountBuckets[keys2[j]].high >>> 0).toNumber(true) : message.notDissolvingNeuronsCountBuckets[keys2[j]];
                        }
                        if (message.dissolvedNeuronsCount != null && message.hasOwnProperty("dissolvedNeuronsCount"))
                            if (typeof message.dissolvedNeuronsCount === "number")
                                object.dissolvedNeuronsCount = options.longs === String ? String(message.dissolvedNeuronsCount) : message.dissolvedNeuronsCount;
                            else
                                object.dissolvedNeuronsCount = options.longs === String ? $util.Long.prototype.toString.call(message.dissolvedNeuronsCount) : options.longs === Number ? new $util.LongBits(message.dissolvedNeuronsCount.low >>> 0, message.dissolvedNeuronsCount.high >>> 0).toNumber(true) : message.dissolvedNeuronsCount;
                        if (message.dissolvedNeuronsE8s != null && message.hasOwnProperty("dissolvedNeuronsE8s"))
                            if (typeof message.dissolvedNeuronsE8s === "number")
                                object.dissolvedNeuronsE8s = options.longs === String ? String(message.dissolvedNeuronsE8s) : message.dissolvedNeuronsE8s;
                            else
                                object.dissolvedNeuronsE8s = options.longs === String ? $util.Long.prototype.toString.call(message.dissolvedNeuronsE8s) : options.longs === Number ? new $util.LongBits(message.dissolvedNeuronsE8s.low >>> 0, message.dissolvedNeuronsE8s.high >>> 0).toNumber(true) : message.dissolvedNeuronsE8s;
                        if (message.garbageCollectableNeuronsCount != null && message.hasOwnProperty("garbageCollectableNeuronsCount"))
                            if (typeof message.garbageCollectableNeuronsCount === "number")
                                object.garbageCollectableNeuronsCount = options.longs === String ? String(message.garbageCollectableNeuronsCount) : message.garbageCollectableNeuronsCount;
                            else
                                object.garbageCollectableNeuronsCount = options.longs === String ? $util.Long.prototype.toString.call(message.garbageCollectableNeuronsCount) : options.longs === Number ? new $util.LongBits(message.garbageCollectableNeuronsCount.low >>> 0, message.garbageCollectableNeuronsCount.high >>> 0).toNumber(true) : message.garbageCollectableNeuronsCount;
                        if (message.neuronsWithInvalidStakeCount != null && message.hasOwnProperty("neuronsWithInvalidStakeCount"))
                            if (typeof message.neuronsWithInvalidStakeCount === "number")
                                object.neuronsWithInvalidStakeCount = options.longs === String ? String(message.neuronsWithInvalidStakeCount) : message.neuronsWithInvalidStakeCount;
                            else
                                object.neuronsWithInvalidStakeCount = options.longs === String ? $util.Long.prototype.toString.call(message.neuronsWithInvalidStakeCount) : options.longs === Number ? new $util.LongBits(message.neuronsWithInvalidStakeCount.low >>> 0, message.neuronsWithInvalidStakeCount.high >>> 0).toNumber(true) : message.neuronsWithInvalidStakeCount;
                        if (message.totalStakedE8s != null && message.hasOwnProperty("totalStakedE8s"))
                            if (typeof message.totalStakedE8s === "number")
                                object.totalStakedE8s = options.longs === String ? String(message.totalStakedE8s) : message.totalStakedE8s;
                            else
                                object.totalStakedE8s = options.longs === String ? $util.Long.prototype.toString.call(message.totalStakedE8s) : options.longs === Number ? new $util.LongBits(message.totalStakedE8s.low >>> 0, message.totalStakedE8s.high >>> 0).toNumber(true) : message.totalStakedE8s;
                        if (message.neuronsWithLessThan_6MonthsDissolveDelayCount != null && message.hasOwnProperty("neuronsWithLessThan_6MonthsDissolveDelayCount"))
                            if (typeof message.neuronsWithLessThan_6MonthsDissolveDelayCount === "number")
                                object.neuronsWithLessThan_6MonthsDissolveDelayCount = options.longs === String ? String(message.neuronsWithLessThan_6MonthsDissolveDelayCount) : message.neuronsWithLessThan_6MonthsDissolveDelayCount;
                            else
                                object.neuronsWithLessThan_6MonthsDissolveDelayCount = options.longs === String ? $util.Long.prototype.toString.call(message.neuronsWithLessThan_6MonthsDissolveDelayCount) : options.longs === Number ? new $util.LongBits(message.neuronsWithLessThan_6MonthsDissolveDelayCount.low >>> 0, message.neuronsWithLessThan_6MonthsDissolveDelayCount.high >>> 0).toNumber(true) : message.neuronsWithLessThan_6MonthsDissolveDelayCount;
                        if (message.neuronsWithLessThan_6MonthsDissolveDelayE8s != null && message.hasOwnProperty("neuronsWithLessThan_6MonthsDissolveDelayE8s"))
                            if (typeof message.neuronsWithLessThan_6MonthsDissolveDelayE8s === "number")
                                object.neuronsWithLessThan_6MonthsDissolveDelayE8s = options.longs === String ? String(message.neuronsWithLessThan_6MonthsDissolveDelayE8s) : message.neuronsWithLessThan_6MonthsDissolveDelayE8s;
                            else
                                object.neuronsWithLessThan_6MonthsDissolveDelayE8s = options.longs === String ? $util.Long.prototype.toString.call(message.neuronsWithLessThan_6MonthsDissolveDelayE8s) : options.longs === Number ? new $util.LongBits(message.neuronsWithLessThan_6MonthsDissolveDelayE8s.low >>> 0, message.neuronsWithLessThan_6MonthsDissolveDelayE8s.high >>> 0).toNumber(true) : message.neuronsWithLessThan_6MonthsDissolveDelayE8s;
                        if (message.communityFundTotalStakedE8s != null && message.hasOwnProperty("communityFundTotalStakedE8s"))
                            if (typeof message.communityFundTotalStakedE8s === "number")
                                object.communityFundTotalStakedE8s = options.longs === String ? String(message.communityFundTotalStakedE8s) : message.communityFundTotalStakedE8s;
                            else
                                object.communityFundTotalStakedE8s = options.longs === String ? $util.Long.prototype.toString.call(message.communityFundTotalStakedE8s) : options.longs === Number ? new $util.LongBits(message.communityFundTotalStakedE8s.low >>> 0, message.communityFundTotalStakedE8s.high >>> 0).toNumber(true) : message.communityFundTotalStakedE8s;
                        return object;
                    };

                    /**
                     * Converts this GovernanceCachedMetrics to JSON.
                     * @function toJSON
                     * @memberof ic_nns_governance.pb.v1.Governance.GovernanceCachedMetrics
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GovernanceCachedMetrics.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GovernanceCachedMetrics;
                })();

                return Governance;
            })();

            v1.ListProposalInfo = (function() {

                /**
                 * Properties of a ListProposalInfo.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IListProposalInfo
                 * @property {number|null} [limit] ListProposalInfo limit
                 * @property {ic_nns_common.pb.v1.IProposalId|null} [beforeProposal] ListProposalInfo beforeProposal
                 * @property {Array.<ic_nns_governance.pb.v1.Topic>|null} [excludeTopic] ListProposalInfo excludeTopic
                 * @property {Array.<ic_nns_governance.pb.v1.ProposalRewardStatus>|null} [includeRewardStatus] ListProposalInfo includeRewardStatus
                 * @property {Array.<ic_nns_governance.pb.v1.ProposalStatus>|null} [includeStatus] ListProposalInfo includeStatus
                 */

                /**
                 * Constructs a new ListProposalInfo.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a ListProposalInfo.
                 * @implements IListProposalInfo
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IListProposalInfo=} [properties] Properties to set
                 */
                function ListProposalInfo(properties) {
                    this.excludeTopic = [];
                    this.includeRewardStatus = [];
                    this.includeStatus = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListProposalInfo limit.
                 * @member {number} limit
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @instance
                 */
                ListProposalInfo.prototype.limit = 0;

                /**
                 * ListProposalInfo beforeProposal.
                 * @member {ic_nns_common.pb.v1.IProposalId|null|undefined} beforeProposal
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @instance
                 */
                ListProposalInfo.prototype.beforeProposal = null;

                /**
                 * ListProposalInfo excludeTopic.
                 * @member {Array.<ic_nns_governance.pb.v1.Topic>} excludeTopic
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @instance
                 */
                ListProposalInfo.prototype.excludeTopic = $util.emptyArray;

                /**
                 * ListProposalInfo includeRewardStatus.
                 * @member {Array.<ic_nns_governance.pb.v1.ProposalRewardStatus>} includeRewardStatus
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @instance
                 */
                ListProposalInfo.prototype.includeRewardStatus = $util.emptyArray;

                /**
                 * ListProposalInfo includeStatus.
                 * @member {Array.<ic_nns_governance.pb.v1.ProposalStatus>} includeStatus
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @instance
                 */
                ListProposalInfo.prototype.includeStatus = $util.emptyArray;

                /**
                 * Creates a new ListProposalInfo instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListProposalInfo=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ListProposalInfo} ListProposalInfo instance
                 */
                ListProposalInfo.create = function create(properties) {
                    return new ListProposalInfo(properties);
                };

                /**
                 * Encodes the specified ListProposalInfo message. Does not implicitly {@link ic_nns_governance.pb.v1.ListProposalInfo.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListProposalInfo} message ListProposalInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListProposalInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.limit);
                    if (message.beforeProposal != null && Object.hasOwnProperty.call(message, "beforeProposal"))
                        $root.ic_nns_common.pb.v1.ProposalId.encode(message.beforeProposal, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.excludeTopic != null && message.excludeTopic.length) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork();
                        for (let i = 0; i < message.excludeTopic.length; ++i)
                            writer.int32(message.excludeTopic[i]);
                        writer.ldelim();
                    }
                    if (message.includeRewardStatus != null && message.includeRewardStatus.length) {
                        writer.uint32(/* id 4, wireType 2 =*/34).fork();
                        for (let i = 0; i < message.includeRewardStatus.length; ++i)
                            writer.int32(message.includeRewardStatus[i]);
                        writer.ldelim();
                    }
                    if (message.includeStatus != null && message.includeStatus.length) {
                        writer.uint32(/* id 5, wireType 2 =*/42).fork();
                        for (let i = 0; i < message.includeStatus.length; ++i)
                            writer.int32(message.includeStatus[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified ListProposalInfo message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ListProposalInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListProposalInfo} message ListProposalInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListProposalInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ListProposalInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ListProposalInfo} ListProposalInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListProposalInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ListProposalInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.limit = reader.uint32();
                            break;
                        case 2:
                            message.beforeProposal = $root.ic_nns_common.pb.v1.ProposalId.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.excludeTopic && message.excludeTopic.length))
                                message.excludeTopic = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.excludeTopic.push(reader.int32());
                            } else
                                message.excludeTopic.push(reader.int32());
                            break;
                        case 4:
                            if (!(message.includeRewardStatus && message.includeRewardStatus.length))
                                message.includeRewardStatus = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.includeRewardStatus.push(reader.int32());
                            } else
                                message.includeRewardStatus.push(reader.int32());
                            break;
                        case 5:
                            if (!(message.includeStatus && message.includeStatus.length))
                                message.includeStatus = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.includeStatus.push(reader.int32());
                            } else
                                message.includeStatus.push(reader.int32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ListProposalInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ListProposalInfo} ListProposalInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListProposalInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ListProposalInfo message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListProposalInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    if (message.beforeProposal != null && message.hasOwnProperty("beforeProposal")) {
                        let error = $root.ic_nns_common.pb.v1.ProposalId.verify(message.beforeProposal);
                        if (error)
                            return "beforeProposal." + error;
                    }
                    if (message.excludeTopic != null && message.hasOwnProperty("excludeTopic")) {
                        if (!Array.isArray(message.excludeTopic))
                            return "excludeTopic: array expected";
                        for (let i = 0; i < message.excludeTopic.length; ++i)
                            switch (message.excludeTopic[i]) {
                            default:
                                return "excludeTopic: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                                break;
                            }
                    }
                    if (message.includeRewardStatus != null && message.hasOwnProperty("includeRewardStatus")) {
                        if (!Array.isArray(message.includeRewardStatus))
                            return "includeRewardStatus: array expected";
                        for (let i = 0; i < message.includeRewardStatus.length; ++i)
                            switch (message.includeRewardStatus[i]) {
                            default:
                                return "includeRewardStatus: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                    }
                    if (message.includeStatus != null && message.hasOwnProperty("includeStatus")) {
                        if (!Array.isArray(message.includeStatus))
                            return "includeStatus: array expected";
                        for (let i = 0; i < message.includeStatus.length; ++i)
                            switch (message.includeStatus[i]) {
                            default:
                                return "includeStatus: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            }
                    }
                    return null;
                };

                /**
                 * Creates a ListProposalInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ListProposalInfo} ListProposalInfo
                 */
                ListProposalInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ListProposalInfo)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ListProposalInfo();
                    if (object.limit != null)
                        message.limit = object.limit >>> 0;
                    if (object.beforeProposal != null) {
                        if (typeof object.beforeProposal !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ListProposalInfo.beforeProposal: object expected");
                        message.beforeProposal = $root.ic_nns_common.pb.v1.ProposalId.fromObject(object.beforeProposal);
                    }
                    if (object.excludeTopic) {
                        if (!Array.isArray(object.excludeTopic))
                            throw TypeError(".ic_nns_governance.pb.v1.ListProposalInfo.excludeTopic: array expected");
                        message.excludeTopic = [];
                        for (let i = 0; i < object.excludeTopic.length; ++i)
                            switch (object.excludeTopic[i]) {
                            default:
                            case "TOPIC_UNSPECIFIED":
                            case 0:
                                message.excludeTopic[i] = 0;
                                break;
                            case "TOPIC_NEURON_MANAGEMENT":
                            case 1:
                                message.excludeTopic[i] = 1;
                                break;
                            case "TOPIC_EXCHANGE_RATE":
                            case 2:
                                message.excludeTopic[i] = 2;
                                break;
                            case "TOPIC_NETWORK_ECONOMICS":
                            case 3:
                                message.excludeTopic[i] = 3;
                                break;
                            case "TOPIC_GOVERNANCE":
                            case 4:
                                message.excludeTopic[i] = 4;
                                break;
                            case "TOPIC_NODE_ADMIN":
                            case 5:
                                message.excludeTopic[i] = 5;
                                break;
                            case "TOPIC_PARTICIPANT_MANAGEMENT":
                            case 6:
                                message.excludeTopic[i] = 6;
                                break;
                            case "TOPIC_SUBNET_MANAGEMENT":
                            case 7:
                                message.excludeTopic[i] = 7;
                                break;
                            case "TOPIC_NETWORK_CANISTER_MANAGEMENT":
                            case 8:
                                message.excludeTopic[i] = 8;
                                break;
                            case "TOPIC_KYC":
                            case 9:
                                message.excludeTopic[i] = 9;
                                break;
                            case "TOPIC_NODE_PROVIDER_REWARDS":
                            case 10:
                                message.excludeTopic[i] = 10;
                                break;
                            }
                    }
                    if (object.includeRewardStatus) {
                        if (!Array.isArray(object.includeRewardStatus))
                            throw TypeError(".ic_nns_governance.pb.v1.ListProposalInfo.includeRewardStatus: array expected");
                        message.includeRewardStatus = [];
                        for (let i = 0; i < object.includeRewardStatus.length; ++i)
                            switch (object.includeRewardStatus[i]) {
                            default:
                            case "PROPOSAL_REWARD_STATUS_UNSPECIFIED":
                            case 0:
                                message.includeRewardStatus[i] = 0;
                                break;
                            case "PROPOSAL_REWARD_STATUS_ACCEPT_VOTES":
                            case 1:
                                message.includeRewardStatus[i] = 1;
                                break;
                            case "PROPOSAL_REWARD_STATUS_READY_TO_SETTLE":
                            case 2:
                                message.includeRewardStatus[i] = 2;
                                break;
                            case "PROPOSAL_REWARD_STATUS_SETTLED":
                            case 3:
                                message.includeRewardStatus[i] = 3;
                                break;
                            case "PROPOSAL_REWARD_STATUS_INELIGIBLE":
                            case 4:
                                message.includeRewardStatus[i] = 4;
                                break;
                            }
                    }
                    if (object.includeStatus) {
                        if (!Array.isArray(object.includeStatus))
                            throw TypeError(".ic_nns_governance.pb.v1.ListProposalInfo.includeStatus: array expected");
                        message.includeStatus = [];
                        for (let i = 0; i < object.includeStatus.length; ++i)
                            switch (object.includeStatus[i]) {
                            default:
                            case "PROPOSAL_STATUS_UNSPECIFIED":
                            case 0:
                                message.includeStatus[i] = 0;
                                break;
                            case "PROPOSAL_STATUS_OPEN":
                            case 1:
                                message.includeStatus[i] = 1;
                                break;
                            case "PROPOSAL_STATUS_REJECTED":
                            case 2:
                                message.includeStatus[i] = 2;
                                break;
                            case "PROPOSAL_STATUS_ADOPTED":
                            case 3:
                                message.includeStatus[i] = 3;
                                break;
                            case "PROPOSAL_STATUS_EXECUTED":
                            case 4:
                                message.includeStatus[i] = 4;
                                break;
                            case "PROPOSAL_STATUS_FAILED":
                            case 5:
                                message.includeStatus[i] = 5;
                                break;
                            }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListProposalInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @static
                 * @param {ic_nns_governance.pb.v1.ListProposalInfo} message ListProposalInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListProposalInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.excludeTopic = [];
                        object.includeRewardStatus = [];
                        object.includeStatus = [];
                    }
                    if (options.defaults) {
                        object.limit = 0;
                        object.beforeProposal = null;
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        object.limit = message.limit;
                    if (message.beforeProposal != null && message.hasOwnProperty("beforeProposal"))
                        object.beforeProposal = $root.ic_nns_common.pb.v1.ProposalId.toObject(message.beforeProposal, options);
                    if (message.excludeTopic && message.excludeTopic.length) {
                        object.excludeTopic = [];
                        for (let j = 0; j < message.excludeTopic.length; ++j)
                            object.excludeTopic[j] = options.enums === String ? $root.ic_nns_governance.pb.v1.Topic[message.excludeTopic[j]] : message.excludeTopic[j];
                    }
                    if (message.includeRewardStatus && message.includeRewardStatus.length) {
                        object.includeRewardStatus = [];
                        for (let j = 0; j < message.includeRewardStatus.length; ++j)
                            object.includeRewardStatus[j] = options.enums === String ? $root.ic_nns_governance.pb.v1.ProposalRewardStatus[message.includeRewardStatus[j]] : message.includeRewardStatus[j];
                    }
                    if (message.includeStatus && message.includeStatus.length) {
                        object.includeStatus = [];
                        for (let j = 0; j < message.includeStatus.length; ++j)
                            object.includeStatus[j] = options.enums === String ? $root.ic_nns_governance.pb.v1.ProposalStatus[message.includeStatus[j]] : message.includeStatus[j];
                    }
                    return object;
                };

                /**
                 * Converts this ListProposalInfo to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListProposalInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListProposalInfo;
            })();

            v1.ListProposalInfoResponse = (function() {

                /**
                 * Properties of a ListProposalInfoResponse.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IListProposalInfoResponse
                 * @property {Array.<ic_nns_governance.pb.v1.IProposalInfo>|null} [proposalInfo] ListProposalInfoResponse proposalInfo
                 */

                /**
                 * Constructs a new ListProposalInfoResponse.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a ListProposalInfoResponse.
                 * @implements IListProposalInfoResponse
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IListProposalInfoResponse=} [properties] Properties to set
                 */
                function ListProposalInfoResponse(properties) {
                    this.proposalInfo = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListProposalInfoResponse proposalInfo.
                 * @member {Array.<ic_nns_governance.pb.v1.IProposalInfo>} proposalInfo
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfoResponse
                 * @instance
                 */
                ListProposalInfoResponse.prototype.proposalInfo = $util.emptyArray;

                /**
                 * Creates a new ListProposalInfoResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfoResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListProposalInfoResponse=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ListProposalInfoResponse} ListProposalInfoResponse instance
                 */
                ListProposalInfoResponse.create = function create(properties) {
                    return new ListProposalInfoResponse(properties);
                };

                /**
                 * Encodes the specified ListProposalInfoResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ListProposalInfoResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfoResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListProposalInfoResponse} message ListProposalInfoResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListProposalInfoResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.proposalInfo != null && message.proposalInfo.length)
                        for (let i = 0; i < message.proposalInfo.length; ++i)
                            $root.ic_nns_governance.pb.v1.ProposalInfo.encode(message.proposalInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ListProposalInfoResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ListProposalInfoResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfoResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListProposalInfoResponse} message ListProposalInfoResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListProposalInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ListProposalInfoResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfoResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ListProposalInfoResponse} ListProposalInfoResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListProposalInfoResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ListProposalInfoResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.proposalInfo && message.proposalInfo.length))
                                message.proposalInfo = [];
                            message.proposalInfo.push($root.ic_nns_governance.pb.v1.ProposalInfo.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ListProposalInfoResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfoResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ListProposalInfoResponse} ListProposalInfoResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListProposalInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ListProposalInfoResponse message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfoResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListProposalInfoResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.proposalInfo != null && message.hasOwnProperty("proposalInfo")) {
                        if (!Array.isArray(message.proposalInfo))
                            return "proposalInfo: array expected";
                        for (let i = 0; i < message.proposalInfo.length; ++i) {
                            let error = $root.ic_nns_governance.pb.v1.ProposalInfo.verify(message.proposalInfo[i]);
                            if (error)
                                return "proposalInfo." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ListProposalInfoResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfoResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ListProposalInfoResponse} ListProposalInfoResponse
                 */
                ListProposalInfoResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ListProposalInfoResponse)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ListProposalInfoResponse();
                    if (object.proposalInfo) {
                        if (!Array.isArray(object.proposalInfo))
                            throw TypeError(".ic_nns_governance.pb.v1.ListProposalInfoResponse.proposalInfo: array expected");
                        message.proposalInfo = [];
                        for (let i = 0; i < object.proposalInfo.length; ++i) {
                            if (typeof object.proposalInfo[i] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ListProposalInfoResponse.proposalInfo: object expected");
                            message.proposalInfo[i] = $root.ic_nns_governance.pb.v1.ProposalInfo.fromObject(object.proposalInfo[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListProposalInfoResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfoResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.ListProposalInfoResponse} message ListProposalInfoResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListProposalInfoResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.proposalInfo = [];
                    if (message.proposalInfo && message.proposalInfo.length) {
                        object.proposalInfo = [];
                        for (let j = 0; j < message.proposalInfo.length; ++j)
                            object.proposalInfo[j] = $root.ic_nns_governance.pb.v1.ProposalInfo.toObject(message.proposalInfo[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ListProposalInfoResponse to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ListProposalInfoResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListProposalInfoResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListProposalInfoResponse;
            })();

            v1.ListNeurons = (function() {

                /**
                 * Properties of a ListNeurons.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IListNeurons
                 * @property {Array.<number|Long>|null} [neuronIds] ListNeurons neuronIds
                 * @property {boolean|null} [includeNeuronsReadableByCaller] ListNeurons includeNeuronsReadableByCaller
                 */

                /**
                 * Constructs a new ListNeurons.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a ListNeurons.
                 * @implements IListNeurons
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IListNeurons=} [properties] Properties to set
                 */
                function ListNeurons(properties) {
                    this.neuronIds = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListNeurons neuronIds.
                 * @member {Array.<number|Long>} neuronIds
                 * @memberof ic_nns_governance.pb.v1.ListNeurons
                 * @instance
                 */
                ListNeurons.prototype.neuronIds = $util.emptyArray;

                /**
                 * ListNeurons includeNeuronsReadableByCaller.
                 * @member {boolean} includeNeuronsReadableByCaller
                 * @memberof ic_nns_governance.pb.v1.ListNeurons
                 * @instance
                 */
                ListNeurons.prototype.includeNeuronsReadableByCaller = false;

                /**
                 * Creates a new ListNeurons instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ListNeurons
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListNeurons=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ListNeurons} ListNeurons instance
                 */
                ListNeurons.create = function create(properties) {
                    return new ListNeurons(properties);
                };

                /**
                 * Encodes the specified ListNeurons message. Does not implicitly {@link ic_nns_governance.pb.v1.ListNeurons.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ListNeurons
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListNeurons} message ListNeurons message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListNeurons.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.neuronIds != null && message.neuronIds.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.neuronIds.length; ++i)
                            writer.fixed64(message.neuronIds[i]);
                        writer.ldelim();
                    }
                    if (message.includeNeuronsReadableByCaller != null && Object.hasOwnProperty.call(message, "includeNeuronsReadableByCaller"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.includeNeuronsReadableByCaller);
                    return writer;
                };

                /**
                 * Encodes the specified ListNeurons message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ListNeurons.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ListNeurons
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListNeurons} message ListNeurons message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListNeurons.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ListNeurons message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ListNeurons
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ListNeurons} ListNeurons
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListNeurons.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ListNeurons();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.neuronIds && message.neuronIds.length))
                                message.neuronIds = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.neuronIds.push(reader.fixed64());
                            } else
                                message.neuronIds.push(reader.fixed64());
                            break;
                        case 2:
                            message.includeNeuronsReadableByCaller = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ListNeurons message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ListNeurons
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ListNeurons} ListNeurons
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListNeurons.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ListNeurons message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ListNeurons
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListNeurons.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.neuronIds != null && message.hasOwnProperty("neuronIds")) {
                        if (!Array.isArray(message.neuronIds))
                            return "neuronIds: array expected";
                        for (let i = 0; i < message.neuronIds.length; ++i)
                            if (!$util.isInteger(message.neuronIds[i]) && !(message.neuronIds[i] && $util.isInteger(message.neuronIds[i].low) && $util.isInteger(message.neuronIds[i].high)))
                                return "neuronIds: integer|Long[] expected";
                    }
                    if (message.includeNeuronsReadableByCaller != null && message.hasOwnProperty("includeNeuronsReadableByCaller"))
                        if (typeof message.includeNeuronsReadableByCaller !== "boolean")
                            return "includeNeuronsReadableByCaller: boolean expected";
                    return null;
                };

                /**
                 * Creates a ListNeurons message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ListNeurons
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ListNeurons} ListNeurons
                 */
                ListNeurons.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ListNeurons)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ListNeurons();
                    if (object.neuronIds) {
                        if (!Array.isArray(object.neuronIds))
                            throw TypeError(".ic_nns_governance.pb.v1.ListNeurons.neuronIds: array expected");
                        message.neuronIds = [];
                        for (let i = 0; i < object.neuronIds.length; ++i)
                            if ($util.Long)
                                (message.neuronIds[i] = $util.Long.fromValue(object.neuronIds[i])).unsigned = false;
                            else if (typeof object.neuronIds[i] === "string")
                                message.neuronIds[i] = parseInt(object.neuronIds[i], 10);
                            else if (typeof object.neuronIds[i] === "number")
                                message.neuronIds[i] = object.neuronIds[i];
                            else if (typeof object.neuronIds[i] === "object")
                                message.neuronIds[i] = new $util.LongBits(object.neuronIds[i].low >>> 0, object.neuronIds[i].high >>> 0).toNumber();
                    }
                    if (object.includeNeuronsReadableByCaller != null)
                        message.includeNeuronsReadableByCaller = Boolean(object.includeNeuronsReadableByCaller);
                    return message;
                };

                /**
                 * Creates a plain object from a ListNeurons message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ListNeurons
                 * @static
                 * @param {ic_nns_governance.pb.v1.ListNeurons} message ListNeurons
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListNeurons.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.neuronIds = [];
                    if (options.defaults)
                        object.includeNeuronsReadableByCaller = false;
                    if (message.neuronIds && message.neuronIds.length) {
                        object.neuronIds = [];
                        for (let j = 0; j < message.neuronIds.length; ++j)
                            if (typeof message.neuronIds[j] === "number")
                                object.neuronIds[j] = options.longs === String ? String(message.neuronIds[j]) : message.neuronIds[j];
                            else
                                object.neuronIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.neuronIds[j]) : options.longs === Number ? new $util.LongBits(message.neuronIds[j].low >>> 0, message.neuronIds[j].high >>> 0).toNumber() : message.neuronIds[j];
                    }
                    if (message.includeNeuronsReadableByCaller != null && message.hasOwnProperty("includeNeuronsReadableByCaller"))
                        object.includeNeuronsReadableByCaller = message.includeNeuronsReadableByCaller;
                    return object;
                };

                /**
                 * Converts this ListNeurons to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ListNeurons
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListNeurons.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListNeurons;
            })();

            v1.ListNeuronsResponse = (function() {

                /**
                 * Properties of a ListNeuronsResponse.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IListNeuronsResponse
                 * @property {Object.<string,ic_nns_governance.pb.v1.INeuronInfo>|null} [neuronInfos] ListNeuronsResponse neuronInfos
                 * @property {Array.<ic_nns_governance.pb.v1.INeuron>|null} [fullNeurons] ListNeuronsResponse fullNeurons
                 */

                /**
                 * Constructs a new ListNeuronsResponse.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a ListNeuronsResponse.
                 * @implements IListNeuronsResponse
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IListNeuronsResponse=} [properties] Properties to set
                 */
                function ListNeuronsResponse(properties) {
                    this.neuronInfos = {};
                    this.fullNeurons = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListNeuronsResponse neuronInfos.
                 * @member {Object.<string,ic_nns_governance.pb.v1.INeuronInfo>} neuronInfos
                 * @memberof ic_nns_governance.pb.v1.ListNeuronsResponse
                 * @instance
                 */
                ListNeuronsResponse.prototype.neuronInfos = $util.emptyObject;

                /**
                 * ListNeuronsResponse fullNeurons.
                 * @member {Array.<ic_nns_governance.pb.v1.INeuron>} fullNeurons
                 * @memberof ic_nns_governance.pb.v1.ListNeuronsResponse
                 * @instance
                 */
                ListNeuronsResponse.prototype.fullNeurons = $util.emptyArray;

                /**
                 * Creates a new ListNeuronsResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ListNeuronsResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListNeuronsResponse=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ListNeuronsResponse} ListNeuronsResponse instance
                 */
                ListNeuronsResponse.create = function create(properties) {
                    return new ListNeuronsResponse(properties);
                };

                /**
                 * Encodes the specified ListNeuronsResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ListNeuronsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ListNeuronsResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListNeuronsResponse} message ListNeuronsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListNeuronsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.neuronInfos != null && Object.hasOwnProperty.call(message, "neuronInfos"))
                        for (let keys = Object.keys(message.neuronInfos), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 1 =*/9).fixed64(keys[i]);
                            $root.ic_nns_governance.pb.v1.NeuronInfo.encode(message.neuronInfos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.fullNeurons != null && message.fullNeurons.length)
                        for (let i = 0; i < message.fullNeurons.length; ++i)
                            $root.ic_nns_governance.pb.v1.Neuron.encode(message.fullNeurons[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ListNeuronsResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ListNeuronsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ListNeuronsResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IListNeuronsResponse} message ListNeuronsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListNeuronsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ListNeuronsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ListNeuronsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ListNeuronsResponse} ListNeuronsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListNeuronsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ListNeuronsResponse(), key, value;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (message.neuronInfos === $util.emptyObject)
                                message.neuronInfos = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = null;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.fixed64();
                                    break;
                                case 2:
                                    value = $root.ic_nns_governance.pb.v1.NeuronInfo.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.neuronInfos[typeof key === "object" ? $util.longToHash(key) : key] = value;
                            break;
                        case 2:
                            if (!(message.fullNeurons && message.fullNeurons.length))
                                message.fullNeurons = [];
                            message.fullNeurons.push($root.ic_nns_governance.pb.v1.Neuron.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ListNeuronsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ListNeuronsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ListNeuronsResponse} ListNeuronsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListNeuronsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ListNeuronsResponse message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ListNeuronsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListNeuronsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.neuronInfos != null && message.hasOwnProperty("neuronInfos")) {
                        if (!$util.isObject(message.neuronInfos))
                            return "neuronInfos: object expected";
                        let key = Object.keys(message.neuronInfos);
                        for (let i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "neuronInfos: integer|Long key{k:fixed64} expected";
                            {
                                let error = $root.ic_nns_governance.pb.v1.NeuronInfo.verify(message.neuronInfos[key[i]]);
                                if (error)
                                    return "neuronInfos." + error;
                            }
                        }
                    }
                    if (message.fullNeurons != null && message.hasOwnProperty("fullNeurons")) {
                        if (!Array.isArray(message.fullNeurons))
                            return "fullNeurons: array expected";
                        for (let i = 0; i < message.fullNeurons.length; ++i) {
                            let error = $root.ic_nns_governance.pb.v1.Neuron.verify(message.fullNeurons[i]);
                            if (error)
                                return "fullNeurons." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ListNeuronsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ListNeuronsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ListNeuronsResponse} ListNeuronsResponse
                 */
                ListNeuronsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ListNeuronsResponse)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ListNeuronsResponse();
                    if (object.neuronInfos) {
                        if (typeof object.neuronInfos !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ListNeuronsResponse.neuronInfos: object expected");
                        message.neuronInfos = {};
                        for (let keys = Object.keys(object.neuronInfos), i = 0; i < keys.length; ++i) {
                            if (typeof object.neuronInfos[keys[i]] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ListNeuronsResponse.neuronInfos: object expected");
                            message.neuronInfos[keys[i]] = $root.ic_nns_governance.pb.v1.NeuronInfo.fromObject(object.neuronInfos[keys[i]]);
                        }
                    }
                    if (object.fullNeurons) {
                        if (!Array.isArray(object.fullNeurons))
                            throw TypeError(".ic_nns_governance.pb.v1.ListNeuronsResponse.fullNeurons: array expected");
                        message.fullNeurons = [];
                        for (let i = 0; i < object.fullNeurons.length; ++i) {
                            if (typeof object.fullNeurons[i] !== "object")
                                throw TypeError(".ic_nns_governance.pb.v1.ListNeuronsResponse.fullNeurons: object expected");
                            message.fullNeurons[i] = $root.ic_nns_governance.pb.v1.Neuron.fromObject(object.fullNeurons[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListNeuronsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ListNeuronsResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.ListNeuronsResponse} message ListNeuronsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListNeuronsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.fullNeurons = [];
                    if (options.objects || options.defaults)
                        object.neuronInfos = {};
                    let keys2;
                    if (message.neuronInfos && (keys2 = Object.keys(message.neuronInfos)).length) {
                        object.neuronInfos = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.neuronInfos[keys2[j]] = $root.ic_nns_governance.pb.v1.NeuronInfo.toObject(message.neuronInfos[keys2[j]], options);
                    }
                    if (message.fullNeurons && message.fullNeurons.length) {
                        object.fullNeurons = [];
                        for (let j = 0; j < message.fullNeurons.length; ++j)
                            object.fullNeurons[j] = $root.ic_nns_governance.pb.v1.Neuron.toObject(message.fullNeurons[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ListNeuronsResponse to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ListNeuronsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListNeuronsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListNeuronsResponse;
            })();

            v1.ClaimOrRefreshNeuronFromAccount = (function() {

                /**
                 * Properties of a ClaimOrRefreshNeuronFromAccount.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IClaimOrRefreshNeuronFromAccount
                 * @property {ic_base_types.pb.v1.IPrincipalId|null} [controller] ClaimOrRefreshNeuronFromAccount controller
                 * @property {number|Long|null} [memo] ClaimOrRefreshNeuronFromAccount memo
                 */

                /**
                 * Constructs a new ClaimOrRefreshNeuronFromAccount.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a ClaimOrRefreshNeuronFromAccount.
                 * @implements IClaimOrRefreshNeuronFromAccount
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IClaimOrRefreshNeuronFromAccount=} [properties] Properties to set
                 */
                function ClaimOrRefreshNeuronFromAccount(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ClaimOrRefreshNeuronFromAccount controller.
                 * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} controller
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount
                 * @instance
                 */
                ClaimOrRefreshNeuronFromAccount.prototype.controller = null;

                /**
                 * ClaimOrRefreshNeuronFromAccount memo.
                 * @member {number|Long} memo
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount
                 * @instance
                 */
                ClaimOrRefreshNeuronFromAccount.prototype.memo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new ClaimOrRefreshNeuronFromAccount instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount
                 * @static
                 * @param {ic_nns_governance.pb.v1.IClaimOrRefreshNeuronFromAccount=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount} ClaimOrRefreshNeuronFromAccount instance
                 */
                ClaimOrRefreshNeuronFromAccount.create = function create(properties) {
                    return new ClaimOrRefreshNeuronFromAccount(properties);
                };

                /**
                 * Encodes the specified ClaimOrRefreshNeuronFromAccount message. Does not implicitly {@link ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount
                 * @static
                 * @param {ic_nns_governance.pb.v1.IClaimOrRefreshNeuronFromAccount} message ClaimOrRefreshNeuronFromAccount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClaimOrRefreshNeuronFromAccount.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.controller != null && Object.hasOwnProperty.call(message, "controller"))
                        $root.ic_base_types.pb.v1.PrincipalId.encode(message.controller, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.memo);
                    return writer;
                };

                /**
                 * Encodes the specified ClaimOrRefreshNeuronFromAccount message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount
                 * @static
                 * @param {ic_nns_governance.pb.v1.IClaimOrRefreshNeuronFromAccount} message ClaimOrRefreshNeuronFromAccount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClaimOrRefreshNeuronFromAccount.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ClaimOrRefreshNeuronFromAccount message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount} ClaimOrRefreshNeuronFromAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClaimOrRefreshNeuronFromAccount.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.controller = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.memo = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ClaimOrRefreshNeuronFromAccount message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount} ClaimOrRefreshNeuronFromAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClaimOrRefreshNeuronFromAccount.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ClaimOrRefreshNeuronFromAccount message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClaimOrRefreshNeuronFromAccount.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.controller != null && message.hasOwnProperty("controller")) {
                        let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.controller);
                        if (error)
                            return "controller." + error;
                    }
                    if (message.memo != null && message.hasOwnProperty("memo"))
                        if (!$util.isInteger(message.memo) && !(message.memo && $util.isInteger(message.memo.low) && $util.isInteger(message.memo.high)))
                            return "memo: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ClaimOrRefreshNeuronFromAccount message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount} ClaimOrRefreshNeuronFromAccount
                 */
                ClaimOrRefreshNeuronFromAccount.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount();
                    if (object.controller != null) {
                        if (typeof object.controller !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount.controller: object expected");
                        message.controller = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.controller);
                    }
                    if (object.memo != null)
                        if ($util.Long)
                            (message.memo = $util.Long.fromValue(object.memo)).unsigned = true;
                        else if (typeof object.memo === "string")
                            message.memo = parseInt(object.memo, 10);
                        else if (typeof object.memo === "number")
                            message.memo = object.memo;
                        else if (typeof object.memo === "object")
                            message.memo = new $util.LongBits(object.memo.low >>> 0, object.memo.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a ClaimOrRefreshNeuronFromAccount message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount
                 * @static
                 * @param {ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount} message ClaimOrRefreshNeuronFromAccount
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClaimOrRefreshNeuronFromAccount.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.controller = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.memo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.memo = options.longs === String ? "0" : 0;
                    }
                    if (message.controller != null && message.hasOwnProperty("controller"))
                        object.controller = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.controller, options);
                    if (message.memo != null && message.hasOwnProperty("memo"))
                        if (typeof message.memo === "number")
                            object.memo = options.longs === String ? String(message.memo) : message.memo;
                        else
                            object.memo = options.longs === String ? $util.Long.prototype.toString.call(message.memo) : options.longs === Number ? new $util.LongBits(message.memo.low >>> 0, message.memo.high >>> 0).toNumber(true) : message.memo;
                    return object;
                };

                /**
                 * Converts this ClaimOrRefreshNeuronFromAccount to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccount
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ClaimOrRefreshNeuronFromAccount.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ClaimOrRefreshNeuronFromAccount;
            })();

            v1.ClaimOrRefreshNeuronFromAccountResponse = (function() {

                /**
                 * Properties of a ClaimOrRefreshNeuronFromAccountResponse.
                 * @memberof ic_nns_governance.pb.v1
                 * @interface IClaimOrRefreshNeuronFromAccountResponse
                 * @property {ic_nns_governance.pb.v1.IGovernanceError|null} [error] ClaimOrRefreshNeuronFromAccountResponse error
                 * @property {ic_nns_common.pb.v1.INeuronId|null} [neuronId] ClaimOrRefreshNeuronFromAccountResponse neuronId
                 */

                /**
                 * Constructs a new ClaimOrRefreshNeuronFromAccountResponse.
                 * @memberof ic_nns_governance.pb.v1
                 * @classdesc Represents a ClaimOrRefreshNeuronFromAccountResponse.
                 * @implements IClaimOrRefreshNeuronFromAccountResponse
                 * @constructor
                 * @param {ic_nns_governance.pb.v1.IClaimOrRefreshNeuronFromAccountResponse=} [properties] Properties to set
                 */
                function ClaimOrRefreshNeuronFromAccountResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ClaimOrRefreshNeuronFromAccountResponse error.
                 * @member {ic_nns_governance.pb.v1.IGovernanceError|null|undefined} error
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @instance
                 */
                ClaimOrRefreshNeuronFromAccountResponse.prototype.error = null;

                /**
                 * ClaimOrRefreshNeuronFromAccountResponse neuronId.
                 * @member {ic_nns_common.pb.v1.INeuronId|null|undefined} neuronId
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @instance
                 */
                ClaimOrRefreshNeuronFromAccountResponse.prototype.neuronId = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * ClaimOrRefreshNeuronFromAccountResponse result.
                 * @member {"error"|"neuronId"|undefined} result
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @instance
                 */
                Object.defineProperty(ClaimOrRefreshNeuronFromAccountResponse.prototype, "result", {
                    get: $util.oneOfGetter($oneOfFields = ["error", "neuronId"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new ClaimOrRefreshNeuronFromAccountResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IClaimOrRefreshNeuronFromAccountResponse=} [properties] Properties to set
                 * @returns {ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse} ClaimOrRefreshNeuronFromAccountResponse instance
                 */
                ClaimOrRefreshNeuronFromAccountResponse.create = function create(properties) {
                    return new ClaimOrRefreshNeuronFromAccountResponse(properties);
                };

                /**
                 * Encodes the specified ClaimOrRefreshNeuronFromAccountResponse message. Does not implicitly {@link ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IClaimOrRefreshNeuronFromAccountResponse} message ClaimOrRefreshNeuronFromAccountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClaimOrRefreshNeuronFromAccountResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.ic_nns_governance.pb.v1.GovernanceError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.neuronId != null && Object.hasOwnProperty.call(message, "neuronId"))
                        $root.ic_nns_common.pb.v1.NeuronId.encode(message.neuronId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ClaimOrRefreshNeuronFromAccountResponse message, length delimited. Does not implicitly {@link ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.IClaimOrRefreshNeuronFromAccountResponse} message ClaimOrRefreshNeuronFromAccountResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClaimOrRefreshNeuronFromAccountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ClaimOrRefreshNeuronFromAccountResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse} ClaimOrRefreshNeuronFromAccountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClaimOrRefreshNeuronFromAccountResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.ic_nns_governance.pb.v1.GovernanceError.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.neuronId = $root.ic_nns_common.pb.v1.NeuronId.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ClaimOrRefreshNeuronFromAccountResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse} ClaimOrRefreshNeuronFromAccountResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClaimOrRefreshNeuronFromAccountResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ClaimOrRefreshNeuronFromAccountResponse message.
                 * @function verify
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClaimOrRefreshNeuronFromAccountResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.error != null && message.hasOwnProperty("error")) {
                        properties.result = 1;
                        {
                            let error = $root.ic_nns_governance.pb.v1.GovernanceError.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                    }
                    if (message.neuronId != null && message.hasOwnProperty("neuronId")) {
                        if (properties.result === 1)
                            return "result: multiple values";
                        properties.result = 1;
                        {
                            let error = $root.ic_nns_common.pb.v1.NeuronId.verify(message.neuronId);
                            if (error)
                                return "neuronId." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ClaimOrRefreshNeuronFromAccountResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse} ClaimOrRefreshNeuronFromAccountResponse
                 */
                ClaimOrRefreshNeuronFromAccountResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse)
                        return object;
                    let message = new $root.ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse.error: object expected");
                        message.error = $root.ic_nns_governance.pb.v1.GovernanceError.fromObject(object.error);
                    }
                    if (object.neuronId != null) {
                        if (typeof object.neuronId !== "object")
                            throw TypeError(".ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse.neuronId: object expected");
                        message.neuronId = $root.ic_nns_common.pb.v1.NeuronId.fromObject(object.neuronId);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ClaimOrRefreshNeuronFromAccountResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @static
                 * @param {ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse} message ClaimOrRefreshNeuronFromAccountResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClaimOrRefreshNeuronFromAccountResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.error != null && message.hasOwnProperty("error")) {
                        object.error = $root.ic_nns_governance.pb.v1.GovernanceError.toObject(message.error, options);
                        if (options.oneofs)
                            object.result = "error";
                    }
                    if (message.neuronId != null && message.hasOwnProperty("neuronId")) {
                        object.neuronId = $root.ic_nns_common.pb.v1.NeuronId.toObject(message.neuronId, options);
                        if (options.oneofs)
                            object.result = "neuronId";
                    }
                    return object;
                };

                /**
                 * Converts this ClaimOrRefreshNeuronFromAccountResponse to JSON.
                 * @function toJSON
                 * @memberof ic_nns_governance.pb.v1.ClaimOrRefreshNeuronFromAccountResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ClaimOrRefreshNeuronFromAccountResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ClaimOrRefreshNeuronFromAccountResponse;
            })();

            return v1;
        })();

        return pb;
    })();

    return ic_nns_governance;
})();

export const ic_base_types = $root.ic_base_types = (() => {

    /**
     * Namespace ic_base_types.
     * @exports ic_base_types
     * @namespace
     */
    const ic_base_types = {};

    ic_base_types.pb = (function() {

        /**
         * Namespace pb.
         * @memberof ic_base_types
         * @namespace
         */
        const pb = {};

        pb.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof ic_base_types.pb
             * @namespace
             */
            const v1 = {};

            v1.PrincipalId = (function() {

                /**
                 * Properties of a PrincipalId.
                 * @memberof ic_base_types.pb.v1
                 * @interface IPrincipalId
                 * @property {Uint8Array|null} [serializedId] PrincipalId serializedId
                 */

                /**
                 * Constructs a new PrincipalId.
                 * @memberof ic_base_types.pb.v1
                 * @classdesc Represents a PrincipalId.
                 * @implements IPrincipalId
                 * @constructor
                 * @param {ic_base_types.pb.v1.IPrincipalId=} [properties] Properties to set
                 */
                function PrincipalId(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PrincipalId serializedId.
                 * @member {Uint8Array} serializedId
                 * @memberof ic_base_types.pb.v1.PrincipalId
                 * @instance
                 */
                PrincipalId.prototype.serializedId = $util.newBuffer([]);

                /**
                 * Creates a new PrincipalId instance using the specified properties.
                 * @function create
                 * @memberof ic_base_types.pb.v1.PrincipalId
                 * @static
                 * @param {ic_base_types.pb.v1.IPrincipalId=} [properties] Properties to set
                 * @returns {ic_base_types.pb.v1.PrincipalId} PrincipalId instance
                 */
                PrincipalId.create = function create(properties) {
                    return new PrincipalId(properties);
                };

                /**
                 * Encodes the specified PrincipalId message. Does not implicitly {@link ic_base_types.pb.v1.PrincipalId.verify|verify} messages.
                 * @function encode
                 * @memberof ic_base_types.pb.v1.PrincipalId
                 * @static
                 * @param {ic_base_types.pb.v1.IPrincipalId} message PrincipalId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PrincipalId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.serializedId != null && Object.hasOwnProperty.call(message, "serializedId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.serializedId);
                    return writer;
                };

                /**
                 * Encodes the specified PrincipalId message, length delimited. Does not implicitly {@link ic_base_types.pb.v1.PrincipalId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_base_types.pb.v1.PrincipalId
                 * @static
                 * @param {ic_base_types.pb.v1.IPrincipalId} message PrincipalId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PrincipalId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PrincipalId message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_base_types.pb.v1.PrincipalId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_base_types.pb.v1.PrincipalId} PrincipalId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PrincipalId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_base_types.pb.v1.PrincipalId();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.serializedId = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PrincipalId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_base_types.pb.v1.PrincipalId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_base_types.pb.v1.PrincipalId} PrincipalId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PrincipalId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PrincipalId message.
                 * @function verify
                 * @memberof ic_base_types.pb.v1.PrincipalId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PrincipalId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.serializedId != null && message.hasOwnProperty("serializedId"))
                        if (!(message.serializedId && typeof message.serializedId.length === "number" || $util.isString(message.serializedId)))
                            return "serializedId: buffer expected";
                    return null;
                };

                /**
                 * Creates a PrincipalId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_base_types.pb.v1.PrincipalId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_base_types.pb.v1.PrincipalId} PrincipalId
                 */
                PrincipalId.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_base_types.pb.v1.PrincipalId)
                        return object;
                    let message = new $root.ic_base_types.pb.v1.PrincipalId();
                    if (object.serializedId != null)
                        if (typeof object.serializedId === "string")
                            $util.base64.decode(object.serializedId, message.serializedId = $util.newBuffer($util.base64.length(object.serializedId)), 0);
                        else if (object.serializedId.length)
                            message.serializedId = object.serializedId;
                    return message;
                };

                /**
                 * Creates a plain object from a PrincipalId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_base_types.pb.v1.PrincipalId
                 * @static
                 * @param {ic_base_types.pb.v1.PrincipalId} message PrincipalId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PrincipalId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.serializedId = "";
                        else {
                            object.serializedId = [];
                            if (options.bytes !== Array)
                                object.serializedId = $util.newBuffer(object.serializedId);
                        }
                    if (message.serializedId != null && message.hasOwnProperty("serializedId"))
                        object.serializedId = options.bytes === String ? $util.base64.encode(message.serializedId, 0, message.serializedId.length) : options.bytes === Array ? Array.prototype.slice.call(message.serializedId) : message.serializedId;
                    return object;
                };

                /**
                 * Converts this PrincipalId to JSON.
                 * @function toJSON
                 * @memberof ic_base_types.pb.v1.PrincipalId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PrincipalId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PrincipalId;
            })();

            return v1;
        })();

        return pb;
    })();

    return ic_base_types;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (let i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (let i = 0; i < message.file.length; ++i) {
                        let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (let i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (let j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (let i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (let i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (let i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.publicDependency && message.publicDependency.length))
                            message.publicDependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.publicDependency.push(reader.int32());
                        } else
                            message.publicDependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weakDependency && message.weakDependency.length))
                            message.weakDependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weakDependency.push(reader.int32());
                        } else
                            message.weakDependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.messageType && message.messageType.length))
                            message.messageType = [];
                        message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (let i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (let i = 0; i < message.messageType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (let i = 0; i < message.service.length; ++i) {
                        let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    let error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (let i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (let i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (let i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (let i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (let i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (let j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (let j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (let j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (let j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (let j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (let i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (let i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (let i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (let i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (let i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (let i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nestedType && message.nestedType.length))
                            message.nestedType = [];
                        message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extensionRange && message.extensionRange.length))
                            message.extensionRange = [];
                        message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneofDecl && message.oneofDecl.length))
                            message.oneofDecl = [];
                        message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reservedRange && message.reservedRange.length))
                            message.reservedRange = [];
                        message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reservedName && message.reservedName.length))
                            message.reservedName = [];
                        message.reservedName.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (let i = 0; i < message.field.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (let i = 0; i < message.nestedType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (let i = 0; i < message.extensionRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (let i = 0; i < message.oneofDecl.length; ++i) {
                        let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                let message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (let i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (let i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (let i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (let i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (let i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (let i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (let j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (let j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (let j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (let j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (let j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (let j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.typeName = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.defaultValue = reader.string();
                        break;
                    case 9:
                        message.oneofIndex = reader.int32();
                        break;
                    case 10:
                        message.jsonName = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (let i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (let i = 0; i < message.value.length; ++i) {
                        let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (let i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (let j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (let i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (let i = 0; i < message.method.length; ++i) {
                        let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (let i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (let j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.inputType = reader.string();
                        break;
                    case 3:
                        message.outputType = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clientStreaming = reader.bool();
                        break;
                    case 6:
                        message.serverStreaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, "javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, "javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.javaPackage = reader.string();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.string();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.bool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.bool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.bool();
                        break;
                    case 9:
                        message.optimizeFor = reader.int32();
                        break;
                    case 11:
                        message.goPackage = reader.string();
                        break;
                    case 16:
                        message.ccGenericServices = reader.bool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.bool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.bool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.string();
                        break;
                    case 37:
                        message.csharpNamespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                let message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = false;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             * @property {boolean|null} [".ic_base_types.pb.v1.tuiSignedMessage"] MessageOptions .ic_base_types.pb.v1.tuiSignedMessage
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MessageOptions .ic_base_types.pb.v1.tuiSignedMessage.
             * @member {boolean} .ic_base_types.pb.v1.tuiSignedMessage
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".ic_base_types.pb.v1.tuiSignedMessage"] = false;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, "messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".ic_base_types.pb.v1.tuiSignedMessage"] != null && Object.hasOwnProperty.call(message, ".ic_base_types.pb.v1.tuiSignedMessage"))
                    writer.uint32(/* id 20000, wireType 0 =*/160000).bool(message[".ic_base_types.pb.v1.tuiSignedMessage"]);
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageSetWireFormat = reader.bool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.mapEntry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 20000:
                        message[".ic_base_types.pb.v1.tuiSignedMessage"] = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".ic_base_types.pb.v1.tuiSignedMessage"] != null && message.hasOwnProperty(".ic_base_types.pb.v1.tuiSignedMessage"))
                    if (typeof message[".ic_base_types.pb.v1.tuiSignedMessage"] !== "boolean")
                        return ".ic_base_types.pb.v1.tuiSignedMessage: boolean expected";
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                let message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".ic_base_types.pb.v1.tuiSignedMessage"] != null)
                    message[".ic_base_types.pb.v1.tuiSignedMessage"] = Boolean(object[".ic_base_types.pb.v1.tuiSignedMessage"]);
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                    object[".ic_base_types.pb.v1.tuiSignedMessage"] = false;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".ic_base_types.pb.v1.tuiSignedMessage"] != null && message.hasOwnProperty(".ic_base_types.pb.v1.tuiSignedMessage"))
                    object[".ic_base_types.pb.v1.tuiSignedMessage"] = message[".ic_base_types.pb.v1.tuiSignedMessage"];
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             * @property {boolean|null} [".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"] FieldOptions .ic_base_types.pb.v1.tuiSignedDisplayQ2_2021
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * FieldOptions .ic_base_types.pb.v1.tuiSignedDisplayQ2_2021.
             * @member {boolean} .ic_base_types.pb.v1.tuiSignedDisplayQ2_2021
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"] = false;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"] != null && Object.hasOwnProperty.call(message, ".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"))
                    writer.uint32(/* id 20001, wireType 0 =*/160008).bool(message[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"]);
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.int32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.int32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 20001:
                        message[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"] = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"] != null && message.hasOwnProperty(".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"))
                    if (typeof message[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"] !== "boolean")
                        return ".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021: boolean expected";
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                let message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"] != null)
                    message[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"] = Boolean(object[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"]);
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                    object[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"] = false;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"] != null && message.hasOwnProperty(".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"))
                    object[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"] = message[".ic_base_types.pb.v1.tuiSignedDisplayQ2_2021"];
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                let message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allowAlias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                let message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                let message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                let message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                let message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (let i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifierValue = reader.string();
                        break;
                    case 4:
                        message.positiveIntValue = reader.uint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.int64();
                        break;
                    case 6:
                        message.doubleValue = reader.double();
                        break;
                    case 7:
                        message.stringValue = reader.bytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (let i = 0; i < message.name.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                let message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (let i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (let j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namePart = reader.string();
                            break;
                        case 2:
                            message.isExtension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    let message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (let i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (let i = 0; i < message.location.length; ++i) {
                        let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                let message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (let i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (let j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leadingComments = reader.string();
                            break;
                        case 4:
                            message.trailingComments = reader.string();
                            break;
                        case 6:
                            if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                message.leadingDetachedComments = [];
                            message.leadingDetachedComments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (let i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    let message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (let i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (let i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (let j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (let j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (let i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (let i = 0; i < message.annotation.length; ++i) {
                        let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                let message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (let i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (let j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.sourceFile = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    let message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        return protobuf;
    })();

    return google;
})();

export const ic_ledger = $root.ic_ledger = (() => {

    /**
     * Namespace ic_ledger.
     * @exports ic_ledger
     * @namespace
     */
    const ic_ledger = {};

    ic_ledger.pb = (function() {

        /**
         * Namespace pb.
         * @memberof ic_ledger
         * @namespace
         */
        const pb = {};

        pb.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof ic_ledger.pb
             * @namespace
             */
            const v1 = {};

            v1.LedgerInit = (function() {

                /**
                 * Properties of a LedgerInit.
                 * @memberof ic_ledger.pb.v1
                 * @interface ILedgerInit
                 * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [mintingAccount] LedgerInit mintingAccount
                 * @property {Array.<ic_ledger.pb.v1.IAccount>|null} [initialValues] LedgerInit initialValues
                 * @property {ic_base_types.pb.v1.IPrincipalId|null} [archiveCanister] LedgerInit archiveCanister
                 * @property {number|null} [maxMessageSizeBytes] LedgerInit maxMessageSizeBytes
                 */

                /**
                 * Constructs a new LedgerInit.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a LedgerInit.
                 * @implements ILedgerInit
                 * @constructor
                 * @param {ic_ledger.pb.v1.ILedgerInit=} [properties] Properties to set
                 */
                function LedgerInit(properties) {
                    this.initialValues = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LedgerInit mintingAccount.
                 * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} mintingAccount
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @instance
                 */
                LedgerInit.prototype.mintingAccount = null;

                /**
                 * LedgerInit initialValues.
                 * @member {Array.<ic_ledger.pb.v1.IAccount>} initialValues
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @instance
                 */
                LedgerInit.prototype.initialValues = $util.emptyArray;

                /**
                 * LedgerInit archiveCanister.
                 * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} archiveCanister
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @instance
                 */
                LedgerInit.prototype.archiveCanister = null;

                /**
                 * LedgerInit maxMessageSizeBytes.
                 * @member {number} maxMessageSizeBytes
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @instance
                 */
                LedgerInit.prototype.maxMessageSizeBytes = 0;

                /**
                 * Creates a new LedgerInit instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @static
                 * @param {ic_ledger.pb.v1.ILedgerInit=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.LedgerInit} LedgerInit instance
                 */
                LedgerInit.create = function create(properties) {
                    return new LedgerInit(properties);
                };

                /**
                 * Encodes the specified LedgerInit message. Does not implicitly {@link ic_ledger.pb.v1.LedgerInit.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @static
                 * @param {ic_ledger.pb.v1.ILedgerInit} message LedgerInit message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LedgerInit.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mintingAccount != null && Object.hasOwnProperty.call(message, "mintingAccount"))
                        $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.mintingAccount, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.initialValues != null && message.initialValues.length)
                        for (let i = 0; i < message.initialValues.length; ++i)
                            $root.ic_ledger.pb.v1.Account.encode(message.initialValues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.archiveCanister != null && Object.hasOwnProperty.call(message, "archiveCanister"))
                        $root.ic_base_types.pb.v1.PrincipalId.encode(message.archiveCanister, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.maxMessageSizeBytes != null && Object.hasOwnProperty.call(message, "maxMessageSizeBytes"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.maxMessageSizeBytes);
                    return writer;
                };

                /**
                 * Encodes the specified LedgerInit message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.LedgerInit.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @static
                 * @param {ic_ledger.pb.v1.ILedgerInit} message LedgerInit message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LedgerInit.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LedgerInit message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.LedgerInit} LedgerInit
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LedgerInit.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.LedgerInit();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mintingAccount = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.initialValues && message.initialValues.length))
                                message.initialValues = [];
                            message.initialValues.push($root.ic_ledger.pb.v1.Account.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.archiveCanister = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.maxMessageSizeBytes = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LedgerInit message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.LedgerInit} LedgerInit
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LedgerInit.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LedgerInit message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LedgerInit.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mintingAccount != null && message.hasOwnProperty("mintingAccount")) {
                        let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.mintingAccount);
                        if (error)
                            return "mintingAccount." + error;
                    }
                    if (message.initialValues != null && message.hasOwnProperty("initialValues")) {
                        if (!Array.isArray(message.initialValues))
                            return "initialValues: array expected";
                        for (let i = 0; i < message.initialValues.length; ++i) {
                            let error = $root.ic_ledger.pb.v1.Account.verify(message.initialValues[i]);
                            if (error)
                                return "initialValues." + error;
                        }
                    }
                    if (message.archiveCanister != null && message.hasOwnProperty("archiveCanister")) {
                        let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.archiveCanister);
                        if (error)
                            return "archiveCanister." + error;
                    }
                    if (message.maxMessageSizeBytes != null && message.hasOwnProperty("maxMessageSizeBytes"))
                        if (!$util.isInteger(message.maxMessageSizeBytes))
                            return "maxMessageSizeBytes: integer expected";
                    return null;
                };

                /**
                 * Creates a LedgerInit message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.LedgerInit} LedgerInit
                 */
                LedgerInit.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.LedgerInit)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.LedgerInit();
                    if (object.mintingAccount != null) {
                        if (typeof object.mintingAccount !== "object")
                            throw TypeError(".ic_ledger.pb.v1.LedgerInit.mintingAccount: object expected");
                        message.mintingAccount = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.mintingAccount);
                    }
                    if (object.initialValues) {
                        if (!Array.isArray(object.initialValues))
                            throw TypeError(".ic_ledger.pb.v1.LedgerInit.initialValues: array expected");
                        message.initialValues = [];
                        for (let i = 0; i < object.initialValues.length; ++i) {
                            if (typeof object.initialValues[i] !== "object")
                                throw TypeError(".ic_ledger.pb.v1.LedgerInit.initialValues: object expected");
                            message.initialValues[i] = $root.ic_ledger.pb.v1.Account.fromObject(object.initialValues[i]);
                        }
                    }
                    if (object.archiveCanister != null) {
                        if (typeof object.archiveCanister !== "object")
                            throw TypeError(".ic_ledger.pb.v1.LedgerInit.archiveCanister: object expected");
                        message.archiveCanister = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.archiveCanister);
                    }
                    if (object.maxMessageSizeBytes != null)
                        message.maxMessageSizeBytes = object.maxMessageSizeBytes >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a LedgerInit message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @static
                 * @param {ic_ledger.pb.v1.LedgerInit} message LedgerInit
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LedgerInit.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.initialValues = [];
                    if (options.defaults) {
                        object.mintingAccount = null;
                        object.archiveCanister = null;
                        object.maxMessageSizeBytes = 0;
                    }
                    if (message.mintingAccount != null && message.hasOwnProperty("mintingAccount"))
                        object.mintingAccount = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.mintingAccount, options);
                    if (message.initialValues && message.initialValues.length) {
                        object.initialValues = [];
                        for (let j = 0; j < message.initialValues.length; ++j)
                            object.initialValues[j] = $root.ic_ledger.pb.v1.Account.toObject(message.initialValues[j], options);
                    }
                    if (message.archiveCanister != null && message.hasOwnProperty("archiveCanister"))
                        object.archiveCanister = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.archiveCanister, options);
                    if (message.maxMessageSizeBytes != null && message.hasOwnProperty("maxMessageSizeBytes"))
                        object.maxMessageSizeBytes = message.maxMessageSizeBytes;
                    return object;
                };

                /**
                 * Converts this LedgerInit to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.LedgerInit
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LedgerInit.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LedgerInit;
            })();

            v1.LedgerUpgrade = (function() {

                /**
                 * Properties of a LedgerUpgrade.
                 * @memberof ic_ledger.pb.v1
                 * @interface ILedgerUpgrade
                 */

                /**
                 * Constructs a new LedgerUpgrade.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a LedgerUpgrade.
                 * @implements ILedgerUpgrade
                 * @constructor
                 * @param {ic_ledger.pb.v1.ILedgerUpgrade=} [properties] Properties to set
                 */
                function LedgerUpgrade(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new LedgerUpgrade instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.LedgerUpgrade
                 * @static
                 * @param {ic_ledger.pb.v1.ILedgerUpgrade=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.LedgerUpgrade} LedgerUpgrade instance
                 */
                LedgerUpgrade.create = function create(properties) {
                    return new LedgerUpgrade(properties);
                };

                /**
                 * Encodes the specified LedgerUpgrade message. Does not implicitly {@link ic_ledger.pb.v1.LedgerUpgrade.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.LedgerUpgrade
                 * @static
                 * @param {ic_ledger.pb.v1.ILedgerUpgrade} message LedgerUpgrade message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LedgerUpgrade.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified LedgerUpgrade message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.LedgerUpgrade.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.LedgerUpgrade
                 * @static
                 * @param {ic_ledger.pb.v1.ILedgerUpgrade} message LedgerUpgrade message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LedgerUpgrade.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LedgerUpgrade message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.LedgerUpgrade
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.LedgerUpgrade} LedgerUpgrade
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LedgerUpgrade.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.LedgerUpgrade();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LedgerUpgrade message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.LedgerUpgrade
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.LedgerUpgrade} LedgerUpgrade
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LedgerUpgrade.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LedgerUpgrade message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.LedgerUpgrade
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LedgerUpgrade.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a LedgerUpgrade message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.LedgerUpgrade
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.LedgerUpgrade} LedgerUpgrade
                 */
                LedgerUpgrade.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.LedgerUpgrade)
                        return object;
                    return new $root.ic_ledger.pb.v1.LedgerUpgrade();
                };

                /**
                 * Creates a plain object from a LedgerUpgrade message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.LedgerUpgrade
                 * @static
                 * @param {ic_ledger.pb.v1.LedgerUpgrade} message LedgerUpgrade
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LedgerUpgrade.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this LedgerUpgrade to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.LedgerUpgrade
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LedgerUpgrade.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LedgerUpgrade;
            })();

            v1.SendRequest = (function() {

                /**
                 * Properties of a SendRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface ISendRequest
                 * @property {ic_ledger.pb.v1.IMemo|null} [memo] SendRequest memo
                 * @property {ic_ledger.pb.v1.IPayment|null} [payment] SendRequest payment
                 * @property {ic_ledger.pb.v1.IICPTs|null} [maxFee] SendRequest maxFee
                 * @property {ic_ledger.pb.v1.ISubaccount|null} [fromSubaccount] SendRequest fromSubaccount
                 * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [to] SendRequest to
                 * @property {ic_ledger.pb.v1.IBlockHeight|null} [createdAt] SendRequest createdAt
                 * @property {ic_ledger.pb.v1.ITimeStamp|null} [createdAtTime] SendRequest createdAtTime
                 */

                /**
                 * Constructs a new SendRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a SendRequest.
                 * @implements ISendRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.ISendRequest=} [properties] Properties to set
                 */
                function SendRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SendRequest memo.
                 * @member {ic_ledger.pb.v1.IMemo|null|undefined} memo
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @instance
                 */
                SendRequest.prototype.memo = null;

                /**
                 * SendRequest payment.
                 * @member {ic_ledger.pb.v1.IPayment|null|undefined} payment
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @instance
                 */
                SendRequest.prototype.payment = null;

                /**
                 * SendRequest maxFee.
                 * @member {ic_ledger.pb.v1.IICPTs|null|undefined} maxFee
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @instance
                 */
                SendRequest.prototype.maxFee = null;

                /**
                 * SendRequest fromSubaccount.
                 * @member {ic_ledger.pb.v1.ISubaccount|null|undefined} fromSubaccount
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @instance
                 */
                SendRequest.prototype.fromSubaccount = null;

                /**
                 * SendRequest to.
                 * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} to
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @instance
                 */
                SendRequest.prototype.to = null;

                /**
                 * SendRequest createdAt.
                 * @member {ic_ledger.pb.v1.IBlockHeight|null|undefined} createdAt
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @instance
                 */
                SendRequest.prototype.createdAt = null;

                /**
                 * SendRequest createdAtTime.
                 * @member {ic_ledger.pb.v1.ITimeStamp|null|undefined} createdAtTime
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @instance
                 */
                SendRequest.prototype.createdAtTime = null;

                /**
                 * Creates a new SendRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ISendRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.SendRequest} SendRequest instance
                 */
                SendRequest.create = function create(properties) {
                    return new SendRequest(properties);
                };

                /**
                 * Encodes the specified SendRequest message. Does not implicitly {@link ic_ledger.pb.v1.SendRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ISendRequest} message SendRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SendRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                        $root.ic_ledger.pb.v1.Memo.encode(message.memo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.payment != null && Object.hasOwnProperty.call(message, "payment"))
                        $root.ic_ledger.pb.v1.Payment.encode(message.payment, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.maxFee != null && Object.hasOwnProperty.call(message, "maxFee"))
                        $root.ic_ledger.pb.v1.ICPTs.encode(message.maxFee, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.fromSubaccount != null && Object.hasOwnProperty.call(message, "fromSubaccount"))
                        $root.ic_ledger.pb.v1.Subaccount.encode(message.fromSubaccount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                        $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.to, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.createdAt != null && Object.hasOwnProperty.call(message, "createdAt"))
                        $root.ic_ledger.pb.v1.BlockHeight.encode(message.createdAt, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.createdAtTime != null && Object.hasOwnProperty.call(message, "createdAtTime"))
                        $root.ic_ledger.pb.v1.TimeStamp.encode(message.createdAtTime, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SendRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.SendRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ISendRequest} message SendRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SendRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SendRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.SendRequest} SendRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SendRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.SendRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.memo = $root.ic_ledger.pb.v1.Memo.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.payment = $root.ic_ledger.pb.v1.Payment.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.maxFee = $root.ic_ledger.pb.v1.ICPTs.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.fromSubaccount = $root.ic_ledger.pb.v1.Subaccount.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.to = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.createdAt = $root.ic_ledger.pb.v1.BlockHeight.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.createdAtTime = $root.ic_ledger.pb.v1.TimeStamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SendRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.SendRequest} SendRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SendRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SendRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SendRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.memo != null && message.hasOwnProperty("memo")) {
                        let error = $root.ic_ledger.pb.v1.Memo.verify(message.memo);
                        if (error)
                            return "memo." + error;
                    }
                    if (message.payment != null && message.hasOwnProperty("payment")) {
                        let error = $root.ic_ledger.pb.v1.Payment.verify(message.payment);
                        if (error)
                            return "payment." + error;
                    }
                    if (message.maxFee != null && message.hasOwnProperty("maxFee")) {
                        let error = $root.ic_ledger.pb.v1.ICPTs.verify(message.maxFee);
                        if (error)
                            return "maxFee." + error;
                    }
                    if (message.fromSubaccount != null && message.hasOwnProperty("fromSubaccount")) {
                        let error = $root.ic_ledger.pb.v1.Subaccount.verify(message.fromSubaccount);
                        if (error)
                            return "fromSubaccount." + error;
                    }
                    if (message.to != null && message.hasOwnProperty("to")) {
                        let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.to);
                        if (error)
                            return "to." + error;
                    }
                    if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                        let error = $root.ic_ledger.pb.v1.BlockHeight.verify(message.createdAt);
                        if (error)
                            return "createdAt." + error;
                    }
                    if (message.createdAtTime != null && message.hasOwnProperty("createdAtTime")) {
                        let error = $root.ic_ledger.pb.v1.TimeStamp.verify(message.createdAtTime);
                        if (error)
                            return "createdAtTime." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SendRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.SendRequest} SendRequest
                 */
                SendRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.SendRequest)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.SendRequest();
                    if (object.memo != null) {
                        if (typeof object.memo !== "object")
                            throw TypeError(".ic_ledger.pb.v1.SendRequest.memo: object expected");
                        message.memo = $root.ic_ledger.pb.v1.Memo.fromObject(object.memo);
                    }
                    if (object.payment != null) {
                        if (typeof object.payment !== "object")
                            throw TypeError(".ic_ledger.pb.v1.SendRequest.payment: object expected");
                        message.payment = $root.ic_ledger.pb.v1.Payment.fromObject(object.payment);
                    }
                    if (object.maxFee != null) {
                        if (typeof object.maxFee !== "object")
                            throw TypeError(".ic_ledger.pb.v1.SendRequest.maxFee: object expected");
                        message.maxFee = $root.ic_ledger.pb.v1.ICPTs.fromObject(object.maxFee);
                    }
                    if (object.fromSubaccount != null) {
                        if (typeof object.fromSubaccount !== "object")
                            throw TypeError(".ic_ledger.pb.v1.SendRequest.fromSubaccount: object expected");
                        message.fromSubaccount = $root.ic_ledger.pb.v1.Subaccount.fromObject(object.fromSubaccount);
                    }
                    if (object.to != null) {
                        if (typeof object.to !== "object")
                            throw TypeError(".ic_ledger.pb.v1.SendRequest.to: object expected");
                        message.to = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.to);
                    }
                    if (object.createdAt != null) {
                        if (typeof object.createdAt !== "object")
                            throw TypeError(".ic_ledger.pb.v1.SendRequest.createdAt: object expected");
                        message.createdAt = $root.ic_ledger.pb.v1.BlockHeight.fromObject(object.createdAt);
                    }
                    if (object.createdAtTime != null) {
                        if (typeof object.createdAtTime !== "object")
                            throw TypeError(".ic_ledger.pb.v1.SendRequest.createdAtTime: object expected");
                        message.createdAtTime = $root.ic_ledger.pb.v1.TimeStamp.fromObject(object.createdAtTime);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SendRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @static
                 * @param {ic_ledger.pb.v1.SendRequest} message SendRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SendRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.memo = null;
                        object.payment = null;
                        object.maxFee = null;
                        object.fromSubaccount = null;
                        object.to = null;
                        object.createdAt = null;
                        object.createdAtTime = null;
                    }
                    if (message.memo != null && message.hasOwnProperty("memo"))
                        object.memo = $root.ic_ledger.pb.v1.Memo.toObject(message.memo, options);
                    if (message.payment != null && message.hasOwnProperty("payment"))
                        object.payment = $root.ic_ledger.pb.v1.Payment.toObject(message.payment, options);
                    if (message.maxFee != null && message.hasOwnProperty("maxFee"))
                        object.maxFee = $root.ic_ledger.pb.v1.ICPTs.toObject(message.maxFee, options);
                    if (message.fromSubaccount != null && message.hasOwnProperty("fromSubaccount"))
                        object.fromSubaccount = $root.ic_ledger.pb.v1.Subaccount.toObject(message.fromSubaccount, options);
                    if (message.to != null && message.hasOwnProperty("to"))
                        object.to = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.to, options);
                    if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                        object.createdAt = $root.ic_ledger.pb.v1.BlockHeight.toObject(message.createdAt, options);
                    if (message.createdAtTime != null && message.hasOwnProperty("createdAtTime"))
                        object.createdAtTime = $root.ic_ledger.pb.v1.TimeStamp.toObject(message.createdAtTime, options);
                    return object;
                };

                /**
                 * Converts this SendRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.SendRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SendRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SendRequest;
            })();

            v1.SendResponse = (function() {

                /**
                 * Properties of a SendResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface ISendResponse
                 * @property {ic_ledger.pb.v1.IBlockHeight|null} [resultingHeight] SendResponse resultingHeight
                 */

                /**
                 * Constructs a new SendResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a SendResponse.
                 * @implements ISendResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.ISendResponse=} [properties] Properties to set
                 */
                function SendResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SendResponse resultingHeight.
                 * @member {ic_ledger.pb.v1.IBlockHeight|null|undefined} resultingHeight
                 * @memberof ic_ledger.pb.v1.SendResponse
                 * @instance
                 */
                SendResponse.prototype.resultingHeight = null;

                /**
                 * Creates a new SendResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.SendResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ISendResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.SendResponse} SendResponse instance
                 */
                SendResponse.create = function create(properties) {
                    return new SendResponse(properties);
                };

                /**
                 * Encodes the specified SendResponse message. Does not implicitly {@link ic_ledger.pb.v1.SendResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.SendResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ISendResponse} message SendResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SendResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.resultingHeight != null && Object.hasOwnProperty.call(message, "resultingHeight"))
                        $root.ic_ledger.pb.v1.BlockHeight.encode(message.resultingHeight, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SendResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.SendResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.SendResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ISendResponse} message SendResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SendResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SendResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.SendResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.SendResponse} SendResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SendResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.SendResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.resultingHeight = $root.ic_ledger.pb.v1.BlockHeight.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SendResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.SendResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.SendResponse} SendResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SendResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SendResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.SendResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SendResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resultingHeight != null && message.hasOwnProperty("resultingHeight")) {
                        let error = $root.ic_ledger.pb.v1.BlockHeight.verify(message.resultingHeight);
                        if (error)
                            return "resultingHeight." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SendResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.SendResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.SendResponse} SendResponse
                 */
                SendResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.SendResponse)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.SendResponse();
                    if (object.resultingHeight != null) {
                        if (typeof object.resultingHeight !== "object")
                            throw TypeError(".ic_ledger.pb.v1.SendResponse.resultingHeight: object expected");
                        message.resultingHeight = $root.ic_ledger.pb.v1.BlockHeight.fromObject(object.resultingHeight);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SendResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.SendResponse
                 * @static
                 * @param {ic_ledger.pb.v1.SendResponse} message SendResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SendResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.resultingHeight = null;
                    if (message.resultingHeight != null && message.hasOwnProperty("resultingHeight"))
                        object.resultingHeight = $root.ic_ledger.pb.v1.BlockHeight.toObject(message.resultingHeight, options);
                    return object;
                };

                /**
                 * Converts this SendResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.SendResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SendResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SendResponse;
            })();

            v1.NotifyRequest = (function() {

                /**
                 * Properties of a NotifyRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface INotifyRequest
                 * @property {ic_ledger.pb.v1.IBlockHeight|null} [blockHeight] NotifyRequest blockHeight
                 * @property {ic_ledger.pb.v1.IICPTs|null} [maxFee] NotifyRequest maxFee
                 * @property {ic_ledger.pb.v1.ISubaccount|null} [fromSubaccount] NotifyRequest fromSubaccount
                 * @property {ic_base_types.pb.v1.IPrincipalId|null} [toCanister] NotifyRequest toCanister
                 * @property {ic_ledger.pb.v1.ISubaccount|null} [toSubaccount] NotifyRequest toSubaccount
                 */

                /**
                 * Constructs a new NotifyRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a NotifyRequest.
                 * @implements INotifyRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.INotifyRequest=} [properties] Properties to set
                 */
                function NotifyRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NotifyRequest blockHeight.
                 * @member {ic_ledger.pb.v1.IBlockHeight|null|undefined} blockHeight
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @instance
                 */
                NotifyRequest.prototype.blockHeight = null;

                /**
                 * NotifyRequest maxFee.
                 * @member {ic_ledger.pb.v1.IICPTs|null|undefined} maxFee
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @instance
                 */
                NotifyRequest.prototype.maxFee = null;

                /**
                 * NotifyRequest fromSubaccount.
                 * @member {ic_ledger.pb.v1.ISubaccount|null|undefined} fromSubaccount
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @instance
                 */
                NotifyRequest.prototype.fromSubaccount = null;

                /**
                 * NotifyRequest toCanister.
                 * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} toCanister
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @instance
                 */
                NotifyRequest.prototype.toCanister = null;

                /**
                 * NotifyRequest toSubaccount.
                 * @member {ic_ledger.pb.v1.ISubaccount|null|undefined} toSubaccount
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @instance
                 */
                NotifyRequest.prototype.toSubaccount = null;

                /**
                 * Creates a new NotifyRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @static
                 * @param {ic_ledger.pb.v1.INotifyRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.NotifyRequest} NotifyRequest instance
                 */
                NotifyRequest.create = function create(properties) {
                    return new NotifyRequest(properties);
                };

                /**
                 * Encodes the specified NotifyRequest message. Does not implicitly {@link ic_ledger.pb.v1.NotifyRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @static
                 * @param {ic_ledger.pb.v1.INotifyRequest} message NotifyRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NotifyRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                        $root.ic_ledger.pb.v1.BlockHeight.encode(message.blockHeight, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.maxFee != null && Object.hasOwnProperty.call(message, "maxFee"))
                        $root.ic_ledger.pb.v1.ICPTs.encode(message.maxFee, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.fromSubaccount != null && Object.hasOwnProperty.call(message, "fromSubaccount"))
                        $root.ic_ledger.pb.v1.Subaccount.encode(message.fromSubaccount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.toCanister != null && Object.hasOwnProperty.call(message, "toCanister"))
                        $root.ic_base_types.pb.v1.PrincipalId.encode(message.toCanister, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.toSubaccount != null && Object.hasOwnProperty.call(message, "toSubaccount"))
                        $root.ic_ledger.pb.v1.Subaccount.encode(message.toSubaccount, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified NotifyRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.NotifyRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @static
                 * @param {ic_ledger.pb.v1.INotifyRequest} message NotifyRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NotifyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NotifyRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.NotifyRequest} NotifyRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NotifyRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.NotifyRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.blockHeight = $root.ic_ledger.pb.v1.BlockHeight.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.maxFee = $root.ic_ledger.pb.v1.ICPTs.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.fromSubaccount = $root.ic_ledger.pb.v1.Subaccount.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.toCanister = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.toSubaccount = $root.ic_ledger.pb.v1.Subaccount.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NotifyRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.NotifyRequest} NotifyRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NotifyRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NotifyRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NotifyRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight")) {
                        let error = $root.ic_ledger.pb.v1.BlockHeight.verify(message.blockHeight);
                        if (error)
                            return "blockHeight." + error;
                    }
                    if (message.maxFee != null && message.hasOwnProperty("maxFee")) {
                        let error = $root.ic_ledger.pb.v1.ICPTs.verify(message.maxFee);
                        if (error)
                            return "maxFee." + error;
                    }
                    if (message.fromSubaccount != null && message.hasOwnProperty("fromSubaccount")) {
                        let error = $root.ic_ledger.pb.v1.Subaccount.verify(message.fromSubaccount);
                        if (error)
                            return "fromSubaccount." + error;
                    }
                    if (message.toCanister != null && message.hasOwnProperty("toCanister")) {
                        let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.toCanister);
                        if (error)
                            return "toCanister." + error;
                    }
                    if (message.toSubaccount != null && message.hasOwnProperty("toSubaccount")) {
                        let error = $root.ic_ledger.pb.v1.Subaccount.verify(message.toSubaccount);
                        if (error)
                            return "toSubaccount." + error;
                    }
                    return null;
                };

                /**
                 * Creates a NotifyRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.NotifyRequest} NotifyRequest
                 */
                NotifyRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.NotifyRequest)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.NotifyRequest();
                    if (object.blockHeight != null) {
                        if (typeof object.blockHeight !== "object")
                            throw TypeError(".ic_ledger.pb.v1.NotifyRequest.blockHeight: object expected");
                        message.blockHeight = $root.ic_ledger.pb.v1.BlockHeight.fromObject(object.blockHeight);
                    }
                    if (object.maxFee != null) {
                        if (typeof object.maxFee !== "object")
                            throw TypeError(".ic_ledger.pb.v1.NotifyRequest.maxFee: object expected");
                        message.maxFee = $root.ic_ledger.pb.v1.ICPTs.fromObject(object.maxFee);
                    }
                    if (object.fromSubaccount != null) {
                        if (typeof object.fromSubaccount !== "object")
                            throw TypeError(".ic_ledger.pb.v1.NotifyRequest.fromSubaccount: object expected");
                        message.fromSubaccount = $root.ic_ledger.pb.v1.Subaccount.fromObject(object.fromSubaccount);
                    }
                    if (object.toCanister != null) {
                        if (typeof object.toCanister !== "object")
                            throw TypeError(".ic_ledger.pb.v1.NotifyRequest.toCanister: object expected");
                        message.toCanister = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.toCanister);
                    }
                    if (object.toSubaccount != null) {
                        if (typeof object.toSubaccount !== "object")
                            throw TypeError(".ic_ledger.pb.v1.NotifyRequest.toSubaccount: object expected");
                        message.toSubaccount = $root.ic_ledger.pb.v1.Subaccount.fromObject(object.toSubaccount);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a NotifyRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @static
                 * @param {ic_ledger.pb.v1.NotifyRequest} message NotifyRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NotifyRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.blockHeight = null;
                        object.maxFee = null;
                        object.fromSubaccount = null;
                        object.toCanister = null;
                        object.toSubaccount = null;
                    }
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                        object.blockHeight = $root.ic_ledger.pb.v1.BlockHeight.toObject(message.blockHeight, options);
                    if (message.maxFee != null && message.hasOwnProperty("maxFee"))
                        object.maxFee = $root.ic_ledger.pb.v1.ICPTs.toObject(message.maxFee, options);
                    if (message.fromSubaccount != null && message.hasOwnProperty("fromSubaccount"))
                        object.fromSubaccount = $root.ic_ledger.pb.v1.Subaccount.toObject(message.fromSubaccount, options);
                    if (message.toCanister != null && message.hasOwnProperty("toCanister"))
                        object.toCanister = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.toCanister, options);
                    if (message.toSubaccount != null && message.hasOwnProperty("toSubaccount"))
                        object.toSubaccount = $root.ic_ledger.pb.v1.Subaccount.toObject(message.toSubaccount, options);
                    return object;
                };

                /**
                 * Converts this NotifyRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.NotifyRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NotifyRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NotifyRequest;
            })();

            v1.NotifyResponse = (function() {

                /**
                 * Properties of a NotifyResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface INotifyResponse
                 */

                /**
                 * Constructs a new NotifyResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a NotifyResponse.
                 * @implements INotifyResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.INotifyResponse=} [properties] Properties to set
                 */
                function NotifyResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new NotifyResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.NotifyResponse
                 * @static
                 * @param {ic_ledger.pb.v1.INotifyResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.NotifyResponse} NotifyResponse instance
                 */
                NotifyResponse.create = function create(properties) {
                    return new NotifyResponse(properties);
                };

                /**
                 * Encodes the specified NotifyResponse message. Does not implicitly {@link ic_ledger.pb.v1.NotifyResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.NotifyResponse
                 * @static
                 * @param {ic_ledger.pb.v1.INotifyResponse} message NotifyResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NotifyResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified NotifyResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.NotifyResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.NotifyResponse
                 * @static
                 * @param {ic_ledger.pb.v1.INotifyResponse} message NotifyResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NotifyResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NotifyResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.NotifyResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.NotifyResponse} NotifyResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NotifyResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.NotifyResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NotifyResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.NotifyResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.NotifyResponse} NotifyResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NotifyResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NotifyResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.NotifyResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NotifyResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a NotifyResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.NotifyResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.NotifyResponse} NotifyResponse
                 */
                NotifyResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.NotifyResponse)
                        return object;
                    return new $root.ic_ledger.pb.v1.NotifyResponse();
                };

                /**
                 * Creates a plain object from a NotifyResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.NotifyResponse
                 * @static
                 * @param {ic_ledger.pb.v1.NotifyResponse} message NotifyResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NotifyResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this NotifyResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.NotifyResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NotifyResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NotifyResponse;
            })();

            v1.TransactionNotificationRequest = (function() {

                /**
                 * Properties of a TransactionNotificationRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface ITransactionNotificationRequest
                 * @property {ic_base_types.pb.v1.IPrincipalId|null} [from] TransactionNotificationRequest from
                 * @property {ic_ledger.pb.v1.ISubaccount|null} [fromSubaccount] TransactionNotificationRequest fromSubaccount
                 * @property {ic_base_types.pb.v1.IPrincipalId|null} [to] TransactionNotificationRequest to
                 * @property {ic_ledger.pb.v1.ISubaccount|null} [toSubaccount] TransactionNotificationRequest toSubaccount
                 * @property {ic_ledger.pb.v1.IBlockHeight|null} [blockHeight] TransactionNotificationRequest blockHeight
                 * @property {ic_ledger.pb.v1.IICPTs|null} [amount] TransactionNotificationRequest amount
                 * @property {ic_ledger.pb.v1.IMemo|null} [memo] TransactionNotificationRequest memo
                 */

                /**
                 * Constructs a new TransactionNotificationRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a TransactionNotificationRequest.
                 * @implements ITransactionNotificationRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.ITransactionNotificationRequest=} [properties] Properties to set
                 */
                function TransactionNotificationRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransactionNotificationRequest from.
                 * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} from
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @instance
                 */
                TransactionNotificationRequest.prototype.from = null;

                /**
                 * TransactionNotificationRequest fromSubaccount.
                 * @member {ic_ledger.pb.v1.ISubaccount|null|undefined} fromSubaccount
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @instance
                 */
                TransactionNotificationRequest.prototype.fromSubaccount = null;

                /**
                 * TransactionNotificationRequest to.
                 * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} to
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @instance
                 */
                TransactionNotificationRequest.prototype.to = null;

                /**
                 * TransactionNotificationRequest toSubaccount.
                 * @member {ic_ledger.pb.v1.ISubaccount|null|undefined} toSubaccount
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @instance
                 */
                TransactionNotificationRequest.prototype.toSubaccount = null;

                /**
                 * TransactionNotificationRequest blockHeight.
                 * @member {ic_ledger.pb.v1.IBlockHeight|null|undefined} blockHeight
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @instance
                 */
                TransactionNotificationRequest.prototype.blockHeight = null;

                /**
                 * TransactionNotificationRequest amount.
                 * @member {ic_ledger.pb.v1.IICPTs|null|undefined} amount
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @instance
                 */
                TransactionNotificationRequest.prototype.amount = null;

                /**
                 * TransactionNotificationRequest memo.
                 * @member {ic_ledger.pb.v1.IMemo|null|undefined} memo
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @instance
                 */
                TransactionNotificationRequest.prototype.memo = null;

                /**
                 * Creates a new TransactionNotificationRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ITransactionNotificationRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.TransactionNotificationRequest} TransactionNotificationRequest instance
                 */
                TransactionNotificationRequest.create = function create(properties) {
                    return new TransactionNotificationRequest(properties);
                };

                /**
                 * Encodes the specified TransactionNotificationRequest message. Does not implicitly {@link ic_ledger.pb.v1.TransactionNotificationRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ITransactionNotificationRequest} message TransactionNotificationRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionNotificationRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                        $root.ic_base_types.pb.v1.PrincipalId.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.fromSubaccount != null && Object.hasOwnProperty.call(message, "fromSubaccount"))
                        $root.ic_ledger.pb.v1.Subaccount.encode(message.fromSubaccount, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                        $root.ic_base_types.pb.v1.PrincipalId.encode(message.to, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.toSubaccount != null && Object.hasOwnProperty.call(message, "toSubaccount"))
                        $root.ic_ledger.pb.v1.Subaccount.encode(message.toSubaccount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                        $root.ic_ledger.pb.v1.BlockHeight.encode(message.blockHeight, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.ic_ledger.pb.v1.ICPTs.encode(message.amount, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                        $root.ic_ledger.pb.v1.Memo.encode(message.memo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TransactionNotificationRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.TransactionNotificationRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ITransactionNotificationRequest} message TransactionNotificationRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionNotificationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransactionNotificationRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.TransactionNotificationRequest} TransactionNotificationRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionNotificationRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.TransactionNotificationRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.from = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.fromSubaccount = $root.ic_ledger.pb.v1.Subaccount.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.to = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.toSubaccount = $root.ic_ledger.pb.v1.Subaccount.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.blockHeight = $root.ic_ledger.pb.v1.BlockHeight.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.amount = $root.ic_ledger.pb.v1.ICPTs.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.memo = $root.ic_ledger.pb.v1.Memo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransactionNotificationRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.TransactionNotificationRequest} TransactionNotificationRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionNotificationRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransactionNotificationRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransactionNotificationRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.from != null && message.hasOwnProperty("from")) {
                        let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.from);
                        if (error)
                            return "from." + error;
                    }
                    if (message.fromSubaccount != null && message.hasOwnProperty("fromSubaccount")) {
                        let error = $root.ic_ledger.pb.v1.Subaccount.verify(message.fromSubaccount);
                        if (error)
                            return "fromSubaccount." + error;
                    }
                    if (message.to != null && message.hasOwnProperty("to")) {
                        let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.to);
                        if (error)
                            return "to." + error;
                    }
                    if (message.toSubaccount != null && message.hasOwnProperty("toSubaccount")) {
                        let error = $root.ic_ledger.pb.v1.Subaccount.verify(message.toSubaccount);
                        if (error)
                            return "toSubaccount." + error;
                    }
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight")) {
                        let error = $root.ic_ledger.pb.v1.BlockHeight.verify(message.blockHeight);
                        if (error)
                            return "blockHeight." + error;
                    }
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        let error = $root.ic_ledger.pb.v1.ICPTs.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    if (message.memo != null && message.hasOwnProperty("memo")) {
                        let error = $root.ic_ledger.pb.v1.Memo.verify(message.memo);
                        if (error)
                            return "memo." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TransactionNotificationRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.TransactionNotificationRequest} TransactionNotificationRequest
                 */
                TransactionNotificationRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.TransactionNotificationRequest)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.TransactionNotificationRequest();
                    if (object.from != null) {
                        if (typeof object.from !== "object")
                            throw TypeError(".ic_ledger.pb.v1.TransactionNotificationRequest.from: object expected");
                        message.from = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.from);
                    }
                    if (object.fromSubaccount != null) {
                        if (typeof object.fromSubaccount !== "object")
                            throw TypeError(".ic_ledger.pb.v1.TransactionNotificationRequest.fromSubaccount: object expected");
                        message.fromSubaccount = $root.ic_ledger.pb.v1.Subaccount.fromObject(object.fromSubaccount);
                    }
                    if (object.to != null) {
                        if (typeof object.to !== "object")
                            throw TypeError(".ic_ledger.pb.v1.TransactionNotificationRequest.to: object expected");
                        message.to = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.to);
                    }
                    if (object.toSubaccount != null) {
                        if (typeof object.toSubaccount !== "object")
                            throw TypeError(".ic_ledger.pb.v1.TransactionNotificationRequest.toSubaccount: object expected");
                        message.toSubaccount = $root.ic_ledger.pb.v1.Subaccount.fromObject(object.toSubaccount);
                    }
                    if (object.blockHeight != null) {
                        if (typeof object.blockHeight !== "object")
                            throw TypeError(".ic_ledger.pb.v1.TransactionNotificationRequest.blockHeight: object expected");
                        message.blockHeight = $root.ic_ledger.pb.v1.BlockHeight.fromObject(object.blockHeight);
                    }
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ic_ledger.pb.v1.TransactionNotificationRequest.amount: object expected");
                        message.amount = $root.ic_ledger.pb.v1.ICPTs.fromObject(object.amount);
                    }
                    if (object.memo != null) {
                        if (typeof object.memo !== "object")
                            throw TypeError(".ic_ledger.pb.v1.TransactionNotificationRequest.memo: object expected");
                        message.memo = $root.ic_ledger.pb.v1.Memo.fromObject(object.memo);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TransactionNotificationRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @static
                 * @param {ic_ledger.pb.v1.TransactionNotificationRequest} message TransactionNotificationRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransactionNotificationRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.from = null;
                        object.fromSubaccount = null;
                        object.to = null;
                        object.toSubaccount = null;
                        object.blockHeight = null;
                        object.amount = null;
                        object.memo = null;
                    }
                    if (message.from != null && message.hasOwnProperty("from"))
                        object.from = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.from, options);
                    if (message.fromSubaccount != null && message.hasOwnProperty("fromSubaccount"))
                        object.fromSubaccount = $root.ic_ledger.pb.v1.Subaccount.toObject(message.fromSubaccount, options);
                    if (message.to != null && message.hasOwnProperty("to"))
                        object.to = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.to, options);
                    if (message.toSubaccount != null && message.hasOwnProperty("toSubaccount"))
                        object.toSubaccount = $root.ic_ledger.pb.v1.Subaccount.toObject(message.toSubaccount, options);
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                        object.blockHeight = $root.ic_ledger.pb.v1.BlockHeight.toObject(message.blockHeight, options);
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.ic_ledger.pb.v1.ICPTs.toObject(message.amount, options);
                    if (message.memo != null && message.hasOwnProperty("memo"))
                        object.memo = $root.ic_ledger.pb.v1.Memo.toObject(message.memo, options);
                    return object;
                };

                /**
                 * Converts this TransactionNotificationRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.TransactionNotificationRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransactionNotificationRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TransactionNotificationRequest;
            })();

            v1.TransactionNotificationResponse = (function() {

                /**
                 * Properties of a TransactionNotificationResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface ITransactionNotificationResponse
                 * @property {Uint8Array|null} [response] TransactionNotificationResponse response
                 */

                /**
                 * Constructs a new TransactionNotificationResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a TransactionNotificationResponse.
                 * @implements ITransactionNotificationResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.ITransactionNotificationResponse=} [properties] Properties to set
                 */
                function TransactionNotificationResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransactionNotificationResponse response.
                 * @member {Uint8Array} response
                 * @memberof ic_ledger.pb.v1.TransactionNotificationResponse
                 * @instance
                 */
                TransactionNotificationResponse.prototype.response = $util.newBuffer([]);

                /**
                 * Creates a new TransactionNotificationResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.TransactionNotificationResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ITransactionNotificationResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.TransactionNotificationResponse} TransactionNotificationResponse instance
                 */
                TransactionNotificationResponse.create = function create(properties) {
                    return new TransactionNotificationResponse(properties);
                };

                /**
                 * Encodes the specified TransactionNotificationResponse message. Does not implicitly {@link ic_ledger.pb.v1.TransactionNotificationResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.TransactionNotificationResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ITransactionNotificationResponse} message TransactionNotificationResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionNotificationResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.response != null && Object.hasOwnProperty.call(message, "response"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.response);
                    return writer;
                };

                /**
                 * Encodes the specified TransactionNotificationResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.TransactionNotificationResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.TransactionNotificationResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ITransactionNotificationResponse} message TransactionNotificationResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionNotificationResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransactionNotificationResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.TransactionNotificationResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.TransactionNotificationResponse} TransactionNotificationResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionNotificationResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.TransactionNotificationResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.response = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransactionNotificationResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.TransactionNotificationResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.TransactionNotificationResponse} TransactionNotificationResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionNotificationResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransactionNotificationResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.TransactionNotificationResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransactionNotificationResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.response != null && message.hasOwnProperty("response"))
                        if (!(message.response && typeof message.response.length === "number" || $util.isString(message.response)))
                            return "response: buffer expected";
                    return null;
                };

                /**
                 * Creates a TransactionNotificationResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.TransactionNotificationResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.TransactionNotificationResponse} TransactionNotificationResponse
                 */
                TransactionNotificationResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.TransactionNotificationResponse)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.TransactionNotificationResponse();
                    if (object.response != null)
                        if (typeof object.response === "string")
                            $util.base64.decode(object.response, message.response = $util.newBuffer($util.base64.length(object.response)), 0);
                        else if (object.response.length)
                            message.response = object.response;
                    return message;
                };

                /**
                 * Creates a plain object from a TransactionNotificationResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.TransactionNotificationResponse
                 * @static
                 * @param {ic_ledger.pb.v1.TransactionNotificationResponse} message TransactionNotificationResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransactionNotificationResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.response = "";
                        else {
                            object.response = [];
                            if (options.bytes !== Array)
                                object.response = $util.newBuffer(object.response);
                        }
                    if (message.response != null && message.hasOwnProperty("response"))
                        object.response = options.bytes === String ? $util.base64.encode(message.response, 0, message.response.length) : options.bytes === Array ? Array.prototype.slice.call(message.response) : message.response;
                    return object;
                };

                /**
                 * Converts this TransactionNotificationResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.TransactionNotificationResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransactionNotificationResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TransactionNotificationResponse;
            })();

            v1.CyclesNotificationResponse = (function() {

                /**
                 * Properties of a CyclesNotificationResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface ICyclesNotificationResponse
                 * @property {ic_base_types.pb.v1.IPrincipalId|null} [createdCanisterId] CyclesNotificationResponse createdCanisterId
                 * @property {ic_ledger.pb.v1.IRefund|null} [refund] CyclesNotificationResponse refund
                 * @property {ic_ledger.pb.v1.IToppedUp|null} [toppedUp] CyclesNotificationResponse toppedUp
                 */

                /**
                 * Constructs a new CyclesNotificationResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a CyclesNotificationResponse.
                 * @implements ICyclesNotificationResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.ICyclesNotificationResponse=} [properties] Properties to set
                 */
                function CyclesNotificationResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CyclesNotificationResponse createdCanisterId.
                 * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} createdCanisterId
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @instance
                 */
                CyclesNotificationResponse.prototype.createdCanisterId = null;

                /**
                 * CyclesNotificationResponse refund.
                 * @member {ic_ledger.pb.v1.IRefund|null|undefined} refund
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @instance
                 */
                CyclesNotificationResponse.prototype.refund = null;

                /**
                 * CyclesNotificationResponse toppedUp.
                 * @member {ic_ledger.pb.v1.IToppedUp|null|undefined} toppedUp
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @instance
                 */
                CyclesNotificationResponse.prototype.toppedUp = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * CyclesNotificationResponse response.
                 * @member {"createdCanisterId"|"refund"|"toppedUp"|undefined} response
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @instance
                 */
                Object.defineProperty(CyclesNotificationResponse.prototype, "response", {
                    get: $util.oneOfGetter($oneOfFields = ["createdCanisterId", "refund", "toppedUp"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new CyclesNotificationResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ICyclesNotificationResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.CyclesNotificationResponse} CyclesNotificationResponse instance
                 */
                CyclesNotificationResponse.create = function create(properties) {
                    return new CyclesNotificationResponse(properties);
                };

                /**
                 * Encodes the specified CyclesNotificationResponse message. Does not implicitly {@link ic_ledger.pb.v1.CyclesNotificationResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ICyclesNotificationResponse} message CyclesNotificationResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CyclesNotificationResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.createdCanisterId != null && Object.hasOwnProperty.call(message, "createdCanisterId"))
                        $root.ic_base_types.pb.v1.PrincipalId.encode(message.createdCanisterId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.refund != null && Object.hasOwnProperty.call(message, "refund"))
                        $root.ic_ledger.pb.v1.Refund.encode(message.refund, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.toppedUp != null && Object.hasOwnProperty.call(message, "toppedUp"))
                        $root.ic_ledger.pb.v1.ToppedUp.encode(message.toppedUp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CyclesNotificationResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.CyclesNotificationResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ICyclesNotificationResponse} message CyclesNotificationResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CyclesNotificationResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CyclesNotificationResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.CyclesNotificationResponse} CyclesNotificationResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CyclesNotificationResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.CyclesNotificationResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.createdCanisterId = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.refund = $root.ic_ledger.pb.v1.Refund.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.toppedUp = $root.ic_ledger.pb.v1.ToppedUp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CyclesNotificationResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.CyclesNotificationResponse} CyclesNotificationResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CyclesNotificationResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CyclesNotificationResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CyclesNotificationResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.createdCanisterId != null && message.hasOwnProperty("createdCanisterId")) {
                        properties.response = 1;
                        {
                            let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.createdCanisterId);
                            if (error)
                                return "createdCanisterId." + error;
                        }
                    }
                    if (message.refund != null && message.hasOwnProperty("refund")) {
                        if (properties.response === 1)
                            return "response: multiple values";
                        properties.response = 1;
                        {
                            let error = $root.ic_ledger.pb.v1.Refund.verify(message.refund);
                            if (error)
                                return "refund." + error;
                        }
                    }
                    if (message.toppedUp != null && message.hasOwnProperty("toppedUp")) {
                        if (properties.response === 1)
                            return "response: multiple values";
                        properties.response = 1;
                        {
                            let error = $root.ic_ledger.pb.v1.ToppedUp.verify(message.toppedUp);
                            if (error)
                                return "toppedUp." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CyclesNotificationResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.CyclesNotificationResponse} CyclesNotificationResponse
                 */
                CyclesNotificationResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.CyclesNotificationResponse)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.CyclesNotificationResponse();
                    if (object.createdCanisterId != null) {
                        if (typeof object.createdCanisterId !== "object")
                            throw TypeError(".ic_ledger.pb.v1.CyclesNotificationResponse.createdCanisterId: object expected");
                        message.createdCanisterId = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.createdCanisterId);
                    }
                    if (object.refund != null) {
                        if (typeof object.refund !== "object")
                            throw TypeError(".ic_ledger.pb.v1.CyclesNotificationResponse.refund: object expected");
                        message.refund = $root.ic_ledger.pb.v1.Refund.fromObject(object.refund);
                    }
                    if (object.toppedUp != null) {
                        if (typeof object.toppedUp !== "object")
                            throw TypeError(".ic_ledger.pb.v1.CyclesNotificationResponse.toppedUp: object expected");
                        message.toppedUp = $root.ic_ledger.pb.v1.ToppedUp.fromObject(object.toppedUp);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CyclesNotificationResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @static
                 * @param {ic_ledger.pb.v1.CyclesNotificationResponse} message CyclesNotificationResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CyclesNotificationResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.createdCanisterId != null && message.hasOwnProperty("createdCanisterId")) {
                        object.createdCanisterId = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.createdCanisterId, options);
                        if (options.oneofs)
                            object.response = "createdCanisterId";
                    }
                    if (message.refund != null && message.hasOwnProperty("refund")) {
                        object.refund = $root.ic_ledger.pb.v1.Refund.toObject(message.refund, options);
                        if (options.oneofs)
                            object.response = "refund";
                    }
                    if (message.toppedUp != null && message.hasOwnProperty("toppedUp")) {
                        object.toppedUp = $root.ic_ledger.pb.v1.ToppedUp.toObject(message.toppedUp, options);
                        if (options.oneofs)
                            object.response = "toppedUp";
                    }
                    return object;
                };

                /**
                 * Converts this CyclesNotificationResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.CyclesNotificationResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CyclesNotificationResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CyclesNotificationResponse;
            })();

            v1.AccountBalanceRequest = (function() {

                /**
                 * Properties of an AccountBalanceRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface IAccountBalanceRequest
                 * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [account] AccountBalanceRequest account
                 */

                /**
                 * Constructs a new AccountBalanceRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an AccountBalanceRequest.
                 * @implements IAccountBalanceRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.IAccountBalanceRequest=} [properties] Properties to set
                 */
                function AccountBalanceRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AccountBalanceRequest account.
                 * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} account
                 * @memberof ic_ledger.pb.v1.AccountBalanceRequest
                 * @instance
                 */
                AccountBalanceRequest.prototype.account = null;

                /**
                 * Creates a new AccountBalanceRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.AccountBalanceRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IAccountBalanceRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.AccountBalanceRequest} AccountBalanceRequest instance
                 */
                AccountBalanceRequest.create = function create(properties) {
                    return new AccountBalanceRequest(properties);
                };

                /**
                 * Encodes the specified AccountBalanceRequest message. Does not implicitly {@link ic_ledger.pb.v1.AccountBalanceRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.AccountBalanceRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IAccountBalanceRequest} message AccountBalanceRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountBalanceRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                        $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.account, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified AccountBalanceRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.AccountBalanceRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.AccountBalanceRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IAccountBalanceRequest} message AccountBalanceRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountBalanceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AccountBalanceRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.AccountBalanceRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.AccountBalanceRequest} AccountBalanceRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountBalanceRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.AccountBalanceRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.account = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AccountBalanceRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.AccountBalanceRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.AccountBalanceRequest} AccountBalanceRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountBalanceRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AccountBalanceRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.AccountBalanceRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AccountBalanceRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.account != null && message.hasOwnProperty("account")) {
                        let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.account);
                        if (error)
                            return "account." + error;
                    }
                    return null;
                };

                /**
                 * Creates an AccountBalanceRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.AccountBalanceRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.AccountBalanceRequest} AccountBalanceRequest
                 */
                AccountBalanceRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.AccountBalanceRequest)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.AccountBalanceRequest();
                    if (object.account != null) {
                        if (typeof object.account !== "object")
                            throw TypeError(".ic_ledger.pb.v1.AccountBalanceRequest.account: object expected");
                        message.account = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.account);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an AccountBalanceRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.AccountBalanceRequest
                 * @static
                 * @param {ic_ledger.pb.v1.AccountBalanceRequest} message AccountBalanceRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AccountBalanceRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.account = null;
                    if (message.account != null && message.hasOwnProperty("account"))
                        object.account = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.account, options);
                    return object;
                };

                /**
                 * Converts this AccountBalanceRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.AccountBalanceRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AccountBalanceRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AccountBalanceRequest;
            })();

            v1.AccountBalanceResponse = (function() {

                /**
                 * Properties of an AccountBalanceResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface IAccountBalanceResponse
                 * @property {ic_ledger.pb.v1.IICPTs|null} [balance] AccountBalanceResponse balance
                 */

                /**
                 * Constructs a new AccountBalanceResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an AccountBalanceResponse.
                 * @implements IAccountBalanceResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.IAccountBalanceResponse=} [properties] Properties to set
                 */
                function AccountBalanceResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AccountBalanceResponse balance.
                 * @member {ic_ledger.pb.v1.IICPTs|null|undefined} balance
                 * @memberof ic_ledger.pb.v1.AccountBalanceResponse
                 * @instance
                 */
                AccountBalanceResponse.prototype.balance = null;

                /**
                 * Creates a new AccountBalanceResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.AccountBalanceResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IAccountBalanceResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.AccountBalanceResponse} AccountBalanceResponse instance
                 */
                AccountBalanceResponse.create = function create(properties) {
                    return new AccountBalanceResponse(properties);
                };

                /**
                 * Encodes the specified AccountBalanceResponse message. Does not implicitly {@link ic_ledger.pb.v1.AccountBalanceResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.AccountBalanceResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IAccountBalanceResponse} message AccountBalanceResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountBalanceResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                        $root.ic_ledger.pb.v1.ICPTs.encode(message.balance, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified AccountBalanceResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.AccountBalanceResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.AccountBalanceResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IAccountBalanceResponse} message AccountBalanceResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountBalanceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AccountBalanceResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.AccountBalanceResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.AccountBalanceResponse} AccountBalanceResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountBalanceResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.AccountBalanceResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.balance = $root.ic_ledger.pb.v1.ICPTs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AccountBalanceResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.AccountBalanceResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.AccountBalanceResponse} AccountBalanceResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountBalanceResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AccountBalanceResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.AccountBalanceResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AccountBalanceResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.balance != null && message.hasOwnProperty("balance")) {
                        let error = $root.ic_ledger.pb.v1.ICPTs.verify(message.balance);
                        if (error)
                            return "balance." + error;
                    }
                    return null;
                };

                /**
                 * Creates an AccountBalanceResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.AccountBalanceResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.AccountBalanceResponse} AccountBalanceResponse
                 */
                AccountBalanceResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.AccountBalanceResponse)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.AccountBalanceResponse();
                    if (object.balance != null) {
                        if (typeof object.balance !== "object")
                            throw TypeError(".ic_ledger.pb.v1.AccountBalanceResponse.balance: object expected");
                        message.balance = $root.ic_ledger.pb.v1.ICPTs.fromObject(object.balance);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an AccountBalanceResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.AccountBalanceResponse
                 * @static
                 * @param {ic_ledger.pb.v1.AccountBalanceResponse} message AccountBalanceResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AccountBalanceResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.balance = null;
                    if (message.balance != null && message.hasOwnProperty("balance"))
                        object.balance = $root.ic_ledger.pb.v1.ICPTs.toObject(message.balance, options);
                    return object;
                };

                /**
                 * Converts this AccountBalanceResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.AccountBalanceResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AccountBalanceResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AccountBalanceResponse;
            })();

            v1.TipOfChainRequest = (function() {

                /**
                 * Properties of a TipOfChainRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface ITipOfChainRequest
                 */

                /**
                 * Constructs a new TipOfChainRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a TipOfChainRequest.
                 * @implements ITipOfChainRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.ITipOfChainRequest=} [properties] Properties to set
                 */
                function TipOfChainRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new TipOfChainRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.TipOfChainRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ITipOfChainRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.TipOfChainRequest} TipOfChainRequest instance
                 */
                TipOfChainRequest.create = function create(properties) {
                    return new TipOfChainRequest(properties);
                };

                /**
                 * Encodes the specified TipOfChainRequest message. Does not implicitly {@link ic_ledger.pb.v1.TipOfChainRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.TipOfChainRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ITipOfChainRequest} message TipOfChainRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TipOfChainRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified TipOfChainRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.TipOfChainRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.TipOfChainRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ITipOfChainRequest} message TipOfChainRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TipOfChainRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TipOfChainRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.TipOfChainRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.TipOfChainRequest} TipOfChainRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TipOfChainRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.TipOfChainRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TipOfChainRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.TipOfChainRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.TipOfChainRequest} TipOfChainRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TipOfChainRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TipOfChainRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.TipOfChainRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TipOfChainRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a TipOfChainRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.TipOfChainRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.TipOfChainRequest} TipOfChainRequest
                 */
                TipOfChainRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.TipOfChainRequest)
                        return object;
                    return new $root.ic_ledger.pb.v1.TipOfChainRequest();
                };

                /**
                 * Creates a plain object from a TipOfChainRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.TipOfChainRequest
                 * @static
                 * @param {ic_ledger.pb.v1.TipOfChainRequest} message TipOfChainRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TipOfChainRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this TipOfChainRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.TipOfChainRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TipOfChainRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TipOfChainRequest;
            })();

            v1.TipOfChainResponse = (function() {

                /**
                 * Properties of a TipOfChainResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface ITipOfChainResponse
                 * @property {ic_ledger.pb.v1.ICertification|null} [certification] TipOfChainResponse certification
                 * @property {ic_ledger.pb.v1.IBlockHeight|null} [chainLength] TipOfChainResponse chainLength
                 */

                /**
                 * Constructs a new TipOfChainResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a TipOfChainResponse.
                 * @implements ITipOfChainResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.ITipOfChainResponse=} [properties] Properties to set
                 */
                function TipOfChainResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TipOfChainResponse certification.
                 * @member {ic_ledger.pb.v1.ICertification|null|undefined} certification
                 * @memberof ic_ledger.pb.v1.TipOfChainResponse
                 * @instance
                 */
                TipOfChainResponse.prototype.certification = null;

                /**
                 * TipOfChainResponse chainLength.
                 * @member {ic_ledger.pb.v1.IBlockHeight|null|undefined} chainLength
                 * @memberof ic_ledger.pb.v1.TipOfChainResponse
                 * @instance
                 */
                TipOfChainResponse.prototype.chainLength = null;

                /**
                 * Creates a new TipOfChainResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.TipOfChainResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ITipOfChainResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.TipOfChainResponse} TipOfChainResponse instance
                 */
                TipOfChainResponse.create = function create(properties) {
                    return new TipOfChainResponse(properties);
                };

                /**
                 * Encodes the specified TipOfChainResponse message. Does not implicitly {@link ic_ledger.pb.v1.TipOfChainResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.TipOfChainResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ITipOfChainResponse} message TipOfChainResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TipOfChainResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.certification != null && Object.hasOwnProperty.call(message, "certification"))
                        $root.ic_ledger.pb.v1.Certification.encode(message.certification, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.chainLength != null && Object.hasOwnProperty.call(message, "chainLength"))
                        $root.ic_ledger.pb.v1.BlockHeight.encode(message.chainLength, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TipOfChainResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.TipOfChainResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.TipOfChainResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ITipOfChainResponse} message TipOfChainResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TipOfChainResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TipOfChainResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.TipOfChainResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.TipOfChainResponse} TipOfChainResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TipOfChainResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.TipOfChainResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.certification = $root.ic_ledger.pb.v1.Certification.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.chainLength = $root.ic_ledger.pb.v1.BlockHeight.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TipOfChainResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.TipOfChainResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.TipOfChainResponse} TipOfChainResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TipOfChainResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TipOfChainResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.TipOfChainResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TipOfChainResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.certification != null && message.hasOwnProperty("certification")) {
                        let error = $root.ic_ledger.pb.v1.Certification.verify(message.certification);
                        if (error)
                            return "certification." + error;
                    }
                    if (message.chainLength != null && message.hasOwnProperty("chainLength")) {
                        let error = $root.ic_ledger.pb.v1.BlockHeight.verify(message.chainLength);
                        if (error)
                            return "chainLength." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TipOfChainResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.TipOfChainResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.TipOfChainResponse} TipOfChainResponse
                 */
                TipOfChainResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.TipOfChainResponse)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.TipOfChainResponse();
                    if (object.certification != null) {
                        if (typeof object.certification !== "object")
                            throw TypeError(".ic_ledger.pb.v1.TipOfChainResponse.certification: object expected");
                        message.certification = $root.ic_ledger.pb.v1.Certification.fromObject(object.certification);
                    }
                    if (object.chainLength != null) {
                        if (typeof object.chainLength !== "object")
                            throw TypeError(".ic_ledger.pb.v1.TipOfChainResponse.chainLength: object expected");
                        message.chainLength = $root.ic_ledger.pb.v1.BlockHeight.fromObject(object.chainLength);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TipOfChainResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.TipOfChainResponse
                 * @static
                 * @param {ic_ledger.pb.v1.TipOfChainResponse} message TipOfChainResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TipOfChainResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.certification = null;
                        object.chainLength = null;
                    }
                    if (message.certification != null && message.hasOwnProperty("certification"))
                        object.certification = $root.ic_ledger.pb.v1.Certification.toObject(message.certification, options);
                    if (message.chainLength != null && message.hasOwnProperty("chainLength"))
                        object.chainLength = $root.ic_ledger.pb.v1.BlockHeight.toObject(message.chainLength, options);
                    return object;
                };

                /**
                 * Converts this TipOfChainResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.TipOfChainResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TipOfChainResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TipOfChainResponse;
            })();

            v1.TotalSupplyRequest = (function() {

                /**
                 * Properties of a TotalSupplyRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface ITotalSupplyRequest
                 */

                /**
                 * Constructs a new TotalSupplyRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a TotalSupplyRequest.
                 * @implements ITotalSupplyRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.ITotalSupplyRequest=} [properties] Properties to set
                 */
                function TotalSupplyRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new TotalSupplyRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.TotalSupplyRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ITotalSupplyRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.TotalSupplyRequest} TotalSupplyRequest instance
                 */
                TotalSupplyRequest.create = function create(properties) {
                    return new TotalSupplyRequest(properties);
                };

                /**
                 * Encodes the specified TotalSupplyRequest message. Does not implicitly {@link ic_ledger.pb.v1.TotalSupplyRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.TotalSupplyRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ITotalSupplyRequest} message TotalSupplyRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TotalSupplyRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified TotalSupplyRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.TotalSupplyRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.TotalSupplyRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ITotalSupplyRequest} message TotalSupplyRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TotalSupplyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TotalSupplyRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.TotalSupplyRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.TotalSupplyRequest} TotalSupplyRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TotalSupplyRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.TotalSupplyRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TotalSupplyRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.TotalSupplyRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.TotalSupplyRequest} TotalSupplyRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TotalSupplyRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TotalSupplyRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.TotalSupplyRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TotalSupplyRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a TotalSupplyRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.TotalSupplyRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.TotalSupplyRequest} TotalSupplyRequest
                 */
                TotalSupplyRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.TotalSupplyRequest)
                        return object;
                    return new $root.ic_ledger.pb.v1.TotalSupplyRequest();
                };

                /**
                 * Creates a plain object from a TotalSupplyRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.TotalSupplyRequest
                 * @static
                 * @param {ic_ledger.pb.v1.TotalSupplyRequest} message TotalSupplyRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TotalSupplyRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this TotalSupplyRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.TotalSupplyRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TotalSupplyRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TotalSupplyRequest;
            })();

            v1.TotalSupplyResponse = (function() {

                /**
                 * Properties of a TotalSupplyResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface ITotalSupplyResponse
                 * @property {ic_ledger.pb.v1.IICPTs|null} [totalSupply] TotalSupplyResponse totalSupply
                 */

                /**
                 * Constructs a new TotalSupplyResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a TotalSupplyResponse.
                 * @implements ITotalSupplyResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.ITotalSupplyResponse=} [properties] Properties to set
                 */
                function TotalSupplyResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TotalSupplyResponse totalSupply.
                 * @member {ic_ledger.pb.v1.IICPTs|null|undefined} totalSupply
                 * @memberof ic_ledger.pb.v1.TotalSupplyResponse
                 * @instance
                 */
                TotalSupplyResponse.prototype.totalSupply = null;

                /**
                 * Creates a new TotalSupplyResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.TotalSupplyResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ITotalSupplyResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.TotalSupplyResponse} TotalSupplyResponse instance
                 */
                TotalSupplyResponse.create = function create(properties) {
                    return new TotalSupplyResponse(properties);
                };

                /**
                 * Encodes the specified TotalSupplyResponse message. Does not implicitly {@link ic_ledger.pb.v1.TotalSupplyResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.TotalSupplyResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ITotalSupplyResponse} message TotalSupplyResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TotalSupplyResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.totalSupply != null && Object.hasOwnProperty.call(message, "totalSupply"))
                        $root.ic_ledger.pb.v1.ICPTs.encode(message.totalSupply, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TotalSupplyResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.TotalSupplyResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.TotalSupplyResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ITotalSupplyResponse} message TotalSupplyResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TotalSupplyResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TotalSupplyResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.TotalSupplyResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.TotalSupplyResponse} TotalSupplyResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TotalSupplyResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.TotalSupplyResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.totalSupply = $root.ic_ledger.pb.v1.ICPTs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TotalSupplyResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.TotalSupplyResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.TotalSupplyResponse} TotalSupplyResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TotalSupplyResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TotalSupplyResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.TotalSupplyResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TotalSupplyResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.totalSupply != null && message.hasOwnProperty("totalSupply")) {
                        let error = $root.ic_ledger.pb.v1.ICPTs.verify(message.totalSupply);
                        if (error)
                            return "totalSupply." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TotalSupplyResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.TotalSupplyResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.TotalSupplyResponse} TotalSupplyResponse
                 */
                TotalSupplyResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.TotalSupplyResponse)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.TotalSupplyResponse();
                    if (object.totalSupply != null) {
                        if (typeof object.totalSupply !== "object")
                            throw TypeError(".ic_ledger.pb.v1.TotalSupplyResponse.totalSupply: object expected");
                        message.totalSupply = $root.ic_ledger.pb.v1.ICPTs.fromObject(object.totalSupply);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TotalSupplyResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.TotalSupplyResponse
                 * @static
                 * @param {ic_ledger.pb.v1.TotalSupplyResponse} message TotalSupplyResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TotalSupplyResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.totalSupply = null;
                    if (message.totalSupply != null && message.hasOwnProperty("totalSupply"))
                        object.totalSupply = $root.ic_ledger.pb.v1.ICPTs.toObject(message.totalSupply, options);
                    return object;
                };

                /**
                 * Converts this TotalSupplyResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.TotalSupplyResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TotalSupplyResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TotalSupplyResponse;
            })();

            v1.LedgerArchiveRequest = (function() {

                /**
                 * Properties of a LedgerArchiveRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface ILedgerArchiveRequest
                 * @property {ic_ledger.pb.v1.ITimeStamp|null} [timestamp] LedgerArchiveRequest timestamp
                 */

                /**
                 * Constructs a new LedgerArchiveRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a LedgerArchiveRequest.
                 * @implements ILedgerArchiveRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.ILedgerArchiveRequest=} [properties] Properties to set
                 */
                function LedgerArchiveRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LedgerArchiveRequest timestamp.
                 * @member {ic_ledger.pb.v1.ITimeStamp|null|undefined} timestamp
                 * @memberof ic_ledger.pb.v1.LedgerArchiveRequest
                 * @instance
                 */
                LedgerArchiveRequest.prototype.timestamp = null;

                /**
                 * Creates a new LedgerArchiveRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.LedgerArchiveRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ILedgerArchiveRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.LedgerArchiveRequest} LedgerArchiveRequest instance
                 */
                LedgerArchiveRequest.create = function create(properties) {
                    return new LedgerArchiveRequest(properties);
                };

                /**
                 * Encodes the specified LedgerArchiveRequest message. Does not implicitly {@link ic_ledger.pb.v1.LedgerArchiveRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.LedgerArchiveRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ILedgerArchiveRequest} message LedgerArchiveRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LedgerArchiveRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        $root.ic_ledger.pb.v1.TimeStamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified LedgerArchiveRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.LedgerArchiveRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.LedgerArchiveRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ILedgerArchiveRequest} message LedgerArchiveRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LedgerArchiveRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LedgerArchiveRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.LedgerArchiveRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.LedgerArchiveRequest} LedgerArchiveRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LedgerArchiveRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.LedgerArchiveRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.ic_ledger.pb.v1.TimeStamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LedgerArchiveRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.LedgerArchiveRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.LedgerArchiveRequest} LedgerArchiveRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LedgerArchiveRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LedgerArchiveRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.LedgerArchiveRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LedgerArchiveRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        let error = $root.ic_ledger.pb.v1.TimeStamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    return null;
                };

                /**
                 * Creates a LedgerArchiveRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.LedgerArchiveRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.LedgerArchiveRequest} LedgerArchiveRequest
                 */
                LedgerArchiveRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.LedgerArchiveRequest)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.LedgerArchiveRequest();
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".ic_ledger.pb.v1.LedgerArchiveRequest.timestamp: object expected");
                        message.timestamp = $root.ic_ledger.pb.v1.TimeStamp.fromObject(object.timestamp);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a LedgerArchiveRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.LedgerArchiveRequest
                 * @static
                 * @param {ic_ledger.pb.v1.LedgerArchiveRequest} message LedgerArchiveRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LedgerArchiveRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.timestamp = null;
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.ic_ledger.pb.v1.TimeStamp.toObject(message.timestamp, options);
                    return object;
                };

                /**
                 * Converts this LedgerArchiveRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.LedgerArchiveRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LedgerArchiveRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LedgerArchiveRequest;
            })();

            v1.BlockRequest = (function() {

                /**
                 * Properties of a BlockRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface IBlockRequest
                 * @property {number|Long|null} [blockHeight] BlockRequest blockHeight
                 */

                /**
                 * Constructs a new BlockRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a BlockRequest.
                 * @implements IBlockRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.IBlockRequest=} [properties] Properties to set
                 */
                function BlockRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BlockRequest blockHeight.
                 * @member {number|Long} blockHeight
                 * @memberof ic_ledger.pb.v1.BlockRequest
                 * @instance
                 */
                BlockRequest.prototype.blockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new BlockRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.BlockRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IBlockRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.BlockRequest} BlockRequest instance
                 */
                BlockRequest.create = function create(properties) {
                    return new BlockRequest(properties);
                };

                /**
                 * Encodes the specified BlockRequest message. Does not implicitly {@link ic_ledger.pb.v1.BlockRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.BlockRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IBlockRequest} message BlockRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlockRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.blockHeight);
                    return writer;
                };

                /**
                 * Encodes the specified BlockRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.BlockRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.BlockRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IBlockRequest} message BlockRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlockRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BlockRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.BlockRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.BlockRequest} BlockRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlockRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.BlockRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.blockHeight = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BlockRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.BlockRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.BlockRequest} BlockRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlockRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BlockRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.BlockRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BlockRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                        if (!$util.isInteger(message.blockHeight) && !(message.blockHeight && $util.isInteger(message.blockHeight.low) && $util.isInteger(message.blockHeight.high)))
                            return "blockHeight: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a BlockRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.BlockRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.BlockRequest} BlockRequest
                 */
                BlockRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.BlockRequest)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.BlockRequest();
                    if (object.blockHeight != null)
                        if ($util.Long)
                            (message.blockHeight = $util.Long.fromValue(object.blockHeight)).unsigned = true;
                        else if (typeof object.blockHeight === "string")
                            message.blockHeight = parseInt(object.blockHeight, 10);
                        else if (typeof object.blockHeight === "number")
                            message.blockHeight = object.blockHeight;
                        else if (typeof object.blockHeight === "object")
                            message.blockHeight = new $util.LongBits(object.blockHeight.low >>> 0, object.blockHeight.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a BlockRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.BlockRequest
                 * @static
                 * @param {ic_ledger.pb.v1.BlockRequest} message BlockRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BlockRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.blockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.blockHeight = options.longs === String ? "0" : 0;
                    if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                        if (typeof message.blockHeight === "number")
                            object.blockHeight = options.longs === String ? String(message.blockHeight) : message.blockHeight;
                        else
                            object.blockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.blockHeight) : options.longs === Number ? new $util.LongBits(message.blockHeight.low >>> 0, message.blockHeight.high >>> 0).toNumber(true) : message.blockHeight;
                    return object;
                };

                /**
                 * Converts this BlockRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.BlockRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BlockRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return BlockRequest;
            })();

            v1.EncodedBlock = (function() {

                /**
                 * Properties of an EncodedBlock.
                 * @memberof ic_ledger.pb.v1
                 * @interface IEncodedBlock
                 * @property {Uint8Array|null} [block] EncodedBlock block
                 */

                /**
                 * Constructs a new EncodedBlock.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an EncodedBlock.
                 * @implements IEncodedBlock
                 * @constructor
                 * @param {ic_ledger.pb.v1.IEncodedBlock=} [properties] Properties to set
                 */
                function EncodedBlock(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EncodedBlock block.
                 * @member {Uint8Array} block
                 * @memberof ic_ledger.pb.v1.EncodedBlock
                 * @instance
                 */
                EncodedBlock.prototype.block = $util.newBuffer([]);

                /**
                 * Creates a new EncodedBlock instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.EncodedBlock
                 * @static
                 * @param {ic_ledger.pb.v1.IEncodedBlock=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.EncodedBlock} EncodedBlock instance
                 */
                EncodedBlock.create = function create(properties) {
                    return new EncodedBlock(properties);
                };

                /**
                 * Encodes the specified EncodedBlock message. Does not implicitly {@link ic_ledger.pb.v1.EncodedBlock.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.EncodedBlock
                 * @static
                 * @param {ic_ledger.pb.v1.IEncodedBlock} message EncodedBlock message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EncodedBlock.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.block);
                    return writer;
                };

                /**
                 * Encodes the specified EncodedBlock message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.EncodedBlock.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.EncodedBlock
                 * @static
                 * @param {ic_ledger.pb.v1.IEncodedBlock} message EncodedBlock message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EncodedBlock.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EncodedBlock message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.EncodedBlock
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.EncodedBlock} EncodedBlock
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EncodedBlock.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.EncodedBlock();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.block = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EncodedBlock message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.EncodedBlock
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.EncodedBlock} EncodedBlock
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EncodedBlock.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EncodedBlock message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.EncodedBlock
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EncodedBlock.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.block != null && message.hasOwnProperty("block"))
                        if (!(message.block && typeof message.block.length === "number" || $util.isString(message.block)))
                            return "block: buffer expected";
                    return null;
                };

                /**
                 * Creates an EncodedBlock message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.EncodedBlock
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.EncodedBlock} EncodedBlock
                 */
                EncodedBlock.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.EncodedBlock)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.EncodedBlock();
                    if (object.block != null)
                        if (typeof object.block === "string")
                            $util.base64.decode(object.block, message.block = $util.newBuffer($util.base64.length(object.block)), 0);
                        else if (object.block.length)
                            message.block = object.block;
                    return message;
                };

                /**
                 * Creates a plain object from an EncodedBlock message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.EncodedBlock
                 * @static
                 * @param {ic_ledger.pb.v1.EncodedBlock} message EncodedBlock
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EncodedBlock.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.block = "";
                        else {
                            object.block = [];
                            if (options.bytes !== Array)
                                object.block = $util.newBuffer(object.block);
                        }
                    if (message.block != null && message.hasOwnProperty("block"))
                        object.block = options.bytes === String ? $util.base64.encode(message.block, 0, message.block.length) : options.bytes === Array ? Array.prototype.slice.call(message.block) : message.block;
                    return object;
                };

                /**
                 * Converts this EncodedBlock to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.EncodedBlock
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EncodedBlock.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return EncodedBlock;
            })();

            v1.BlockResponse = (function() {

                /**
                 * Properties of a BlockResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface IBlockResponse
                 * @property {ic_ledger.pb.v1.IEncodedBlock|null} [block] BlockResponse block
                 * @property {ic_base_types.pb.v1.IPrincipalId|null} [canisterId] BlockResponse canisterId
                 */

                /**
                 * Constructs a new BlockResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a BlockResponse.
                 * @implements IBlockResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.IBlockResponse=} [properties] Properties to set
                 */
                function BlockResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BlockResponse block.
                 * @member {ic_ledger.pb.v1.IEncodedBlock|null|undefined} block
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @instance
                 */
                BlockResponse.prototype.block = null;

                /**
                 * BlockResponse canisterId.
                 * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} canisterId
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @instance
                 */
                BlockResponse.prototype.canisterId = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * BlockResponse blockContent.
                 * @member {"block"|"canisterId"|undefined} blockContent
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @instance
                 */
                Object.defineProperty(BlockResponse.prototype, "blockContent", {
                    get: $util.oneOfGetter($oneOfFields = ["block", "canisterId"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new BlockResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IBlockResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.BlockResponse} BlockResponse instance
                 */
                BlockResponse.create = function create(properties) {
                    return new BlockResponse(properties);
                };

                /**
                 * Encodes the specified BlockResponse message. Does not implicitly {@link ic_ledger.pb.v1.BlockResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IBlockResponse} message BlockResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlockResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                        $root.ic_ledger.pb.v1.EncodedBlock.encode(message.block, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.canisterId != null && Object.hasOwnProperty.call(message, "canisterId"))
                        $root.ic_base_types.pb.v1.PrincipalId.encode(message.canisterId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BlockResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.BlockResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IBlockResponse} message BlockResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlockResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BlockResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.BlockResponse} BlockResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlockResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.BlockResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.block = $root.ic_ledger.pb.v1.EncodedBlock.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.canisterId = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BlockResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.BlockResponse} BlockResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlockResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BlockResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BlockResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.block != null && message.hasOwnProperty("block")) {
                        properties.blockContent = 1;
                        {
                            let error = $root.ic_ledger.pb.v1.EncodedBlock.verify(message.block);
                            if (error)
                                return "block." + error;
                        }
                    }
                    if (message.canisterId != null && message.hasOwnProperty("canisterId")) {
                        if (properties.blockContent === 1)
                            return "blockContent: multiple values";
                        properties.blockContent = 1;
                        {
                            let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.canisterId);
                            if (error)
                                return "canisterId." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a BlockResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.BlockResponse} BlockResponse
                 */
                BlockResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.BlockResponse)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.BlockResponse();
                    if (object.block != null) {
                        if (typeof object.block !== "object")
                            throw TypeError(".ic_ledger.pb.v1.BlockResponse.block: object expected");
                        message.block = $root.ic_ledger.pb.v1.EncodedBlock.fromObject(object.block);
                    }
                    if (object.canisterId != null) {
                        if (typeof object.canisterId !== "object")
                            throw TypeError(".ic_ledger.pb.v1.BlockResponse.canisterId: object expected");
                        message.canisterId = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.canisterId);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a BlockResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @static
                 * @param {ic_ledger.pb.v1.BlockResponse} message BlockResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BlockResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.block != null && message.hasOwnProperty("block")) {
                        object.block = $root.ic_ledger.pb.v1.EncodedBlock.toObject(message.block, options);
                        if (options.oneofs)
                            object.blockContent = "block";
                    }
                    if (message.canisterId != null && message.hasOwnProperty("canisterId")) {
                        object.canisterId = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.canisterId, options);
                        if (options.oneofs)
                            object.blockContent = "canisterId";
                    }
                    return object;
                };

                /**
                 * Converts this BlockResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.BlockResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BlockResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return BlockResponse;
            })();

            v1.GetBlocksRequest = (function() {

                /**
                 * Properties of a GetBlocksRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface IGetBlocksRequest
                 * @property {number|Long|null} [start] GetBlocksRequest start
                 * @property {number|Long|null} [length] GetBlocksRequest length
                 */

                /**
                 * Constructs a new GetBlocksRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a GetBlocksRequest.
                 * @implements IGetBlocksRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.IGetBlocksRequest=} [properties] Properties to set
                 */
                function GetBlocksRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetBlocksRequest start.
                 * @member {number|Long} start
                 * @memberof ic_ledger.pb.v1.GetBlocksRequest
                 * @instance
                 */
                GetBlocksRequest.prototype.start = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * GetBlocksRequest length.
                 * @member {number|Long} length
                 * @memberof ic_ledger.pb.v1.GetBlocksRequest
                 * @instance
                 */
                GetBlocksRequest.prototype.length = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new GetBlocksRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.GetBlocksRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IGetBlocksRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.GetBlocksRequest} GetBlocksRequest instance
                 */
                GetBlocksRequest.create = function create(properties) {
                    return new GetBlocksRequest(properties);
                };

                /**
                 * Encodes the specified GetBlocksRequest message. Does not implicitly {@link ic_ledger.pb.v1.GetBlocksRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.GetBlocksRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IGetBlocksRequest} message GetBlocksRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetBlocksRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.start);
                    if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.length);
                    return writer;
                };

                /**
                 * Encodes the specified GetBlocksRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.GetBlocksRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.GetBlocksRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IGetBlocksRequest} message GetBlocksRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetBlocksRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetBlocksRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.GetBlocksRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.GetBlocksRequest} GetBlocksRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetBlocksRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.GetBlocksRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.uint64();
                            break;
                        case 2:
                            message.length = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GetBlocksRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.GetBlocksRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.GetBlocksRequest} GetBlocksRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetBlocksRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetBlocksRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.GetBlocksRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetBlocksRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high)))
                            return "start: integer|Long expected";
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (!$util.isInteger(message.length) && !(message.length && $util.isInteger(message.length.low) && $util.isInteger(message.length.high)))
                            return "length: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a GetBlocksRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.GetBlocksRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.GetBlocksRequest} GetBlocksRequest
                 */
                GetBlocksRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.GetBlocksRequest)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.GetBlocksRequest();
                    if (object.start != null)
                        if ($util.Long)
                            (message.start = $util.Long.fromValue(object.start)).unsigned = true;
                        else if (typeof object.start === "string")
                            message.start = parseInt(object.start, 10);
                        else if (typeof object.start === "number")
                            message.start = object.start;
                        else if (typeof object.start === "object")
                            message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber(true);
                    if (object.length != null)
                        if ($util.Long)
                            (message.length = $util.Long.fromValue(object.length)).unsigned = true;
                        else if (typeof object.length === "string")
                            message.length = parseInt(object.length, 10);
                        else if (typeof object.length === "number")
                            message.length = object.length;
                        else if (typeof object.length === "object")
                            message.length = new $util.LongBits(object.length.low >>> 0, object.length.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a GetBlocksRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.GetBlocksRequest
                 * @static
                 * @param {ic_ledger.pb.v1.GetBlocksRequest} message GetBlocksRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetBlocksRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.start = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.start = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.length = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.length = options.longs === String ? "0" : 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (typeof message.start === "number")
                            object.start = options.longs === String ? String(message.start) : message.start;
                        else
                            object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber(true) : message.start;
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (typeof message.length === "number")
                            object.length = options.longs === String ? String(message.length) : message.length;
                        else
                            object.length = options.longs === String ? $util.Long.prototype.toString.call(message.length) : options.longs === Number ? new $util.LongBits(message.length.low >>> 0, message.length.high >>> 0).toNumber(true) : message.length;
                    return object;
                };

                /**
                 * Converts this GetBlocksRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.GetBlocksRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetBlocksRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetBlocksRequest;
            })();

            v1.Refund = (function() {

                /**
                 * Properties of a Refund.
                 * @memberof ic_ledger.pb.v1
                 * @interface IRefund
                 * @property {ic_ledger.pb.v1.IBlockHeight|null} [refund] Refund refund
                 * @property {string|null} [error] Refund error
                 */

                /**
                 * Constructs a new Refund.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a Refund.
                 * @implements IRefund
                 * @constructor
                 * @param {ic_ledger.pb.v1.IRefund=} [properties] Properties to set
                 */
                function Refund(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Refund refund.
                 * @member {ic_ledger.pb.v1.IBlockHeight|null|undefined} refund
                 * @memberof ic_ledger.pb.v1.Refund
                 * @instance
                 */
                Refund.prototype.refund = null;

                /**
                 * Refund error.
                 * @member {string} error
                 * @memberof ic_ledger.pb.v1.Refund
                 * @instance
                 */
                Refund.prototype.error = "";

                /**
                 * Creates a new Refund instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Refund
                 * @static
                 * @param {ic_ledger.pb.v1.IRefund=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Refund} Refund instance
                 */
                Refund.create = function create(properties) {
                    return new Refund(properties);
                };

                /**
                 * Encodes the specified Refund message. Does not implicitly {@link ic_ledger.pb.v1.Refund.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Refund
                 * @static
                 * @param {ic_ledger.pb.v1.IRefund} message Refund message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Refund.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.refund != null && Object.hasOwnProperty.call(message, "refund"))
                        $root.ic_ledger.pb.v1.BlockHeight.encode(message.refund, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.error);
                    return writer;
                };

                /**
                 * Encodes the specified Refund message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Refund.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Refund
                 * @static
                 * @param {ic_ledger.pb.v1.IRefund} message Refund message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Refund.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Refund message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Refund
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Refund} Refund
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Refund.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Refund();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.refund = $root.ic_ledger.pb.v1.BlockHeight.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.error = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Refund message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Refund
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Refund} Refund
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Refund.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Refund message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Refund
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Refund.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.refund != null && message.hasOwnProperty("refund")) {
                        let error = $root.ic_ledger.pb.v1.BlockHeight.verify(message.refund);
                        if (error)
                            return "refund." + error;
                    }
                    if (message.error != null && message.hasOwnProperty("error"))
                        if (!$util.isString(message.error))
                            return "error: string expected";
                    return null;
                };

                /**
                 * Creates a Refund message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Refund
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Refund} Refund
                 */
                Refund.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Refund)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Refund();
                    if (object.refund != null) {
                        if (typeof object.refund !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Refund.refund: object expected");
                        message.refund = $root.ic_ledger.pb.v1.BlockHeight.fromObject(object.refund);
                    }
                    if (object.error != null)
                        message.error = String(object.error);
                    return message;
                };

                /**
                 * Creates a plain object from a Refund message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Refund
                 * @static
                 * @param {ic_ledger.pb.v1.Refund} message Refund
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Refund.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.refund = null;
                        object.error = "";
                    }
                    if (message.refund != null && message.hasOwnProperty("refund"))
                        object.refund = $root.ic_ledger.pb.v1.BlockHeight.toObject(message.refund, options);
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = message.error;
                    return object;
                };

                /**
                 * Converts this Refund to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Refund
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Refund.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Refund;
            })();

            v1.ToppedUp = (function() {

                /**
                 * Properties of a ToppedUp.
                 * @memberof ic_ledger.pb.v1
                 * @interface IToppedUp
                 */

                /**
                 * Constructs a new ToppedUp.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a ToppedUp.
                 * @implements IToppedUp
                 * @constructor
                 * @param {ic_ledger.pb.v1.IToppedUp=} [properties] Properties to set
                 */
                function ToppedUp(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new ToppedUp instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.ToppedUp
                 * @static
                 * @param {ic_ledger.pb.v1.IToppedUp=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.ToppedUp} ToppedUp instance
                 */
                ToppedUp.create = function create(properties) {
                    return new ToppedUp(properties);
                };

                /**
                 * Encodes the specified ToppedUp message. Does not implicitly {@link ic_ledger.pb.v1.ToppedUp.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.ToppedUp
                 * @static
                 * @param {ic_ledger.pb.v1.IToppedUp} message ToppedUp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ToppedUp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified ToppedUp message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.ToppedUp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.ToppedUp
                 * @static
                 * @param {ic_ledger.pb.v1.IToppedUp} message ToppedUp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ToppedUp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ToppedUp message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.ToppedUp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.ToppedUp} ToppedUp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ToppedUp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.ToppedUp();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ToppedUp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.ToppedUp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.ToppedUp} ToppedUp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ToppedUp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ToppedUp message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.ToppedUp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ToppedUp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a ToppedUp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.ToppedUp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.ToppedUp} ToppedUp
                 */
                ToppedUp.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.ToppedUp)
                        return object;
                    return new $root.ic_ledger.pb.v1.ToppedUp();
                };

                /**
                 * Creates a plain object from a ToppedUp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.ToppedUp
                 * @static
                 * @param {ic_ledger.pb.v1.ToppedUp} message ToppedUp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ToppedUp.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this ToppedUp to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.ToppedUp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ToppedUp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ToppedUp;
            })();

            v1.EncodedBlocks = (function() {

                /**
                 * Properties of an EncodedBlocks.
                 * @memberof ic_ledger.pb.v1
                 * @interface IEncodedBlocks
                 * @property {Array.<ic_ledger.pb.v1.IEncodedBlock>|null} [blocks] EncodedBlocks blocks
                 */

                /**
                 * Constructs a new EncodedBlocks.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an EncodedBlocks.
                 * @implements IEncodedBlocks
                 * @constructor
                 * @param {ic_ledger.pb.v1.IEncodedBlocks=} [properties] Properties to set
                 */
                function EncodedBlocks(properties) {
                    this.blocks = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EncodedBlocks blocks.
                 * @member {Array.<ic_ledger.pb.v1.IEncodedBlock>} blocks
                 * @memberof ic_ledger.pb.v1.EncodedBlocks
                 * @instance
                 */
                EncodedBlocks.prototype.blocks = $util.emptyArray;

                /**
                 * Creates a new EncodedBlocks instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.EncodedBlocks
                 * @static
                 * @param {ic_ledger.pb.v1.IEncodedBlocks=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.EncodedBlocks} EncodedBlocks instance
                 */
                EncodedBlocks.create = function create(properties) {
                    return new EncodedBlocks(properties);
                };

                /**
                 * Encodes the specified EncodedBlocks message. Does not implicitly {@link ic_ledger.pb.v1.EncodedBlocks.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.EncodedBlocks
                 * @static
                 * @param {ic_ledger.pb.v1.IEncodedBlocks} message EncodedBlocks message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EncodedBlocks.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.blocks != null && message.blocks.length)
                        for (let i = 0; i < message.blocks.length; ++i)
                            $root.ic_ledger.pb.v1.EncodedBlock.encode(message.blocks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified EncodedBlocks message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.EncodedBlocks.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.EncodedBlocks
                 * @static
                 * @param {ic_ledger.pb.v1.IEncodedBlocks} message EncodedBlocks message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EncodedBlocks.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EncodedBlocks message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.EncodedBlocks
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.EncodedBlocks} EncodedBlocks
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EncodedBlocks.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.EncodedBlocks();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.blocks && message.blocks.length))
                                message.blocks = [];
                            message.blocks.push($root.ic_ledger.pb.v1.EncodedBlock.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EncodedBlocks message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.EncodedBlocks
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.EncodedBlocks} EncodedBlocks
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EncodedBlocks.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EncodedBlocks message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.EncodedBlocks
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EncodedBlocks.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.blocks != null && message.hasOwnProperty("blocks")) {
                        if (!Array.isArray(message.blocks))
                            return "blocks: array expected";
                        for (let i = 0; i < message.blocks.length; ++i) {
                            let error = $root.ic_ledger.pb.v1.EncodedBlock.verify(message.blocks[i]);
                            if (error)
                                return "blocks." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an EncodedBlocks message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.EncodedBlocks
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.EncodedBlocks} EncodedBlocks
                 */
                EncodedBlocks.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.EncodedBlocks)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.EncodedBlocks();
                    if (object.blocks) {
                        if (!Array.isArray(object.blocks))
                            throw TypeError(".ic_ledger.pb.v1.EncodedBlocks.blocks: array expected");
                        message.blocks = [];
                        for (let i = 0; i < object.blocks.length; ++i) {
                            if (typeof object.blocks[i] !== "object")
                                throw TypeError(".ic_ledger.pb.v1.EncodedBlocks.blocks: object expected");
                            message.blocks[i] = $root.ic_ledger.pb.v1.EncodedBlock.fromObject(object.blocks[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an EncodedBlocks message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.EncodedBlocks
                 * @static
                 * @param {ic_ledger.pb.v1.EncodedBlocks} message EncodedBlocks
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EncodedBlocks.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.blocks = [];
                    if (message.blocks && message.blocks.length) {
                        object.blocks = [];
                        for (let j = 0; j < message.blocks.length; ++j)
                            object.blocks[j] = $root.ic_ledger.pb.v1.EncodedBlock.toObject(message.blocks[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this EncodedBlocks to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.EncodedBlocks
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EncodedBlocks.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return EncodedBlocks;
            })();

            v1.GetBlocksResponse = (function() {

                /**
                 * Properties of a GetBlocksResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface IGetBlocksResponse
                 * @property {ic_ledger.pb.v1.IEncodedBlocks|null} [blocks] GetBlocksResponse blocks
                 * @property {string|null} [error] GetBlocksResponse error
                 */

                /**
                 * Constructs a new GetBlocksResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a GetBlocksResponse.
                 * @implements IGetBlocksResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.IGetBlocksResponse=} [properties] Properties to set
                 */
                function GetBlocksResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetBlocksResponse blocks.
                 * @member {ic_ledger.pb.v1.IEncodedBlocks|null|undefined} blocks
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @instance
                 */
                GetBlocksResponse.prototype.blocks = null;

                /**
                 * GetBlocksResponse error.
                 * @member {string|null|undefined} error
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @instance
                 */
                GetBlocksResponse.prototype.error = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * GetBlocksResponse getBlocksContent.
                 * @member {"blocks"|"error"|undefined} getBlocksContent
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @instance
                 */
                Object.defineProperty(GetBlocksResponse.prototype, "getBlocksContent", {
                    get: $util.oneOfGetter($oneOfFields = ["blocks", "error"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new GetBlocksResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IGetBlocksResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.GetBlocksResponse} GetBlocksResponse instance
                 */
                GetBlocksResponse.create = function create(properties) {
                    return new GetBlocksResponse(properties);
                };

                /**
                 * Encodes the specified GetBlocksResponse message. Does not implicitly {@link ic_ledger.pb.v1.GetBlocksResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IGetBlocksResponse} message GetBlocksResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetBlocksResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.blocks != null && Object.hasOwnProperty.call(message, "blocks"))
                        $root.ic_ledger.pb.v1.EncodedBlocks.encode(message.blocks, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.error);
                    return writer;
                };

                /**
                 * Encodes the specified GetBlocksResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.GetBlocksResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IGetBlocksResponse} message GetBlocksResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetBlocksResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetBlocksResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.GetBlocksResponse} GetBlocksResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetBlocksResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.GetBlocksResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.blocks = $root.ic_ledger.pb.v1.EncodedBlocks.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.error = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GetBlocksResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.GetBlocksResponse} GetBlocksResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetBlocksResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetBlocksResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetBlocksResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.blocks != null && message.hasOwnProperty("blocks")) {
                        properties.getBlocksContent = 1;
                        {
                            let error = $root.ic_ledger.pb.v1.EncodedBlocks.verify(message.blocks);
                            if (error)
                                return "blocks." + error;
                        }
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        if (properties.getBlocksContent === 1)
                            return "getBlocksContent: multiple values";
                        properties.getBlocksContent = 1;
                        if (!$util.isString(message.error))
                            return "error: string expected";
                    }
                    return null;
                };

                /**
                 * Creates a GetBlocksResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.GetBlocksResponse} GetBlocksResponse
                 */
                GetBlocksResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.GetBlocksResponse)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.GetBlocksResponse();
                    if (object.blocks != null) {
                        if (typeof object.blocks !== "object")
                            throw TypeError(".ic_ledger.pb.v1.GetBlocksResponse.blocks: object expected");
                        message.blocks = $root.ic_ledger.pb.v1.EncodedBlocks.fromObject(object.blocks);
                    }
                    if (object.error != null)
                        message.error = String(object.error);
                    return message;
                };

                /**
                 * Creates a plain object from a GetBlocksResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @static
                 * @param {ic_ledger.pb.v1.GetBlocksResponse} message GetBlocksResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetBlocksResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.blocks != null && message.hasOwnProperty("blocks")) {
                        object.blocks = $root.ic_ledger.pb.v1.EncodedBlocks.toObject(message.blocks, options);
                        if (options.oneofs)
                            object.getBlocksContent = "blocks";
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        object.error = message.error;
                        if (options.oneofs)
                            object.getBlocksContent = "error";
                    }
                    return object;
                };

                /**
                 * Converts this GetBlocksResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.GetBlocksResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetBlocksResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetBlocksResponse;
            })();

            v1.IterBlocksRequest = (function() {

                /**
                 * Properties of an IterBlocksRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface IIterBlocksRequest
                 * @property {number|Long|null} [start] IterBlocksRequest start
                 * @property {number|Long|null} [length] IterBlocksRequest length
                 */

                /**
                 * Constructs a new IterBlocksRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an IterBlocksRequest.
                 * @implements IIterBlocksRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.IIterBlocksRequest=} [properties] Properties to set
                 */
                function IterBlocksRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * IterBlocksRequest start.
                 * @member {number|Long} start
                 * @memberof ic_ledger.pb.v1.IterBlocksRequest
                 * @instance
                 */
                IterBlocksRequest.prototype.start = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * IterBlocksRequest length.
                 * @member {number|Long} length
                 * @memberof ic_ledger.pb.v1.IterBlocksRequest
                 * @instance
                 */
                IterBlocksRequest.prototype.length = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new IterBlocksRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.IterBlocksRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IIterBlocksRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.IterBlocksRequest} IterBlocksRequest instance
                 */
                IterBlocksRequest.create = function create(properties) {
                    return new IterBlocksRequest(properties);
                };

                /**
                 * Encodes the specified IterBlocksRequest message. Does not implicitly {@link ic_ledger.pb.v1.IterBlocksRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.IterBlocksRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IIterBlocksRequest} message IterBlocksRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IterBlocksRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.start);
                    if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.length);
                    return writer;
                };

                /**
                 * Encodes the specified IterBlocksRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.IterBlocksRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.IterBlocksRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IIterBlocksRequest} message IterBlocksRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IterBlocksRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an IterBlocksRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.IterBlocksRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.IterBlocksRequest} IterBlocksRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IterBlocksRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.IterBlocksRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.uint64();
                            break;
                        case 2:
                            message.length = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an IterBlocksRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.IterBlocksRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.IterBlocksRequest} IterBlocksRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IterBlocksRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an IterBlocksRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.IterBlocksRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                IterBlocksRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high)))
                            return "start: integer|Long expected";
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (!$util.isInteger(message.length) && !(message.length && $util.isInteger(message.length.low) && $util.isInteger(message.length.high)))
                            return "length: integer|Long expected";
                    return null;
                };

                /**
                 * Creates an IterBlocksRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.IterBlocksRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.IterBlocksRequest} IterBlocksRequest
                 */
                IterBlocksRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.IterBlocksRequest)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.IterBlocksRequest();
                    if (object.start != null)
                        if ($util.Long)
                            (message.start = $util.Long.fromValue(object.start)).unsigned = true;
                        else if (typeof object.start === "string")
                            message.start = parseInt(object.start, 10);
                        else if (typeof object.start === "number")
                            message.start = object.start;
                        else if (typeof object.start === "object")
                            message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber(true);
                    if (object.length != null)
                        if ($util.Long)
                            (message.length = $util.Long.fromValue(object.length)).unsigned = true;
                        else if (typeof object.length === "string")
                            message.length = parseInt(object.length, 10);
                        else if (typeof object.length === "number")
                            message.length = object.length;
                        else if (typeof object.length === "object")
                            message.length = new $util.LongBits(object.length.low >>> 0, object.length.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from an IterBlocksRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.IterBlocksRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IterBlocksRequest} message IterBlocksRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                IterBlocksRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.start = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.start = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.length = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.length = options.longs === String ? "0" : 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (typeof message.start === "number")
                            object.start = options.longs === String ? String(message.start) : message.start;
                        else
                            object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber(true) : message.start;
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (typeof message.length === "number")
                            object.length = options.longs === String ? String(message.length) : message.length;
                        else
                            object.length = options.longs === String ? $util.Long.prototype.toString.call(message.length) : options.longs === Number ? new $util.LongBits(message.length.low >>> 0, message.length.high >>> 0).toNumber(true) : message.length;
                    return object;
                };

                /**
                 * Converts this IterBlocksRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.IterBlocksRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                IterBlocksRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return IterBlocksRequest;
            })();

            v1.IterBlocksResponse = (function() {

                /**
                 * Properties of an IterBlocksResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface IIterBlocksResponse
                 * @property {Array.<ic_ledger.pb.v1.IEncodedBlock>|null} [blocks] IterBlocksResponse blocks
                 */

                /**
                 * Constructs a new IterBlocksResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an IterBlocksResponse.
                 * @implements IIterBlocksResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.IIterBlocksResponse=} [properties] Properties to set
                 */
                function IterBlocksResponse(properties) {
                    this.blocks = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * IterBlocksResponse blocks.
                 * @member {Array.<ic_ledger.pb.v1.IEncodedBlock>} blocks
                 * @memberof ic_ledger.pb.v1.IterBlocksResponse
                 * @instance
                 */
                IterBlocksResponse.prototype.blocks = $util.emptyArray;

                /**
                 * Creates a new IterBlocksResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.IterBlocksResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IIterBlocksResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.IterBlocksResponse} IterBlocksResponse instance
                 */
                IterBlocksResponse.create = function create(properties) {
                    return new IterBlocksResponse(properties);
                };

                /**
                 * Encodes the specified IterBlocksResponse message. Does not implicitly {@link ic_ledger.pb.v1.IterBlocksResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.IterBlocksResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IIterBlocksResponse} message IterBlocksResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IterBlocksResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.blocks != null && message.blocks.length)
                        for (let i = 0; i < message.blocks.length; ++i)
                            $root.ic_ledger.pb.v1.EncodedBlock.encode(message.blocks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified IterBlocksResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.IterBlocksResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.IterBlocksResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IIterBlocksResponse} message IterBlocksResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IterBlocksResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an IterBlocksResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.IterBlocksResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.IterBlocksResponse} IterBlocksResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IterBlocksResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.IterBlocksResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.blocks && message.blocks.length))
                                message.blocks = [];
                            message.blocks.push($root.ic_ledger.pb.v1.EncodedBlock.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an IterBlocksResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.IterBlocksResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.IterBlocksResponse} IterBlocksResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IterBlocksResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an IterBlocksResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.IterBlocksResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                IterBlocksResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.blocks != null && message.hasOwnProperty("blocks")) {
                        if (!Array.isArray(message.blocks))
                            return "blocks: array expected";
                        for (let i = 0; i < message.blocks.length; ++i) {
                            let error = $root.ic_ledger.pb.v1.EncodedBlock.verify(message.blocks[i]);
                            if (error)
                                return "blocks." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an IterBlocksResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.IterBlocksResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.IterBlocksResponse} IterBlocksResponse
                 */
                IterBlocksResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.IterBlocksResponse)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.IterBlocksResponse();
                    if (object.blocks) {
                        if (!Array.isArray(object.blocks))
                            throw TypeError(".ic_ledger.pb.v1.IterBlocksResponse.blocks: array expected");
                        message.blocks = [];
                        for (let i = 0; i < object.blocks.length; ++i) {
                            if (typeof object.blocks[i] !== "object")
                                throw TypeError(".ic_ledger.pb.v1.IterBlocksResponse.blocks: object expected");
                            message.blocks[i] = $root.ic_ledger.pb.v1.EncodedBlock.fromObject(object.blocks[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an IterBlocksResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.IterBlocksResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IterBlocksResponse} message IterBlocksResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                IterBlocksResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.blocks = [];
                    if (message.blocks && message.blocks.length) {
                        object.blocks = [];
                        for (let j = 0; j < message.blocks.length; ++j)
                            object.blocks[j] = $root.ic_ledger.pb.v1.EncodedBlock.toObject(message.blocks[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this IterBlocksResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.IterBlocksResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                IterBlocksResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return IterBlocksResponse;
            })();

            v1.ArchiveIndexEntry = (function() {

                /**
                 * Properties of an ArchiveIndexEntry.
                 * @memberof ic_ledger.pb.v1
                 * @interface IArchiveIndexEntry
                 * @property {number|Long|null} [heightFrom] ArchiveIndexEntry heightFrom
                 * @property {number|Long|null} [heightTo] ArchiveIndexEntry heightTo
                 * @property {ic_base_types.pb.v1.IPrincipalId|null} [canisterId] ArchiveIndexEntry canisterId
                 */

                /**
                 * Constructs a new ArchiveIndexEntry.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an ArchiveIndexEntry.
                 * @implements IArchiveIndexEntry
                 * @constructor
                 * @param {ic_ledger.pb.v1.IArchiveIndexEntry=} [properties] Properties to set
                 */
                function ArchiveIndexEntry(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ArchiveIndexEntry heightFrom.
                 * @member {number|Long} heightFrom
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @instance
                 */
                ArchiveIndexEntry.prototype.heightFrom = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ArchiveIndexEntry heightTo.
                 * @member {number|Long} heightTo
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @instance
                 */
                ArchiveIndexEntry.prototype.heightTo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ArchiveIndexEntry canisterId.
                 * @member {ic_base_types.pb.v1.IPrincipalId|null|undefined} canisterId
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @instance
                 */
                ArchiveIndexEntry.prototype.canisterId = null;

                /**
                 * Creates a new ArchiveIndexEntry instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveIndexEntry=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.ArchiveIndexEntry} ArchiveIndexEntry instance
                 */
                ArchiveIndexEntry.create = function create(properties) {
                    return new ArchiveIndexEntry(properties);
                };

                /**
                 * Encodes the specified ArchiveIndexEntry message. Does not implicitly {@link ic_ledger.pb.v1.ArchiveIndexEntry.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveIndexEntry} message ArchiveIndexEntry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArchiveIndexEntry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.heightFrom != null && Object.hasOwnProperty.call(message, "heightFrom"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.heightFrom);
                    if (message.heightTo != null && Object.hasOwnProperty.call(message, "heightTo"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.heightTo);
                    if (message.canisterId != null && Object.hasOwnProperty.call(message, "canisterId"))
                        $root.ic_base_types.pb.v1.PrincipalId.encode(message.canisterId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ArchiveIndexEntry message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.ArchiveIndexEntry.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveIndexEntry} message ArchiveIndexEntry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArchiveIndexEntry.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ArchiveIndexEntry message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.ArchiveIndexEntry} ArchiveIndexEntry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArchiveIndexEntry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.ArchiveIndexEntry();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.heightFrom = reader.uint64();
                            break;
                        case 2:
                            message.heightTo = reader.uint64();
                            break;
                        case 3:
                            message.canisterId = $root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ArchiveIndexEntry message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.ArchiveIndexEntry} ArchiveIndexEntry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArchiveIndexEntry.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ArchiveIndexEntry message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ArchiveIndexEntry.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.heightFrom != null && message.hasOwnProperty("heightFrom"))
                        if (!$util.isInteger(message.heightFrom) && !(message.heightFrom && $util.isInteger(message.heightFrom.low) && $util.isInteger(message.heightFrom.high)))
                            return "heightFrom: integer|Long expected";
                    if (message.heightTo != null && message.hasOwnProperty("heightTo"))
                        if (!$util.isInteger(message.heightTo) && !(message.heightTo && $util.isInteger(message.heightTo.low) && $util.isInteger(message.heightTo.high)))
                            return "heightTo: integer|Long expected";
                    if (message.canisterId != null && message.hasOwnProperty("canisterId")) {
                        let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.canisterId);
                        if (error)
                            return "canisterId." + error;
                    }
                    return null;
                };

                /**
                 * Creates an ArchiveIndexEntry message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.ArchiveIndexEntry} ArchiveIndexEntry
                 */
                ArchiveIndexEntry.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.ArchiveIndexEntry)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.ArchiveIndexEntry();
                    if (object.heightFrom != null)
                        if ($util.Long)
                            (message.heightFrom = $util.Long.fromValue(object.heightFrom)).unsigned = true;
                        else if (typeof object.heightFrom === "string")
                            message.heightFrom = parseInt(object.heightFrom, 10);
                        else if (typeof object.heightFrom === "number")
                            message.heightFrom = object.heightFrom;
                        else if (typeof object.heightFrom === "object")
                            message.heightFrom = new $util.LongBits(object.heightFrom.low >>> 0, object.heightFrom.high >>> 0).toNumber(true);
                    if (object.heightTo != null)
                        if ($util.Long)
                            (message.heightTo = $util.Long.fromValue(object.heightTo)).unsigned = true;
                        else if (typeof object.heightTo === "string")
                            message.heightTo = parseInt(object.heightTo, 10);
                        else if (typeof object.heightTo === "number")
                            message.heightTo = object.heightTo;
                        else if (typeof object.heightTo === "object")
                            message.heightTo = new $util.LongBits(object.heightTo.low >>> 0, object.heightTo.high >>> 0).toNumber(true);
                    if (object.canisterId != null) {
                        if (typeof object.canisterId !== "object")
                            throw TypeError(".ic_ledger.pb.v1.ArchiveIndexEntry.canisterId: object expected");
                        message.canisterId = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.canisterId);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ArchiveIndexEntry message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @static
                 * @param {ic_ledger.pb.v1.ArchiveIndexEntry} message ArchiveIndexEntry
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ArchiveIndexEntry.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.heightFrom = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.heightFrom = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.heightTo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.heightTo = options.longs === String ? "0" : 0;
                        object.canisterId = null;
                    }
                    if (message.heightFrom != null && message.hasOwnProperty("heightFrom"))
                        if (typeof message.heightFrom === "number")
                            object.heightFrom = options.longs === String ? String(message.heightFrom) : message.heightFrom;
                        else
                            object.heightFrom = options.longs === String ? $util.Long.prototype.toString.call(message.heightFrom) : options.longs === Number ? new $util.LongBits(message.heightFrom.low >>> 0, message.heightFrom.high >>> 0).toNumber(true) : message.heightFrom;
                    if (message.heightTo != null && message.hasOwnProperty("heightTo"))
                        if (typeof message.heightTo === "number")
                            object.heightTo = options.longs === String ? String(message.heightTo) : message.heightTo;
                        else
                            object.heightTo = options.longs === String ? $util.Long.prototype.toString.call(message.heightTo) : options.longs === Number ? new $util.LongBits(message.heightTo.low >>> 0, message.heightTo.high >>> 0).toNumber(true) : message.heightTo;
                    if (message.canisterId != null && message.hasOwnProperty("canisterId"))
                        object.canisterId = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.canisterId, options);
                    return object;
                };

                /**
                 * Converts this ArchiveIndexEntry to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.ArchiveIndexEntry
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ArchiveIndexEntry.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ArchiveIndexEntry;
            })();

            v1.ArchiveIndexResponse = (function() {

                /**
                 * Properties of an ArchiveIndexResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface IArchiveIndexResponse
                 * @property {Array.<ic_ledger.pb.v1.IArchiveIndexEntry>|null} [entries] ArchiveIndexResponse entries
                 */

                /**
                 * Constructs a new ArchiveIndexResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an ArchiveIndexResponse.
                 * @implements IArchiveIndexResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.IArchiveIndexResponse=} [properties] Properties to set
                 */
                function ArchiveIndexResponse(properties) {
                    this.entries = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ArchiveIndexResponse entries.
                 * @member {Array.<ic_ledger.pb.v1.IArchiveIndexEntry>} entries
                 * @memberof ic_ledger.pb.v1.ArchiveIndexResponse
                 * @instance
                 */
                ArchiveIndexResponse.prototype.entries = $util.emptyArray;

                /**
                 * Creates a new ArchiveIndexResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.ArchiveIndexResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveIndexResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.ArchiveIndexResponse} ArchiveIndexResponse instance
                 */
                ArchiveIndexResponse.create = function create(properties) {
                    return new ArchiveIndexResponse(properties);
                };

                /**
                 * Encodes the specified ArchiveIndexResponse message. Does not implicitly {@link ic_ledger.pb.v1.ArchiveIndexResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.ArchiveIndexResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveIndexResponse} message ArchiveIndexResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArchiveIndexResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entries != null && message.entries.length)
                        for (let i = 0; i < message.entries.length; ++i)
                            $root.ic_ledger.pb.v1.ArchiveIndexEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ArchiveIndexResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.ArchiveIndexResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.ArchiveIndexResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveIndexResponse} message ArchiveIndexResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArchiveIndexResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ArchiveIndexResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.ArchiveIndexResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.ArchiveIndexResponse} ArchiveIndexResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArchiveIndexResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.ArchiveIndexResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.entries && message.entries.length))
                                message.entries = [];
                            message.entries.push($root.ic_ledger.pb.v1.ArchiveIndexEntry.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ArchiveIndexResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.ArchiveIndexResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.ArchiveIndexResponse} ArchiveIndexResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArchiveIndexResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ArchiveIndexResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.ArchiveIndexResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ArchiveIndexResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entries != null && message.hasOwnProperty("entries")) {
                        if (!Array.isArray(message.entries))
                            return "entries: array expected";
                        for (let i = 0; i < message.entries.length; ++i) {
                            let error = $root.ic_ledger.pb.v1.ArchiveIndexEntry.verify(message.entries[i]);
                            if (error)
                                return "entries." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an ArchiveIndexResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.ArchiveIndexResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.ArchiveIndexResponse} ArchiveIndexResponse
                 */
                ArchiveIndexResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.ArchiveIndexResponse)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.ArchiveIndexResponse();
                    if (object.entries) {
                        if (!Array.isArray(object.entries))
                            throw TypeError(".ic_ledger.pb.v1.ArchiveIndexResponse.entries: array expected");
                        message.entries = [];
                        for (let i = 0; i < object.entries.length; ++i) {
                            if (typeof object.entries[i] !== "object")
                                throw TypeError(".ic_ledger.pb.v1.ArchiveIndexResponse.entries: object expected");
                            message.entries[i] = $root.ic_ledger.pb.v1.ArchiveIndexEntry.fromObject(object.entries[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ArchiveIndexResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.ArchiveIndexResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ArchiveIndexResponse} message ArchiveIndexResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ArchiveIndexResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.entries = [];
                    if (message.entries && message.entries.length) {
                        object.entries = [];
                        for (let j = 0; j < message.entries.length; ++j)
                            object.entries[j] = $root.ic_ledger.pb.v1.ArchiveIndexEntry.toObject(message.entries[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ArchiveIndexResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.ArchiveIndexResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ArchiveIndexResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ArchiveIndexResponse;
            })();

            v1.ArchiveInit = (function() {

                /**
                 * Properties of an ArchiveInit.
                 * @memberof ic_ledger.pb.v1
                 * @interface IArchiveInit
                 * @property {number|null} [nodeMaxMemorySizeBytes] ArchiveInit nodeMaxMemorySizeBytes
                 * @property {number|null} [maxMessageSizeBytes] ArchiveInit maxMessageSizeBytes
                 */

                /**
                 * Constructs a new ArchiveInit.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an ArchiveInit.
                 * @implements IArchiveInit
                 * @constructor
                 * @param {ic_ledger.pb.v1.IArchiveInit=} [properties] Properties to set
                 */
                function ArchiveInit(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ArchiveInit nodeMaxMemorySizeBytes.
                 * @member {number} nodeMaxMemorySizeBytes
                 * @memberof ic_ledger.pb.v1.ArchiveInit
                 * @instance
                 */
                ArchiveInit.prototype.nodeMaxMemorySizeBytes = 0;

                /**
                 * ArchiveInit maxMessageSizeBytes.
                 * @member {number} maxMessageSizeBytes
                 * @memberof ic_ledger.pb.v1.ArchiveInit
                 * @instance
                 */
                ArchiveInit.prototype.maxMessageSizeBytes = 0;

                /**
                 * Creates a new ArchiveInit instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.ArchiveInit
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveInit=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.ArchiveInit} ArchiveInit instance
                 */
                ArchiveInit.create = function create(properties) {
                    return new ArchiveInit(properties);
                };

                /**
                 * Encodes the specified ArchiveInit message. Does not implicitly {@link ic_ledger.pb.v1.ArchiveInit.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.ArchiveInit
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveInit} message ArchiveInit message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArchiveInit.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodeMaxMemorySizeBytes != null && Object.hasOwnProperty.call(message, "nodeMaxMemorySizeBytes"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.nodeMaxMemorySizeBytes);
                    if (message.maxMessageSizeBytes != null && Object.hasOwnProperty.call(message, "maxMessageSizeBytes"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.maxMessageSizeBytes);
                    return writer;
                };

                /**
                 * Encodes the specified ArchiveInit message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.ArchiveInit.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.ArchiveInit
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveInit} message ArchiveInit message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArchiveInit.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ArchiveInit message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.ArchiveInit
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.ArchiveInit} ArchiveInit
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArchiveInit.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.ArchiveInit();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nodeMaxMemorySizeBytes = reader.uint32();
                            break;
                        case 2:
                            message.maxMessageSizeBytes = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ArchiveInit message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.ArchiveInit
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.ArchiveInit} ArchiveInit
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArchiveInit.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ArchiveInit message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.ArchiveInit
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ArchiveInit.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodeMaxMemorySizeBytes != null && message.hasOwnProperty("nodeMaxMemorySizeBytes"))
                        if (!$util.isInteger(message.nodeMaxMemorySizeBytes))
                            return "nodeMaxMemorySizeBytes: integer expected";
                    if (message.maxMessageSizeBytes != null && message.hasOwnProperty("maxMessageSizeBytes"))
                        if (!$util.isInteger(message.maxMessageSizeBytes))
                            return "maxMessageSizeBytes: integer expected";
                    return null;
                };

                /**
                 * Creates an ArchiveInit message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.ArchiveInit
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.ArchiveInit} ArchiveInit
                 */
                ArchiveInit.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.ArchiveInit)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.ArchiveInit();
                    if (object.nodeMaxMemorySizeBytes != null)
                        message.nodeMaxMemorySizeBytes = object.nodeMaxMemorySizeBytes >>> 0;
                    if (object.maxMessageSizeBytes != null)
                        message.maxMessageSizeBytes = object.maxMessageSizeBytes >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ArchiveInit message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.ArchiveInit
                 * @static
                 * @param {ic_ledger.pb.v1.ArchiveInit} message ArchiveInit
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ArchiveInit.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.nodeMaxMemorySizeBytes = 0;
                        object.maxMessageSizeBytes = 0;
                    }
                    if (message.nodeMaxMemorySizeBytes != null && message.hasOwnProperty("nodeMaxMemorySizeBytes"))
                        object.nodeMaxMemorySizeBytes = message.nodeMaxMemorySizeBytes;
                    if (message.maxMessageSizeBytes != null && message.hasOwnProperty("maxMessageSizeBytes"))
                        object.maxMessageSizeBytes = message.maxMessageSizeBytes;
                    return object;
                };

                /**
                 * Converts this ArchiveInit to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.ArchiveInit
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ArchiveInit.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ArchiveInit;
            })();

            v1.ArchiveAddRequest = (function() {

                /**
                 * Properties of an ArchiveAddRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface IArchiveAddRequest
                 * @property {Array.<ic_ledger.pb.v1.IBlock>|null} [blocks] ArchiveAddRequest blocks
                 */

                /**
                 * Constructs a new ArchiveAddRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an ArchiveAddRequest.
                 * @implements IArchiveAddRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.IArchiveAddRequest=} [properties] Properties to set
                 */
                function ArchiveAddRequest(properties) {
                    this.blocks = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ArchiveAddRequest blocks.
                 * @member {Array.<ic_ledger.pb.v1.IBlock>} blocks
                 * @memberof ic_ledger.pb.v1.ArchiveAddRequest
                 * @instance
                 */
                ArchiveAddRequest.prototype.blocks = $util.emptyArray;

                /**
                 * Creates a new ArchiveAddRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.ArchiveAddRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveAddRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.ArchiveAddRequest} ArchiveAddRequest instance
                 */
                ArchiveAddRequest.create = function create(properties) {
                    return new ArchiveAddRequest(properties);
                };

                /**
                 * Encodes the specified ArchiveAddRequest message. Does not implicitly {@link ic_ledger.pb.v1.ArchiveAddRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.ArchiveAddRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveAddRequest} message ArchiveAddRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArchiveAddRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.blocks != null && message.blocks.length)
                        for (let i = 0; i < message.blocks.length; ++i)
                            $root.ic_ledger.pb.v1.Block.encode(message.blocks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ArchiveAddRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.ArchiveAddRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.ArchiveAddRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveAddRequest} message ArchiveAddRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArchiveAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ArchiveAddRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.ArchiveAddRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.ArchiveAddRequest} ArchiveAddRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArchiveAddRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.ArchiveAddRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.blocks && message.blocks.length))
                                message.blocks = [];
                            message.blocks.push($root.ic_ledger.pb.v1.Block.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ArchiveAddRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.ArchiveAddRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.ArchiveAddRequest} ArchiveAddRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArchiveAddRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ArchiveAddRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.ArchiveAddRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ArchiveAddRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.blocks != null && message.hasOwnProperty("blocks")) {
                        if (!Array.isArray(message.blocks))
                            return "blocks: array expected";
                        for (let i = 0; i < message.blocks.length; ++i) {
                            let error = $root.ic_ledger.pb.v1.Block.verify(message.blocks[i]);
                            if (error)
                                return "blocks." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an ArchiveAddRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.ArchiveAddRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.ArchiveAddRequest} ArchiveAddRequest
                 */
                ArchiveAddRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.ArchiveAddRequest)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.ArchiveAddRequest();
                    if (object.blocks) {
                        if (!Array.isArray(object.blocks))
                            throw TypeError(".ic_ledger.pb.v1.ArchiveAddRequest.blocks: array expected");
                        message.blocks = [];
                        for (let i = 0; i < object.blocks.length; ++i) {
                            if (typeof object.blocks[i] !== "object")
                                throw TypeError(".ic_ledger.pb.v1.ArchiveAddRequest.blocks: object expected");
                            message.blocks[i] = $root.ic_ledger.pb.v1.Block.fromObject(object.blocks[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ArchiveAddRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.ArchiveAddRequest
                 * @static
                 * @param {ic_ledger.pb.v1.ArchiveAddRequest} message ArchiveAddRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ArchiveAddRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.blocks = [];
                    if (message.blocks && message.blocks.length) {
                        object.blocks = [];
                        for (let j = 0; j < message.blocks.length; ++j)
                            object.blocks[j] = $root.ic_ledger.pb.v1.Block.toObject(message.blocks[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ArchiveAddRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.ArchiveAddRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ArchiveAddRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ArchiveAddRequest;
            })();

            v1.ArchiveAddResponse = (function() {

                /**
                 * Properties of an ArchiveAddResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface IArchiveAddResponse
                 */

                /**
                 * Constructs a new ArchiveAddResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an ArchiveAddResponse.
                 * @implements IArchiveAddResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.IArchiveAddResponse=} [properties] Properties to set
                 */
                function ArchiveAddResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new ArchiveAddResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.ArchiveAddResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveAddResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.ArchiveAddResponse} ArchiveAddResponse instance
                 */
                ArchiveAddResponse.create = function create(properties) {
                    return new ArchiveAddResponse(properties);
                };

                /**
                 * Encodes the specified ArchiveAddResponse message. Does not implicitly {@link ic_ledger.pb.v1.ArchiveAddResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.ArchiveAddResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveAddResponse} message ArchiveAddResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArchiveAddResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified ArchiveAddResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.ArchiveAddResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.ArchiveAddResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IArchiveAddResponse} message ArchiveAddResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArchiveAddResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ArchiveAddResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.ArchiveAddResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.ArchiveAddResponse} ArchiveAddResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArchiveAddResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.ArchiveAddResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ArchiveAddResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.ArchiveAddResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.ArchiveAddResponse} ArchiveAddResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArchiveAddResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ArchiveAddResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.ArchiveAddResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ArchiveAddResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an ArchiveAddResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.ArchiveAddResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.ArchiveAddResponse} ArchiveAddResponse
                 */
                ArchiveAddResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.ArchiveAddResponse)
                        return object;
                    return new $root.ic_ledger.pb.v1.ArchiveAddResponse();
                };

                /**
                 * Creates a plain object from an ArchiveAddResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.ArchiveAddResponse
                 * @static
                 * @param {ic_ledger.pb.v1.ArchiveAddResponse} message ArchiveAddResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ArchiveAddResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this ArchiveAddResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.ArchiveAddResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ArchiveAddResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ArchiveAddResponse;
            })();

            v1.GetNodesRequest = (function() {

                /**
                 * Properties of a GetNodesRequest.
                 * @memberof ic_ledger.pb.v1
                 * @interface IGetNodesRequest
                 */

                /**
                 * Constructs a new GetNodesRequest.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a GetNodesRequest.
                 * @implements IGetNodesRequest
                 * @constructor
                 * @param {ic_ledger.pb.v1.IGetNodesRequest=} [properties] Properties to set
                 */
                function GetNodesRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new GetNodesRequest instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.GetNodesRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IGetNodesRequest=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.GetNodesRequest} GetNodesRequest instance
                 */
                GetNodesRequest.create = function create(properties) {
                    return new GetNodesRequest(properties);
                };

                /**
                 * Encodes the specified GetNodesRequest message. Does not implicitly {@link ic_ledger.pb.v1.GetNodesRequest.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.GetNodesRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IGetNodesRequest} message GetNodesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetNodesRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified GetNodesRequest message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.GetNodesRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.GetNodesRequest
                 * @static
                 * @param {ic_ledger.pb.v1.IGetNodesRequest} message GetNodesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetNodesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetNodesRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.GetNodesRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.GetNodesRequest} GetNodesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetNodesRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.GetNodesRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GetNodesRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.GetNodesRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.GetNodesRequest} GetNodesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetNodesRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetNodesRequest message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.GetNodesRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetNodesRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a GetNodesRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.GetNodesRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.GetNodesRequest} GetNodesRequest
                 */
                GetNodesRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.GetNodesRequest)
                        return object;
                    return new $root.ic_ledger.pb.v1.GetNodesRequest();
                };

                /**
                 * Creates a plain object from a GetNodesRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.GetNodesRequest
                 * @static
                 * @param {ic_ledger.pb.v1.GetNodesRequest} message GetNodesRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetNodesRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this GetNodesRequest to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.GetNodesRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetNodesRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetNodesRequest;
            })();

            v1.GetNodesResponse = (function() {

                /**
                 * Properties of a GetNodesResponse.
                 * @memberof ic_ledger.pb.v1
                 * @interface IGetNodesResponse
                 * @property {Array.<ic_base_types.pb.v1.IPrincipalId>|null} [nodes] GetNodesResponse nodes
                 */

                /**
                 * Constructs a new GetNodesResponse.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a GetNodesResponse.
                 * @implements IGetNodesResponse
                 * @constructor
                 * @param {ic_ledger.pb.v1.IGetNodesResponse=} [properties] Properties to set
                 */
                function GetNodesResponse(properties) {
                    this.nodes = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetNodesResponse nodes.
                 * @member {Array.<ic_base_types.pb.v1.IPrincipalId>} nodes
                 * @memberof ic_ledger.pb.v1.GetNodesResponse
                 * @instance
                 */
                GetNodesResponse.prototype.nodes = $util.emptyArray;

                /**
                 * Creates a new GetNodesResponse instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.GetNodesResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IGetNodesResponse=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.GetNodesResponse} GetNodesResponse instance
                 */
                GetNodesResponse.create = function create(properties) {
                    return new GetNodesResponse(properties);
                };

                /**
                 * Encodes the specified GetNodesResponse message. Does not implicitly {@link ic_ledger.pb.v1.GetNodesResponse.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.GetNodesResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IGetNodesResponse} message GetNodesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetNodesResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodes != null && message.nodes.length)
                        for (let i = 0; i < message.nodes.length; ++i)
                            $root.ic_base_types.pb.v1.PrincipalId.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified GetNodesResponse message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.GetNodesResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.GetNodesResponse
                 * @static
                 * @param {ic_ledger.pb.v1.IGetNodesResponse} message GetNodesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetNodesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetNodesResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.GetNodesResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.GetNodesResponse} GetNodesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetNodesResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.GetNodesResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push($root.ic_base_types.pb.v1.PrincipalId.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GetNodesResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.GetNodesResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.GetNodesResponse} GetNodesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetNodesResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetNodesResponse message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.GetNodesResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetNodesResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
                        if (!Array.isArray(message.nodes))
                            return "nodes: array expected";
                        for (let i = 0; i < message.nodes.length; ++i) {
                            let error = $root.ic_base_types.pb.v1.PrincipalId.verify(message.nodes[i]);
                            if (error)
                                return "nodes." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetNodesResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.GetNodesResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.GetNodesResponse} GetNodesResponse
                 */
                GetNodesResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.GetNodesResponse)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.GetNodesResponse();
                    if (object.nodes) {
                        if (!Array.isArray(object.nodes))
                            throw TypeError(".ic_ledger.pb.v1.GetNodesResponse.nodes: array expected");
                        message.nodes = [];
                        for (let i = 0; i < object.nodes.length; ++i) {
                            if (typeof object.nodes[i] !== "object")
                                throw TypeError(".ic_ledger.pb.v1.GetNodesResponse.nodes: object expected");
                            message.nodes[i] = $root.ic_base_types.pb.v1.PrincipalId.fromObject(object.nodes[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetNodesResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.GetNodesResponse
                 * @static
                 * @param {ic_ledger.pb.v1.GetNodesResponse} message GetNodesResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetNodesResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.nodes = [];
                    if (message.nodes && message.nodes.length) {
                        object.nodes = [];
                        for (let j = 0; j < message.nodes.length; ++j)
                            object.nodes[j] = $root.ic_base_types.pb.v1.PrincipalId.toObject(message.nodes[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetNodesResponse to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.GetNodesResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetNodesResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetNodesResponse;
            })();

            v1.ICPTs = (function() {

                /**
                 * Properties of a ICPTs.
                 * @memberof ic_ledger.pb.v1
                 * @interface IICPTs
                 * @property {number|Long|null} [e8s] ICPTs e8s
                 */

                /**
                 * Constructs a new ICPTs.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a ICPTs.
                 * @implements IICPTs
                 * @constructor
                 * @param {ic_ledger.pb.v1.IICPTs=} [properties] Properties to set
                 */
                function ICPTs(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ICPTs e8s.
                 * @member {number|Long} e8s
                 * @memberof ic_ledger.pb.v1.ICPTs
                 * @instance
                 */
                ICPTs.prototype.e8s = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new ICPTs instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.ICPTs
                 * @static
                 * @param {ic_ledger.pb.v1.IICPTs=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.ICPTs} ICPTs instance
                 */
                ICPTs.create = function create(properties) {
                    return new ICPTs(properties);
                };

                /**
                 * Encodes the specified ICPTs message. Does not implicitly {@link ic_ledger.pb.v1.ICPTs.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.ICPTs
                 * @static
                 * @param {ic_ledger.pb.v1.IICPTs} message ICPTs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ICPTs.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.e8s != null && Object.hasOwnProperty.call(message, "e8s"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.e8s);
                    return writer;
                };

                /**
                 * Encodes the specified ICPTs message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.ICPTs.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.ICPTs
                 * @static
                 * @param {ic_ledger.pb.v1.IICPTs} message ICPTs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ICPTs.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ICPTs message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.ICPTs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.ICPTs} ICPTs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ICPTs.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.ICPTs();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.e8s = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ICPTs message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.ICPTs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.ICPTs} ICPTs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ICPTs.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ICPTs message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.ICPTs
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ICPTs.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.e8s != null && message.hasOwnProperty("e8s"))
                        if (!$util.isInteger(message.e8s) && !(message.e8s && $util.isInteger(message.e8s.low) && $util.isInteger(message.e8s.high)))
                            return "e8s: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ICPTs message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.ICPTs
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.ICPTs} ICPTs
                 */
                ICPTs.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.ICPTs)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.ICPTs();
                    if (object.e8s != null)
                        if ($util.Long)
                            (message.e8s = $util.Long.fromValue(object.e8s)).unsigned = true;
                        else if (typeof object.e8s === "string")
                            message.e8s = parseInt(object.e8s, 10);
                        else if (typeof object.e8s === "number")
                            message.e8s = object.e8s;
                        else if (typeof object.e8s === "object")
                            message.e8s = new $util.LongBits(object.e8s.low >>> 0, object.e8s.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a ICPTs message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.ICPTs
                 * @static
                 * @param {ic_ledger.pb.v1.ICPTs} message ICPTs
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ICPTs.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.e8s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.e8s = options.longs === String ? "0" : 0;
                    if (message.e8s != null && message.hasOwnProperty("e8s"))
                        if (typeof message.e8s === "number")
                            object.e8s = options.longs === String ? String(message.e8s) : message.e8s;
                        else
                            object.e8s = options.longs === String ? $util.Long.prototype.toString.call(message.e8s) : options.longs === Number ? new $util.LongBits(message.e8s.low >>> 0, message.e8s.high >>> 0).toNumber(true) : message.e8s;
                    return object;
                };

                /**
                 * Converts this ICPTs to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.ICPTs
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ICPTs.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ICPTs;
            })();

            v1.Payment = (function() {

                /**
                 * Properties of a Payment.
                 * @memberof ic_ledger.pb.v1
                 * @interface IPayment
                 * @property {ic_ledger.pb.v1.IICPTs|null} [receiverGets] Payment receiverGets
                 */

                /**
                 * Constructs a new Payment.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a Payment.
                 * @implements IPayment
                 * @constructor
                 * @param {ic_ledger.pb.v1.IPayment=} [properties] Properties to set
                 */
                function Payment(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Payment receiverGets.
                 * @member {ic_ledger.pb.v1.IICPTs|null|undefined} receiverGets
                 * @memberof ic_ledger.pb.v1.Payment
                 * @instance
                 */
                Payment.prototype.receiverGets = null;

                /**
                 * Creates a new Payment instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Payment
                 * @static
                 * @param {ic_ledger.pb.v1.IPayment=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Payment} Payment instance
                 */
                Payment.create = function create(properties) {
                    return new Payment(properties);
                };

                /**
                 * Encodes the specified Payment message. Does not implicitly {@link ic_ledger.pb.v1.Payment.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Payment
                 * @static
                 * @param {ic_ledger.pb.v1.IPayment} message Payment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Payment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.receiverGets != null && Object.hasOwnProperty.call(message, "receiverGets"))
                        $root.ic_ledger.pb.v1.ICPTs.encode(message.receiverGets, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Payment message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Payment.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Payment
                 * @static
                 * @param {ic_ledger.pb.v1.IPayment} message Payment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Payment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Payment message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Payment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Payment} Payment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Payment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Payment();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.receiverGets = $root.ic_ledger.pb.v1.ICPTs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Payment message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Payment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Payment} Payment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Payment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Payment message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Payment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Payment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.receiverGets != null && message.hasOwnProperty("receiverGets")) {
                        let error = $root.ic_ledger.pb.v1.ICPTs.verify(message.receiverGets);
                        if (error)
                            return "receiverGets." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Payment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Payment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Payment} Payment
                 */
                Payment.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Payment)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Payment();
                    if (object.receiverGets != null) {
                        if (typeof object.receiverGets !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Payment.receiverGets: object expected");
                        message.receiverGets = $root.ic_ledger.pb.v1.ICPTs.fromObject(object.receiverGets);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Payment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Payment
                 * @static
                 * @param {ic_ledger.pb.v1.Payment} message Payment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Payment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.receiverGets = null;
                    if (message.receiverGets != null && message.hasOwnProperty("receiverGets"))
                        object.receiverGets = $root.ic_ledger.pb.v1.ICPTs.toObject(message.receiverGets, options);
                    return object;
                };

                /**
                 * Converts this Payment to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Payment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Payment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Payment;
            })();

            v1.BlockHeight = (function() {

                /**
                 * Properties of a BlockHeight.
                 * @memberof ic_ledger.pb.v1
                 * @interface IBlockHeight
                 * @property {number|Long|null} [height] BlockHeight height
                 */

                /**
                 * Constructs a new BlockHeight.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a BlockHeight.
                 * @implements IBlockHeight
                 * @constructor
                 * @param {ic_ledger.pb.v1.IBlockHeight=} [properties] Properties to set
                 */
                function BlockHeight(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BlockHeight height.
                 * @member {number|Long} height
                 * @memberof ic_ledger.pb.v1.BlockHeight
                 * @instance
                 */
                BlockHeight.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new BlockHeight instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.BlockHeight
                 * @static
                 * @param {ic_ledger.pb.v1.IBlockHeight=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.BlockHeight} BlockHeight instance
                 */
                BlockHeight.create = function create(properties) {
                    return new BlockHeight(properties);
                };

                /**
                 * Encodes the specified BlockHeight message. Does not implicitly {@link ic_ledger.pb.v1.BlockHeight.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.BlockHeight
                 * @static
                 * @param {ic_ledger.pb.v1.IBlockHeight} message BlockHeight message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlockHeight.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.height);
                    return writer;
                };

                /**
                 * Encodes the specified BlockHeight message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.BlockHeight.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.BlockHeight
                 * @static
                 * @param {ic_ledger.pb.v1.IBlockHeight} message BlockHeight message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BlockHeight.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BlockHeight message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.BlockHeight
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.BlockHeight} BlockHeight
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlockHeight.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.BlockHeight();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.height = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BlockHeight message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.BlockHeight
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.BlockHeight} BlockHeight
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BlockHeight.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BlockHeight message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.BlockHeight
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BlockHeight.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                            return "height: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a BlockHeight message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.BlockHeight
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.BlockHeight} BlockHeight
                 */
                BlockHeight.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.BlockHeight)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.BlockHeight();
                    if (object.height != null)
                        if ($util.Long)
                            (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                        else if (typeof object.height === "string")
                            message.height = parseInt(object.height, 10);
                        else if (typeof object.height === "number")
                            message.height = object.height;
                        else if (typeof object.height === "object")
                            message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a BlockHeight message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.BlockHeight
                 * @static
                 * @param {ic_ledger.pb.v1.BlockHeight} message BlockHeight
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BlockHeight.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.height = options.longs === String ? "0" : 0;
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (typeof message.height === "number")
                            object.height = options.longs === String ? String(message.height) : message.height;
                        else
                            object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                    return object;
                };

                /**
                 * Converts this BlockHeight to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.BlockHeight
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BlockHeight.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return BlockHeight;
            })();

            v1.Block = (function() {

                /**
                 * Properties of a Block.
                 * @memberof ic_ledger.pb.v1
                 * @interface IBlock
                 * @property {ic_ledger.pb.v1.IHash|null} [parentHash] Block parentHash
                 * @property {ic_ledger.pb.v1.ITimeStamp|null} [timestamp] Block timestamp
                 * @property {ic_ledger.pb.v1.ITransaction|null} [transaction] Block transaction
                 */

                /**
                 * Constructs a new Block.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a Block.
                 * @implements IBlock
                 * @constructor
                 * @param {ic_ledger.pb.v1.IBlock=} [properties] Properties to set
                 */
                function Block(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Block parentHash.
                 * @member {ic_ledger.pb.v1.IHash|null|undefined} parentHash
                 * @memberof ic_ledger.pb.v1.Block
                 * @instance
                 */
                Block.prototype.parentHash = null;

                /**
                 * Block timestamp.
                 * @member {ic_ledger.pb.v1.ITimeStamp|null|undefined} timestamp
                 * @memberof ic_ledger.pb.v1.Block
                 * @instance
                 */
                Block.prototype.timestamp = null;

                /**
                 * Block transaction.
                 * @member {ic_ledger.pb.v1.ITransaction|null|undefined} transaction
                 * @memberof ic_ledger.pb.v1.Block
                 * @instance
                 */
                Block.prototype.transaction = null;

                /**
                 * Creates a new Block instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Block
                 * @static
                 * @param {ic_ledger.pb.v1.IBlock=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Block} Block instance
                 */
                Block.create = function create(properties) {
                    return new Block(properties);
                };

                /**
                 * Encodes the specified Block message. Does not implicitly {@link ic_ledger.pb.v1.Block.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Block
                 * @static
                 * @param {ic_ledger.pb.v1.IBlock} message Block message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Block.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.parentHash != null && Object.hasOwnProperty.call(message, "parentHash"))
                        $root.ic_ledger.pb.v1.Hash.encode(message.parentHash, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        $root.ic_ledger.pb.v1.TimeStamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                        $root.ic_ledger.pb.v1.Transaction.encode(message.transaction, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Block message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Block.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Block
                 * @static
                 * @param {ic_ledger.pb.v1.IBlock} message Block message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Block.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Block message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Block
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Block} Block
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Block.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Block();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.parentHash = $root.ic_ledger.pb.v1.Hash.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.timestamp = $root.ic_ledger.pb.v1.TimeStamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.transaction = $root.ic_ledger.pb.v1.Transaction.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Block message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Block
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Block} Block
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Block.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Block message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Block
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Block.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.parentHash != null && message.hasOwnProperty("parentHash")) {
                        let error = $root.ic_ledger.pb.v1.Hash.verify(message.parentHash);
                        if (error)
                            return "parentHash." + error;
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        let error = $root.ic_ledger.pb.v1.TimeStamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.transaction != null && message.hasOwnProperty("transaction")) {
                        let error = $root.ic_ledger.pb.v1.Transaction.verify(message.transaction);
                        if (error)
                            return "transaction." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Block message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Block
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Block} Block
                 */
                Block.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Block)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Block();
                    if (object.parentHash != null) {
                        if (typeof object.parentHash !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Block.parentHash: object expected");
                        message.parentHash = $root.ic_ledger.pb.v1.Hash.fromObject(object.parentHash);
                    }
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Block.timestamp: object expected");
                        message.timestamp = $root.ic_ledger.pb.v1.TimeStamp.fromObject(object.timestamp);
                    }
                    if (object.transaction != null) {
                        if (typeof object.transaction !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Block.transaction: object expected");
                        message.transaction = $root.ic_ledger.pb.v1.Transaction.fromObject(object.transaction);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Block message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Block
                 * @static
                 * @param {ic_ledger.pb.v1.Block} message Block
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Block.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.parentHash = null;
                        object.timestamp = null;
                        object.transaction = null;
                    }
                    if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                        object.parentHash = $root.ic_ledger.pb.v1.Hash.toObject(message.parentHash, options);
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.ic_ledger.pb.v1.TimeStamp.toObject(message.timestamp, options);
                    if (message.transaction != null && message.hasOwnProperty("transaction"))
                        object.transaction = $root.ic_ledger.pb.v1.Transaction.toObject(message.transaction, options);
                    return object;
                };

                /**
                 * Converts this Block to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Block
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Block.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Block;
            })();

            v1.Hash = (function() {

                /**
                 * Properties of a Hash.
                 * @memberof ic_ledger.pb.v1
                 * @interface IHash
                 * @property {Uint8Array|null} [hash] Hash hash
                 */

                /**
                 * Constructs a new Hash.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a Hash.
                 * @implements IHash
                 * @constructor
                 * @param {ic_ledger.pb.v1.IHash=} [properties] Properties to set
                 */
                function Hash(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Hash hash.
                 * @member {Uint8Array} hash
                 * @memberof ic_ledger.pb.v1.Hash
                 * @instance
                 */
                Hash.prototype.hash = $util.newBuffer([]);

                /**
                 * Creates a new Hash instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Hash
                 * @static
                 * @param {ic_ledger.pb.v1.IHash=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Hash} Hash instance
                 */
                Hash.create = function create(properties) {
                    return new Hash(properties);
                };

                /**
                 * Encodes the specified Hash message. Does not implicitly {@link ic_ledger.pb.v1.Hash.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Hash
                 * @static
                 * @param {ic_ledger.pb.v1.IHash} message Hash message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Hash.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                    return writer;
                };

                /**
                 * Encodes the specified Hash message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Hash.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Hash
                 * @static
                 * @param {ic_ledger.pb.v1.IHash} message Hash message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Hash.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Hash message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Hash
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Hash} Hash
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Hash.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Hash();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.hash = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Hash message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Hash
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Hash} Hash
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Hash.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Hash message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Hash
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Hash.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                            return "hash: buffer expected";
                    return null;
                };

                /**
                 * Creates a Hash message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Hash
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Hash} Hash
                 */
                Hash.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Hash)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Hash();
                    if (object.hash != null)
                        if (typeof object.hash === "string")
                            $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                        else if (object.hash.length)
                            message.hash = object.hash;
                    return message;
                };

                /**
                 * Creates a plain object from a Hash message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Hash
                 * @static
                 * @param {ic_ledger.pb.v1.Hash} message Hash
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Hash.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.hash = "";
                        else {
                            object.hash = [];
                            if (options.bytes !== Array)
                                object.hash = $util.newBuffer(object.hash);
                        }
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                    return object;
                };

                /**
                 * Converts this Hash to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Hash
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Hash.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Hash;
            })();

            v1.Account = (function() {

                /**
                 * Properties of an Account.
                 * @memberof ic_ledger.pb.v1
                 * @interface IAccount
                 * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [identifier] Account identifier
                 * @property {ic_ledger.pb.v1.IICPTs|null} [balance] Account balance
                 */

                /**
                 * Constructs a new Account.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an Account.
                 * @implements IAccount
                 * @constructor
                 * @param {ic_ledger.pb.v1.IAccount=} [properties] Properties to set
                 */
                function Account(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Account identifier.
                 * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} identifier
                 * @memberof ic_ledger.pb.v1.Account
                 * @instance
                 */
                Account.prototype.identifier = null;

                /**
                 * Account balance.
                 * @member {ic_ledger.pb.v1.IICPTs|null|undefined} balance
                 * @memberof ic_ledger.pb.v1.Account
                 * @instance
                 */
                Account.prototype.balance = null;

                /**
                 * Creates a new Account instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Account
                 * @static
                 * @param {ic_ledger.pb.v1.IAccount=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Account} Account instance
                 */
                Account.create = function create(properties) {
                    return new Account(properties);
                };

                /**
                 * Encodes the specified Account message. Does not implicitly {@link ic_ledger.pb.v1.Account.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Account
                 * @static
                 * @param {ic_ledger.pb.v1.IAccount} message Account message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Account.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.identifier != null && Object.hasOwnProperty.call(message, "identifier"))
                        $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.identifier, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                        $root.ic_ledger.pb.v1.ICPTs.encode(message.balance, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Account message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Account.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Account
                 * @static
                 * @param {ic_ledger.pb.v1.IAccount} message Account message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Account.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Account message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Account
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Account} Account
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Account.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Account();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.identifier = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.balance = $root.ic_ledger.pb.v1.ICPTs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Account message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Account
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Account} Account
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Account.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Account message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Account
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Account.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.identifier != null && message.hasOwnProperty("identifier")) {
                        let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.identifier);
                        if (error)
                            return "identifier." + error;
                    }
                    if (message.balance != null && message.hasOwnProperty("balance")) {
                        let error = $root.ic_ledger.pb.v1.ICPTs.verify(message.balance);
                        if (error)
                            return "balance." + error;
                    }
                    return null;
                };

                /**
                 * Creates an Account message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Account
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Account} Account
                 */
                Account.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Account)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Account();
                    if (object.identifier != null) {
                        if (typeof object.identifier !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Account.identifier: object expected");
                        message.identifier = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.identifier);
                    }
                    if (object.balance != null) {
                        if (typeof object.balance !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Account.balance: object expected");
                        message.balance = $root.ic_ledger.pb.v1.ICPTs.fromObject(object.balance);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Account message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Account
                 * @static
                 * @param {ic_ledger.pb.v1.Account} message Account
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Account.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.identifier = null;
                        object.balance = null;
                    }
                    if (message.identifier != null && message.hasOwnProperty("identifier"))
                        object.identifier = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.identifier, options);
                    if (message.balance != null && message.hasOwnProperty("balance"))
                        object.balance = $root.ic_ledger.pb.v1.ICPTs.toObject(message.balance, options);
                    return object;
                };

                /**
                 * Converts this Account to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Account
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Account.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Account;
            })();

            v1.Transaction = (function() {

                /**
                 * Properties of a Transaction.
                 * @memberof ic_ledger.pb.v1
                 * @interface ITransaction
                 * @property {ic_ledger.pb.v1.IBurn|null} [burn] Transaction burn
                 * @property {ic_ledger.pb.v1.IMint|null} [mint] Transaction mint
                 * @property {ic_ledger.pb.v1.ISend|null} [send] Transaction send
                 * @property {ic_ledger.pb.v1.IMemo|null} [memo] Transaction memo
                 * @property {ic_ledger.pb.v1.IBlockHeight|null} [createdAt] Transaction createdAt
                 * @property {ic_ledger.pb.v1.ITimeStamp|null} [createdAtTime] Transaction createdAtTime
                 */

                /**
                 * Constructs a new Transaction.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a Transaction.
                 * @implements ITransaction
                 * @constructor
                 * @param {ic_ledger.pb.v1.ITransaction=} [properties] Properties to set
                 */
                function Transaction(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Transaction burn.
                 * @member {ic_ledger.pb.v1.IBurn|null|undefined} burn
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @instance
                 */
                Transaction.prototype.burn = null;

                /**
                 * Transaction mint.
                 * @member {ic_ledger.pb.v1.IMint|null|undefined} mint
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @instance
                 */
                Transaction.prototype.mint = null;

                /**
                 * Transaction send.
                 * @member {ic_ledger.pb.v1.ISend|null|undefined} send
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @instance
                 */
                Transaction.prototype.send = null;

                /**
                 * Transaction memo.
                 * @member {ic_ledger.pb.v1.IMemo|null|undefined} memo
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @instance
                 */
                Transaction.prototype.memo = null;

                /**
                 * Transaction createdAt.
                 * @member {ic_ledger.pb.v1.IBlockHeight|null|undefined} createdAt
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @instance
                 */
                Transaction.prototype.createdAt = null;

                /**
                 * Transaction createdAtTime.
                 * @member {ic_ledger.pb.v1.ITimeStamp|null|undefined} createdAtTime
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @instance
                 */
                Transaction.prototype.createdAtTime = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Transaction transfer.
                 * @member {"burn"|"mint"|"send"|undefined} transfer
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @instance
                 */
                Object.defineProperty(Transaction.prototype, "transfer", {
                    get: $util.oneOfGetter($oneOfFields = ["burn", "mint", "send"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Transaction instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @static
                 * @param {ic_ledger.pb.v1.ITransaction=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Transaction} Transaction instance
                 */
                Transaction.create = function create(properties) {
                    return new Transaction(properties);
                };

                /**
                 * Encodes the specified Transaction message. Does not implicitly {@link ic_ledger.pb.v1.Transaction.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @static
                 * @param {ic_ledger.pb.v1.ITransaction} message Transaction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Transaction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.burn != null && Object.hasOwnProperty.call(message, "burn"))
                        $root.ic_ledger.pb.v1.Burn.encode(message.burn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.mint != null && Object.hasOwnProperty.call(message, "mint"))
                        $root.ic_ledger.pb.v1.Mint.encode(message.mint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.send != null && Object.hasOwnProperty.call(message, "send"))
                        $root.ic_ledger.pb.v1.Send.encode(message.send, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                        $root.ic_ledger.pb.v1.Memo.encode(message.memo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.createdAt != null && Object.hasOwnProperty.call(message, "createdAt"))
                        $root.ic_ledger.pb.v1.BlockHeight.encode(message.createdAt, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.createdAtTime != null && Object.hasOwnProperty.call(message, "createdAtTime"))
                        $root.ic_ledger.pb.v1.TimeStamp.encode(message.createdAtTime, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Transaction message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Transaction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @static
                 * @param {ic_ledger.pb.v1.ITransaction} message Transaction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Transaction message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Transaction} Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Transaction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Transaction();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.burn = $root.ic_ledger.pb.v1.Burn.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.mint = $root.ic_ledger.pb.v1.Mint.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.send = $root.ic_ledger.pb.v1.Send.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.memo = $root.ic_ledger.pb.v1.Memo.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.createdAt = $root.ic_ledger.pb.v1.BlockHeight.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.createdAtTime = $root.ic_ledger.pb.v1.TimeStamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Transaction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Transaction} Transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Transaction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Transaction message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Transaction.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.burn != null && message.hasOwnProperty("burn")) {
                        properties.transfer = 1;
                        {
                            let error = $root.ic_ledger.pb.v1.Burn.verify(message.burn);
                            if (error)
                                return "burn." + error;
                        }
                    }
                    if (message.mint != null && message.hasOwnProperty("mint")) {
                        if (properties.transfer === 1)
                            return "transfer: multiple values";
                        properties.transfer = 1;
                        {
                            let error = $root.ic_ledger.pb.v1.Mint.verify(message.mint);
                            if (error)
                                return "mint." + error;
                        }
                    }
                    if (message.send != null && message.hasOwnProperty("send")) {
                        if (properties.transfer === 1)
                            return "transfer: multiple values";
                        properties.transfer = 1;
                        {
                            let error = $root.ic_ledger.pb.v1.Send.verify(message.send);
                            if (error)
                                return "send." + error;
                        }
                    }
                    if (message.memo != null && message.hasOwnProperty("memo")) {
                        let error = $root.ic_ledger.pb.v1.Memo.verify(message.memo);
                        if (error)
                            return "memo." + error;
                    }
                    if (message.createdAt != null && message.hasOwnProperty("createdAt")) {
                        let error = $root.ic_ledger.pb.v1.BlockHeight.verify(message.createdAt);
                        if (error)
                            return "createdAt." + error;
                    }
                    if (message.createdAtTime != null && message.hasOwnProperty("createdAtTime")) {
                        let error = $root.ic_ledger.pb.v1.TimeStamp.verify(message.createdAtTime);
                        if (error)
                            return "createdAtTime." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Transaction} Transaction
                 */
                Transaction.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Transaction)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Transaction();
                    if (object.burn != null) {
                        if (typeof object.burn !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Transaction.burn: object expected");
                        message.burn = $root.ic_ledger.pb.v1.Burn.fromObject(object.burn);
                    }
                    if (object.mint != null) {
                        if (typeof object.mint !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Transaction.mint: object expected");
                        message.mint = $root.ic_ledger.pb.v1.Mint.fromObject(object.mint);
                    }
                    if (object.send != null) {
                        if (typeof object.send !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Transaction.send: object expected");
                        message.send = $root.ic_ledger.pb.v1.Send.fromObject(object.send);
                    }
                    if (object.memo != null) {
                        if (typeof object.memo !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Transaction.memo: object expected");
                        message.memo = $root.ic_ledger.pb.v1.Memo.fromObject(object.memo);
                    }
                    if (object.createdAt != null) {
                        if (typeof object.createdAt !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Transaction.createdAt: object expected");
                        message.createdAt = $root.ic_ledger.pb.v1.BlockHeight.fromObject(object.createdAt);
                    }
                    if (object.createdAtTime != null) {
                        if (typeof object.createdAtTime !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Transaction.createdAtTime: object expected");
                        message.createdAtTime = $root.ic_ledger.pb.v1.TimeStamp.fromObject(object.createdAtTime);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Transaction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @static
                 * @param {ic_ledger.pb.v1.Transaction} message Transaction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Transaction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.memo = null;
                        object.createdAt = null;
                        object.createdAtTime = null;
                    }
                    if (message.burn != null && message.hasOwnProperty("burn")) {
                        object.burn = $root.ic_ledger.pb.v1.Burn.toObject(message.burn, options);
                        if (options.oneofs)
                            object.transfer = "burn";
                    }
                    if (message.mint != null && message.hasOwnProperty("mint")) {
                        object.mint = $root.ic_ledger.pb.v1.Mint.toObject(message.mint, options);
                        if (options.oneofs)
                            object.transfer = "mint";
                    }
                    if (message.send != null && message.hasOwnProperty("send")) {
                        object.send = $root.ic_ledger.pb.v1.Send.toObject(message.send, options);
                        if (options.oneofs)
                            object.transfer = "send";
                    }
                    if (message.memo != null && message.hasOwnProperty("memo"))
                        object.memo = $root.ic_ledger.pb.v1.Memo.toObject(message.memo, options);
                    if (message.createdAt != null && message.hasOwnProperty("createdAt"))
                        object.createdAt = $root.ic_ledger.pb.v1.BlockHeight.toObject(message.createdAt, options);
                    if (message.createdAtTime != null && message.hasOwnProperty("createdAtTime"))
                        object.createdAtTime = $root.ic_ledger.pb.v1.TimeStamp.toObject(message.createdAtTime, options);
                    return object;
                };

                /**
                 * Converts this Transaction to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Transaction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Transaction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Transaction;
            })();

            v1.Send = (function() {

                /**
                 * Properties of a Send.
                 * @memberof ic_ledger.pb.v1
                 * @interface ISend
                 * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [from] Send from
                 * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [to] Send to
                 * @property {ic_ledger.pb.v1.IICPTs|null} [amount] Send amount
                 * @property {ic_ledger.pb.v1.IICPTs|null} [maxFee] Send maxFee
                 */

                /**
                 * Constructs a new Send.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a Send.
                 * @implements ISend
                 * @constructor
                 * @param {ic_ledger.pb.v1.ISend=} [properties] Properties to set
                 */
                function Send(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Send from.
                 * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} from
                 * @memberof ic_ledger.pb.v1.Send
                 * @instance
                 */
                Send.prototype.from = null;

                /**
                 * Send to.
                 * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} to
                 * @memberof ic_ledger.pb.v1.Send
                 * @instance
                 */
                Send.prototype.to = null;

                /**
                 * Send amount.
                 * @member {ic_ledger.pb.v1.IICPTs|null|undefined} amount
                 * @memberof ic_ledger.pb.v1.Send
                 * @instance
                 */
                Send.prototype.amount = null;

                /**
                 * Send maxFee.
                 * @member {ic_ledger.pb.v1.IICPTs|null|undefined} maxFee
                 * @memberof ic_ledger.pb.v1.Send
                 * @instance
                 */
                Send.prototype.maxFee = null;

                /**
                 * Creates a new Send instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Send
                 * @static
                 * @param {ic_ledger.pb.v1.ISend=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Send} Send instance
                 */
                Send.create = function create(properties) {
                    return new Send(properties);
                };

                /**
                 * Encodes the specified Send message. Does not implicitly {@link ic_ledger.pb.v1.Send.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Send
                 * @static
                 * @param {ic_ledger.pb.v1.ISend} message Send message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Send.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                        $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                        $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.to, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.ic_ledger.pb.v1.ICPTs.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.maxFee != null && Object.hasOwnProperty.call(message, "maxFee"))
                        $root.ic_ledger.pb.v1.ICPTs.encode(message.maxFee, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Send message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Send.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Send
                 * @static
                 * @param {ic_ledger.pb.v1.ISend} message Send message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Send.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Send message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Send
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Send} Send
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Send.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Send();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.from = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.to = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.amount = $root.ic_ledger.pb.v1.ICPTs.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.maxFee = $root.ic_ledger.pb.v1.ICPTs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Send message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Send
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Send} Send
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Send.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Send message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Send
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Send.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.from != null && message.hasOwnProperty("from")) {
                        let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.from);
                        if (error)
                            return "from." + error;
                    }
                    if (message.to != null && message.hasOwnProperty("to")) {
                        let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.to);
                        if (error)
                            return "to." + error;
                    }
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        let error = $root.ic_ledger.pb.v1.ICPTs.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    if (message.maxFee != null && message.hasOwnProperty("maxFee")) {
                        let error = $root.ic_ledger.pb.v1.ICPTs.verify(message.maxFee);
                        if (error)
                            return "maxFee." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Send message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Send
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Send} Send
                 */
                Send.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Send)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Send();
                    if (object.from != null) {
                        if (typeof object.from !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Send.from: object expected");
                        message.from = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.from);
                    }
                    if (object.to != null) {
                        if (typeof object.to !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Send.to: object expected");
                        message.to = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.to);
                    }
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Send.amount: object expected");
                        message.amount = $root.ic_ledger.pb.v1.ICPTs.fromObject(object.amount);
                    }
                    if (object.maxFee != null) {
                        if (typeof object.maxFee !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Send.maxFee: object expected");
                        message.maxFee = $root.ic_ledger.pb.v1.ICPTs.fromObject(object.maxFee);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Send message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Send
                 * @static
                 * @param {ic_ledger.pb.v1.Send} message Send
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Send.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.from = null;
                        object.to = null;
                        object.amount = null;
                        object.maxFee = null;
                    }
                    if (message.from != null && message.hasOwnProperty("from"))
                        object.from = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.from, options);
                    if (message.to != null && message.hasOwnProperty("to"))
                        object.to = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.to, options);
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.ic_ledger.pb.v1.ICPTs.toObject(message.amount, options);
                    if (message.maxFee != null && message.hasOwnProperty("maxFee"))
                        object.maxFee = $root.ic_ledger.pb.v1.ICPTs.toObject(message.maxFee, options);
                    return object;
                };

                /**
                 * Converts this Send to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Send
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Send.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Send;
            })();

            v1.Mint = (function() {

                /**
                 * Properties of a Mint.
                 * @memberof ic_ledger.pb.v1
                 * @interface IMint
                 * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [to] Mint to
                 * @property {ic_ledger.pb.v1.IICPTs|null} [amount] Mint amount
                 */

                /**
                 * Constructs a new Mint.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a Mint.
                 * @implements IMint
                 * @constructor
                 * @param {ic_ledger.pb.v1.IMint=} [properties] Properties to set
                 */
                function Mint(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Mint to.
                 * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} to
                 * @memberof ic_ledger.pb.v1.Mint
                 * @instance
                 */
                Mint.prototype.to = null;

                /**
                 * Mint amount.
                 * @member {ic_ledger.pb.v1.IICPTs|null|undefined} amount
                 * @memberof ic_ledger.pb.v1.Mint
                 * @instance
                 */
                Mint.prototype.amount = null;

                /**
                 * Creates a new Mint instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Mint
                 * @static
                 * @param {ic_ledger.pb.v1.IMint=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Mint} Mint instance
                 */
                Mint.create = function create(properties) {
                    return new Mint(properties);
                };

                /**
                 * Encodes the specified Mint message. Does not implicitly {@link ic_ledger.pb.v1.Mint.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Mint
                 * @static
                 * @param {ic_ledger.pb.v1.IMint} message Mint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Mint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                        $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.to, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.ic_ledger.pb.v1.ICPTs.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Mint message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Mint.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Mint
                 * @static
                 * @param {ic_ledger.pb.v1.IMint} message Mint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Mint.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Mint message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Mint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Mint} Mint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Mint.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Mint();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.to = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.amount = $root.ic_ledger.pb.v1.ICPTs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Mint message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Mint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Mint} Mint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Mint.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Mint message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Mint
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Mint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.to != null && message.hasOwnProperty("to")) {
                        let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.to);
                        if (error)
                            return "to." + error;
                    }
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        let error = $root.ic_ledger.pb.v1.ICPTs.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Mint message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Mint
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Mint} Mint
                 */
                Mint.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Mint)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Mint();
                    if (object.to != null) {
                        if (typeof object.to !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Mint.to: object expected");
                        message.to = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.to);
                    }
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Mint.amount: object expected");
                        message.amount = $root.ic_ledger.pb.v1.ICPTs.fromObject(object.amount);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Mint message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Mint
                 * @static
                 * @param {ic_ledger.pb.v1.Mint} message Mint
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Mint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.to = null;
                        object.amount = null;
                    }
                    if (message.to != null && message.hasOwnProperty("to"))
                        object.to = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.to, options);
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.ic_ledger.pb.v1.ICPTs.toObject(message.amount, options);
                    return object;
                };

                /**
                 * Converts this Mint to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Mint
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Mint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Mint;
            })();

            v1.Burn = (function() {

                /**
                 * Properties of a Burn.
                 * @memberof ic_ledger.pb.v1
                 * @interface IBurn
                 * @property {ic_ledger.pb.v1.IAccountIdentifier|null} [from] Burn from
                 * @property {ic_ledger.pb.v1.IICPTs|null} [amount] Burn amount
                 */

                /**
                 * Constructs a new Burn.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a Burn.
                 * @implements IBurn
                 * @constructor
                 * @param {ic_ledger.pb.v1.IBurn=} [properties] Properties to set
                 */
                function Burn(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Burn from.
                 * @member {ic_ledger.pb.v1.IAccountIdentifier|null|undefined} from
                 * @memberof ic_ledger.pb.v1.Burn
                 * @instance
                 */
                Burn.prototype.from = null;

                /**
                 * Burn amount.
                 * @member {ic_ledger.pb.v1.IICPTs|null|undefined} amount
                 * @memberof ic_ledger.pb.v1.Burn
                 * @instance
                 */
                Burn.prototype.amount = null;

                /**
                 * Creates a new Burn instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Burn
                 * @static
                 * @param {ic_ledger.pb.v1.IBurn=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Burn} Burn instance
                 */
                Burn.create = function create(properties) {
                    return new Burn(properties);
                };

                /**
                 * Encodes the specified Burn message. Does not implicitly {@link ic_ledger.pb.v1.Burn.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Burn
                 * @static
                 * @param {ic_ledger.pb.v1.IBurn} message Burn message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Burn.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                        $root.ic_ledger.pb.v1.AccountIdentifier.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        $root.ic_ledger.pb.v1.ICPTs.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Burn message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Burn.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Burn
                 * @static
                 * @param {ic_ledger.pb.v1.IBurn} message Burn message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Burn.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Burn message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Burn
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Burn} Burn
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Burn.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Burn();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.from = $root.ic_ledger.pb.v1.AccountIdentifier.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.amount = $root.ic_ledger.pb.v1.ICPTs.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Burn message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Burn
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Burn} Burn
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Burn.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Burn message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Burn
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Burn.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.from != null && message.hasOwnProperty("from")) {
                        let error = $root.ic_ledger.pb.v1.AccountIdentifier.verify(message.from);
                        if (error)
                            return "from." + error;
                    }
                    if (message.amount != null && message.hasOwnProperty("amount")) {
                        let error = $root.ic_ledger.pb.v1.ICPTs.verify(message.amount);
                        if (error)
                            return "amount." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Burn message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Burn
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Burn} Burn
                 */
                Burn.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Burn)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Burn();
                    if (object.from != null) {
                        if (typeof object.from !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Burn.from: object expected");
                        message.from = $root.ic_ledger.pb.v1.AccountIdentifier.fromObject(object.from);
                    }
                    if (object.amount != null) {
                        if (typeof object.amount !== "object")
                            throw TypeError(".ic_ledger.pb.v1.Burn.amount: object expected");
                        message.amount = $root.ic_ledger.pb.v1.ICPTs.fromObject(object.amount);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Burn message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Burn
                 * @static
                 * @param {ic_ledger.pb.v1.Burn} message Burn
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Burn.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.from = null;
                        object.amount = null;
                    }
                    if (message.from != null && message.hasOwnProperty("from"))
                        object.from = $root.ic_ledger.pb.v1.AccountIdentifier.toObject(message.from, options);
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        object.amount = $root.ic_ledger.pb.v1.ICPTs.toObject(message.amount, options);
                    return object;
                };

                /**
                 * Converts this Burn to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Burn
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Burn.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Burn;
            })();

            v1.AccountIdentifier = (function() {

                /**
                 * Properties of an AccountIdentifier.
                 * @memberof ic_ledger.pb.v1
                 * @interface IAccountIdentifier
                 * @property {Uint8Array|null} [hash] AccountIdentifier hash
                 */

                /**
                 * Constructs a new AccountIdentifier.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents an AccountIdentifier.
                 * @implements IAccountIdentifier
                 * @constructor
                 * @param {ic_ledger.pb.v1.IAccountIdentifier=} [properties] Properties to set
                 */
                function AccountIdentifier(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AccountIdentifier hash.
                 * @member {Uint8Array} hash
                 * @memberof ic_ledger.pb.v1.AccountIdentifier
                 * @instance
                 */
                AccountIdentifier.prototype.hash = $util.newBuffer([]);

                /**
                 * Creates a new AccountIdentifier instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.AccountIdentifier
                 * @static
                 * @param {ic_ledger.pb.v1.IAccountIdentifier=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.AccountIdentifier} AccountIdentifier instance
                 */
                AccountIdentifier.create = function create(properties) {
                    return new AccountIdentifier(properties);
                };

                /**
                 * Encodes the specified AccountIdentifier message. Does not implicitly {@link ic_ledger.pb.v1.AccountIdentifier.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.AccountIdentifier
                 * @static
                 * @param {ic_ledger.pb.v1.IAccountIdentifier} message AccountIdentifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountIdentifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                    return writer;
                };

                /**
                 * Encodes the specified AccountIdentifier message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.AccountIdentifier.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.AccountIdentifier
                 * @static
                 * @param {ic_ledger.pb.v1.IAccountIdentifier} message AccountIdentifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AccountIdentifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.AccountIdentifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.AccountIdentifier} AccountIdentifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountIdentifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.AccountIdentifier();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.hash = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AccountIdentifier message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.AccountIdentifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.AccountIdentifier} AccountIdentifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountIdentifier.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AccountIdentifier message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.AccountIdentifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AccountIdentifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                            return "hash: buffer expected";
                    return null;
                };

                /**
                 * Creates an AccountIdentifier message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.AccountIdentifier
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.AccountIdentifier} AccountIdentifier
                 */
                AccountIdentifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.AccountIdentifier)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.AccountIdentifier();
                    if (object.hash != null)
                        if (typeof object.hash === "string")
                            $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                        else if (object.hash.length)
                            message.hash = object.hash;
                    return message;
                };

                /**
                 * Creates a plain object from an AccountIdentifier message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.AccountIdentifier
                 * @static
                 * @param {ic_ledger.pb.v1.AccountIdentifier} message AccountIdentifier
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AccountIdentifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.hash = "";
                        else {
                            object.hash = [];
                            if (options.bytes !== Array)
                                object.hash = $util.newBuffer(object.hash);
                        }
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                    return object;
                };

                /**
                 * Converts this AccountIdentifier to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.AccountIdentifier
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AccountIdentifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AccountIdentifier;
            })();

            v1.Subaccount = (function() {

                /**
                 * Properties of a Subaccount.
                 * @memberof ic_ledger.pb.v1
                 * @interface ISubaccount
                 * @property {Uint8Array|null} [subAccount] Subaccount subAccount
                 */

                /**
                 * Constructs a new Subaccount.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a Subaccount.
                 * @implements ISubaccount
                 * @constructor
                 * @param {ic_ledger.pb.v1.ISubaccount=} [properties] Properties to set
                 */
                function Subaccount(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Subaccount subAccount.
                 * @member {Uint8Array} subAccount
                 * @memberof ic_ledger.pb.v1.Subaccount
                 * @instance
                 */
                Subaccount.prototype.subAccount = $util.newBuffer([]);

                /**
                 * Creates a new Subaccount instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Subaccount
                 * @static
                 * @param {ic_ledger.pb.v1.ISubaccount=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Subaccount} Subaccount instance
                 */
                Subaccount.create = function create(properties) {
                    return new Subaccount(properties);
                };

                /**
                 * Encodes the specified Subaccount message. Does not implicitly {@link ic_ledger.pb.v1.Subaccount.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Subaccount
                 * @static
                 * @param {ic_ledger.pb.v1.ISubaccount} message Subaccount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subaccount.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.subAccount != null && Object.hasOwnProperty.call(message, "subAccount"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.subAccount);
                    return writer;
                };

                /**
                 * Encodes the specified Subaccount message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Subaccount.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Subaccount
                 * @static
                 * @param {ic_ledger.pb.v1.ISubaccount} message Subaccount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Subaccount.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Subaccount message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Subaccount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Subaccount} Subaccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subaccount.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Subaccount();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.subAccount = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Subaccount message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Subaccount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Subaccount} Subaccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Subaccount.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Subaccount message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Subaccount
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Subaccount.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.subAccount != null && message.hasOwnProperty("subAccount"))
                        if (!(message.subAccount && typeof message.subAccount.length === "number" || $util.isString(message.subAccount)))
                            return "subAccount: buffer expected";
                    return null;
                };

                /**
                 * Creates a Subaccount message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Subaccount
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Subaccount} Subaccount
                 */
                Subaccount.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Subaccount)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Subaccount();
                    if (object.subAccount != null)
                        if (typeof object.subAccount === "string")
                            $util.base64.decode(object.subAccount, message.subAccount = $util.newBuffer($util.base64.length(object.subAccount)), 0);
                        else if (object.subAccount.length)
                            message.subAccount = object.subAccount;
                    return message;
                };

                /**
                 * Creates a plain object from a Subaccount message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Subaccount
                 * @static
                 * @param {ic_ledger.pb.v1.Subaccount} message Subaccount
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Subaccount.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.subAccount = "";
                        else {
                            object.subAccount = [];
                            if (options.bytes !== Array)
                                object.subAccount = $util.newBuffer(object.subAccount);
                        }
                    if (message.subAccount != null && message.hasOwnProperty("subAccount"))
                        object.subAccount = options.bytes === String ? $util.base64.encode(message.subAccount, 0, message.subAccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.subAccount) : message.subAccount;
                    return object;
                };

                /**
                 * Converts this Subaccount to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Subaccount
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Subaccount.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Subaccount;
            })();

            v1.Memo = (function() {

                /**
                 * Properties of a Memo.
                 * @memberof ic_ledger.pb.v1
                 * @interface IMemo
                 * @property {number|Long|null} [memo] Memo memo
                 */

                /**
                 * Constructs a new Memo.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a Memo.
                 * @implements IMemo
                 * @constructor
                 * @param {ic_ledger.pb.v1.IMemo=} [properties] Properties to set
                 */
                function Memo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Memo memo.
                 * @member {number|Long} memo
                 * @memberof ic_ledger.pb.v1.Memo
                 * @instance
                 */
                Memo.prototype.memo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new Memo instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Memo
                 * @static
                 * @param {ic_ledger.pb.v1.IMemo=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Memo} Memo instance
                 */
                Memo.create = function create(properties) {
                    return new Memo(properties);
                };

                /**
                 * Encodes the specified Memo message. Does not implicitly {@link ic_ledger.pb.v1.Memo.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Memo
                 * @static
                 * @param {ic_ledger.pb.v1.IMemo} message Memo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Memo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.memo != null && Object.hasOwnProperty.call(message, "memo"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.memo);
                    return writer;
                };

                /**
                 * Encodes the specified Memo message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Memo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Memo
                 * @static
                 * @param {ic_ledger.pb.v1.IMemo} message Memo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Memo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Memo message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Memo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Memo} Memo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Memo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Memo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.memo = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Memo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Memo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Memo} Memo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Memo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Memo message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Memo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Memo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.memo != null && message.hasOwnProperty("memo"))
                        if (!$util.isInteger(message.memo) && !(message.memo && $util.isInteger(message.memo.low) && $util.isInteger(message.memo.high)))
                            return "memo: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a Memo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Memo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Memo} Memo
                 */
                Memo.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Memo)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Memo();
                    if (object.memo != null)
                        if ($util.Long)
                            (message.memo = $util.Long.fromValue(object.memo)).unsigned = true;
                        else if (typeof object.memo === "string")
                            message.memo = parseInt(object.memo, 10);
                        else if (typeof object.memo === "number")
                            message.memo = object.memo;
                        else if (typeof object.memo === "object")
                            message.memo = new $util.LongBits(object.memo.low >>> 0, object.memo.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a Memo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Memo
                 * @static
                 * @param {ic_ledger.pb.v1.Memo} message Memo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Memo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.memo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.memo = options.longs === String ? "0" : 0;
                    if (message.memo != null && message.hasOwnProperty("memo"))
                        if (typeof message.memo === "number")
                            object.memo = options.longs === String ? String(message.memo) : message.memo;
                        else
                            object.memo = options.longs === String ? $util.Long.prototype.toString.call(message.memo) : options.longs === Number ? new $util.LongBits(message.memo.low >>> 0, message.memo.high >>> 0).toNumber(true) : message.memo;
                    return object;
                };

                /**
                 * Converts this Memo to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Memo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Memo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Memo;
            })();

            v1.TimeStamp = (function() {

                /**
                 * Properties of a TimeStamp.
                 * @memberof ic_ledger.pb.v1
                 * @interface ITimeStamp
                 * @property {number|Long|null} [timestampNanos] TimeStamp timestampNanos
                 */

                /**
                 * Constructs a new TimeStamp.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a TimeStamp.
                 * @implements ITimeStamp
                 * @constructor
                 * @param {ic_ledger.pb.v1.ITimeStamp=} [properties] Properties to set
                 */
                function TimeStamp(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TimeStamp timestampNanos.
                 * @member {number|Long} timestampNanos
                 * @memberof ic_ledger.pb.v1.TimeStamp
                 * @instance
                 */
                TimeStamp.prototype.timestampNanos = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new TimeStamp instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.TimeStamp
                 * @static
                 * @param {ic_ledger.pb.v1.ITimeStamp=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.TimeStamp} TimeStamp instance
                 */
                TimeStamp.create = function create(properties) {
                    return new TimeStamp(properties);
                };

                /**
                 * Encodes the specified TimeStamp message. Does not implicitly {@link ic_ledger.pb.v1.TimeStamp.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.TimeStamp
                 * @static
                 * @param {ic_ledger.pb.v1.ITimeStamp} message TimeStamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimeStamp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestampNanos != null && Object.hasOwnProperty.call(message, "timestampNanos"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestampNanos);
                    return writer;
                };

                /**
                 * Encodes the specified TimeStamp message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.TimeStamp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.TimeStamp
                 * @static
                 * @param {ic_ledger.pb.v1.ITimeStamp} message TimeStamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimeStamp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TimeStamp message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.TimeStamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.TimeStamp} TimeStamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimeStamp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.TimeStamp();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestampNanos = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TimeStamp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.TimeStamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.TimeStamp} TimeStamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimeStamp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TimeStamp message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.TimeStamp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TimeStamp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestampNanos != null && message.hasOwnProperty("timestampNanos"))
                        if (!$util.isInteger(message.timestampNanos) && !(message.timestampNanos && $util.isInteger(message.timestampNanos.low) && $util.isInteger(message.timestampNanos.high)))
                            return "timestampNanos: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a TimeStamp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.TimeStamp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.TimeStamp} TimeStamp
                 */
                TimeStamp.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.TimeStamp)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.TimeStamp();
                    if (object.timestampNanos != null)
                        if ($util.Long)
                            (message.timestampNanos = $util.Long.fromValue(object.timestampNanos)).unsigned = true;
                        else if (typeof object.timestampNanos === "string")
                            message.timestampNanos = parseInt(object.timestampNanos, 10);
                        else if (typeof object.timestampNanos === "number")
                            message.timestampNanos = object.timestampNanos;
                        else if (typeof object.timestampNanos === "object")
                            message.timestampNanos = new $util.LongBits(object.timestampNanos.low >>> 0, object.timestampNanos.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a TimeStamp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.TimeStamp
                 * @static
                 * @param {ic_ledger.pb.v1.TimeStamp} message TimeStamp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeStamp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.timestampNanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestampNanos = options.longs === String ? "0" : 0;
                    if (message.timestampNanos != null && message.hasOwnProperty("timestampNanos"))
                        if (typeof message.timestampNanos === "number")
                            object.timestampNanos = options.longs === String ? String(message.timestampNanos) : message.timestampNanos;
                        else
                            object.timestampNanos = options.longs === String ? $util.Long.prototype.toString.call(message.timestampNanos) : options.longs === Number ? new $util.LongBits(message.timestampNanos.low >>> 0, message.timestampNanos.high >>> 0).toNumber(true) : message.timestampNanos;
                    return object;
                };

                /**
                 * Converts this TimeStamp to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.TimeStamp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TimeStamp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TimeStamp;
            })();

            v1.Certification = (function() {

                /**
                 * Properties of a Certification.
                 * @memberof ic_ledger.pb.v1
                 * @interface ICertification
                 * @property {Uint8Array|null} [certification] Certification certification
                 */

                /**
                 * Constructs a new Certification.
                 * @memberof ic_ledger.pb.v1
                 * @classdesc Represents a Certification.
                 * @implements ICertification
                 * @constructor
                 * @param {ic_ledger.pb.v1.ICertification=} [properties] Properties to set
                 */
                function Certification(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Certification certification.
                 * @member {Uint8Array} certification
                 * @memberof ic_ledger.pb.v1.Certification
                 * @instance
                 */
                Certification.prototype.certification = $util.newBuffer([]);

                /**
                 * Creates a new Certification instance using the specified properties.
                 * @function create
                 * @memberof ic_ledger.pb.v1.Certification
                 * @static
                 * @param {ic_ledger.pb.v1.ICertification=} [properties] Properties to set
                 * @returns {ic_ledger.pb.v1.Certification} Certification instance
                 */
                Certification.create = function create(properties) {
                    return new Certification(properties);
                };

                /**
                 * Encodes the specified Certification message. Does not implicitly {@link ic_ledger.pb.v1.Certification.verify|verify} messages.
                 * @function encode
                 * @memberof ic_ledger.pb.v1.Certification
                 * @static
                 * @param {ic_ledger.pb.v1.ICertification} message Certification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Certification.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.certification != null && Object.hasOwnProperty.call(message, "certification"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.certification);
                    return writer;
                };

                /**
                 * Encodes the specified Certification message, length delimited. Does not implicitly {@link ic_ledger.pb.v1.Certification.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_ledger.pb.v1.Certification
                 * @static
                 * @param {ic_ledger.pb.v1.ICertification} message Certification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Certification.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Certification message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_ledger.pb.v1.Certification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_ledger.pb.v1.Certification} Certification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Certification.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_ledger.pb.v1.Certification();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.certification = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Certification message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_ledger.pb.v1.Certification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_ledger.pb.v1.Certification} Certification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Certification.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Certification message.
                 * @function verify
                 * @memberof ic_ledger.pb.v1.Certification
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Certification.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.certification != null && message.hasOwnProperty("certification"))
                        if (!(message.certification && typeof message.certification.length === "number" || $util.isString(message.certification)))
                            return "certification: buffer expected";
                    return null;
                };

                /**
                 * Creates a Certification message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_ledger.pb.v1.Certification
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_ledger.pb.v1.Certification} Certification
                 */
                Certification.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_ledger.pb.v1.Certification)
                        return object;
                    let message = new $root.ic_ledger.pb.v1.Certification();
                    if (object.certification != null)
                        if (typeof object.certification === "string")
                            $util.base64.decode(object.certification, message.certification = $util.newBuffer($util.base64.length(object.certification)), 0);
                        else if (object.certification.length)
                            message.certification = object.certification;
                    return message;
                };

                /**
                 * Creates a plain object from a Certification message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_ledger.pb.v1.Certification
                 * @static
                 * @param {ic_ledger.pb.v1.Certification} message Certification
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Certification.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.certification = "";
                        else {
                            object.certification = [];
                            if (options.bytes !== Array)
                                object.certification = $util.newBuffer(object.certification);
                        }
                    if (message.certification != null && message.hasOwnProperty("certification"))
                        object.certification = options.bytes === String ? $util.base64.encode(message.certification, 0, message.certification.length) : options.bytes === Array ? Array.prototype.slice.call(message.certification) : message.certification;
                    return object;
                };

                /**
                 * Converts this Certification to JSON.
                 * @function toJSON
                 * @memberof ic_ledger.pb.v1.Certification
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Certification.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Certification;
            })();

            return v1;
        })();

        return pb;
    })();

    return ic_ledger;
})();

export const ic_nns_common = $root.ic_nns_common = (() => {

    /**
     * Namespace ic_nns_common.
     * @exports ic_nns_common
     * @namespace
     */
    const ic_nns_common = {};

    ic_nns_common.pb = (function() {

        /**
         * Namespace pb.
         * @memberof ic_nns_common
         * @namespace
         */
        const pb = {};

        pb.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof ic_nns_common.pb
             * @namespace
             */
            const v1 = {};

            v1.CanisterId = (function() {

                /**
                 * Properties of a CanisterId.
                 * @memberof ic_nns_common.pb.v1
                 * @interface ICanisterId
                 * @property {Uint8Array|null} [serializedId] CanisterId serializedId
                 */

                /**
                 * Constructs a new CanisterId.
                 * @memberof ic_nns_common.pb.v1
                 * @classdesc Represents a CanisterId.
                 * @implements ICanisterId
                 * @constructor
                 * @param {ic_nns_common.pb.v1.ICanisterId=} [properties] Properties to set
                 */
                function CanisterId(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CanisterId serializedId.
                 * @member {Uint8Array} serializedId
                 * @memberof ic_nns_common.pb.v1.CanisterId
                 * @instance
                 */
                CanisterId.prototype.serializedId = $util.newBuffer([]);

                /**
                 * Creates a new CanisterId instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_common.pb.v1.CanisterId
                 * @static
                 * @param {ic_nns_common.pb.v1.ICanisterId=} [properties] Properties to set
                 * @returns {ic_nns_common.pb.v1.CanisterId} CanisterId instance
                 */
                CanisterId.create = function create(properties) {
                    return new CanisterId(properties);
                };

                /**
                 * Encodes the specified CanisterId message. Does not implicitly {@link ic_nns_common.pb.v1.CanisterId.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_common.pb.v1.CanisterId
                 * @static
                 * @param {ic_nns_common.pb.v1.ICanisterId} message CanisterId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CanisterId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.serializedId != null && Object.hasOwnProperty.call(message, "serializedId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.serializedId);
                    return writer;
                };

                /**
                 * Encodes the specified CanisterId message, length delimited. Does not implicitly {@link ic_nns_common.pb.v1.CanisterId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_common.pb.v1.CanisterId
                 * @static
                 * @param {ic_nns_common.pb.v1.ICanisterId} message CanisterId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CanisterId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CanisterId message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_common.pb.v1.CanisterId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_common.pb.v1.CanisterId} CanisterId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CanisterId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_common.pb.v1.CanisterId();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.serializedId = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CanisterId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_common.pb.v1.CanisterId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_common.pb.v1.CanisterId} CanisterId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CanisterId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CanisterId message.
                 * @function verify
                 * @memberof ic_nns_common.pb.v1.CanisterId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CanisterId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.serializedId != null && message.hasOwnProperty("serializedId"))
                        if (!(message.serializedId && typeof message.serializedId.length === "number" || $util.isString(message.serializedId)))
                            return "serializedId: buffer expected";
                    return null;
                };

                /**
                 * Creates a CanisterId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_common.pb.v1.CanisterId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_common.pb.v1.CanisterId} CanisterId
                 */
                CanisterId.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_common.pb.v1.CanisterId)
                        return object;
                    let message = new $root.ic_nns_common.pb.v1.CanisterId();
                    if (object.serializedId != null)
                        if (typeof object.serializedId === "string")
                            $util.base64.decode(object.serializedId, message.serializedId = $util.newBuffer($util.base64.length(object.serializedId)), 0);
                        else if (object.serializedId.length)
                            message.serializedId = object.serializedId;
                    return message;
                };

                /**
                 * Creates a plain object from a CanisterId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_common.pb.v1.CanisterId
                 * @static
                 * @param {ic_nns_common.pb.v1.CanisterId} message CanisterId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CanisterId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.serializedId = "";
                        else {
                            object.serializedId = [];
                            if (options.bytes !== Array)
                                object.serializedId = $util.newBuffer(object.serializedId);
                        }
                    if (message.serializedId != null && message.hasOwnProperty("serializedId"))
                        object.serializedId = options.bytes === String ? $util.base64.encode(message.serializedId, 0, message.serializedId.length) : options.bytes === Array ? Array.prototype.slice.call(message.serializedId) : message.serializedId;
                    return object;
                };

                /**
                 * Converts this CanisterId to JSON.
                 * @function toJSON
                 * @memberof ic_nns_common.pb.v1.CanisterId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CanisterId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CanisterId;
            })();

            v1.NeuronId = (function() {

                /**
                 * Properties of a NeuronId.
                 * @memberof ic_nns_common.pb.v1
                 * @interface INeuronId
                 * @property {number|Long|null} [id] NeuronId id
                 */

                /**
                 * Constructs a new NeuronId.
                 * @memberof ic_nns_common.pb.v1
                 * @classdesc Represents a NeuronId.
                 * @implements INeuronId
                 * @constructor
                 * @param {ic_nns_common.pb.v1.INeuronId=} [properties] Properties to set
                 */
                function NeuronId(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NeuronId id.
                 * @member {number|Long} id
                 * @memberof ic_nns_common.pb.v1.NeuronId
                 * @instance
                 */
                NeuronId.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new NeuronId instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_common.pb.v1.NeuronId
                 * @static
                 * @param {ic_nns_common.pb.v1.INeuronId=} [properties] Properties to set
                 * @returns {ic_nns_common.pb.v1.NeuronId} NeuronId instance
                 */
                NeuronId.create = function create(properties) {
                    return new NeuronId(properties);
                };

                /**
                 * Encodes the specified NeuronId message. Does not implicitly {@link ic_nns_common.pb.v1.NeuronId.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_common.pb.v1.NeuronId
                 * @static
                 * @param {ic_nns_common.pb.v1.INeuronId} message NeuronId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuronId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);
                    return writer;
                };

                /**
                 * Encodes the specified NeuronId message, length delimited. Does not implicitly {@link ic_nns_common.pb.v1.NeuronId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_common.pb.v1.NeuronId
                 * @static
                 * @param {ic_nns_common.pb.v1.INeuronId} message NeuronId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuronId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NeuronId message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_common.pb.v1.NeuronId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_common.pb.v1.NeuronId} NeuronId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuronId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_common.pb.v1.NeuronId();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.id = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NeuronId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_common.pb.v1.NeuronId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_common.pb.v1.NeuronId} NeuronId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuronId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NeuronId message.
                 * @function verify
                 * @memberof ic_nns_common.pb.v1.NeuronId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NeuronId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a NeuronId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_common.pb.v1.NeuronId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_common.pb.v1.NeuronId} NeuronId
                 */
                NeuronId.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_common.pb.v1.NeuronId)
                        return object;
                    let message = new $root.ic_nns_common.pb.v1.NeuronId();
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a NeuronId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_common.pb.v1.NeuronId
                 * @static
                 * @param {ic_nns_common.pb.v1.NeuronId} message NeuronId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NeuronId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    return object;
                };

                /**
                 * Converts this NeuronId to JSON.
                 * @function toJSON
                 * @memberof ic_nns_common.pb.v1.NeuronId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NeuronId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NeuronId;
            })();

            v1.ProposalId = (function() {

                /**
                 * Properties of a ProposalId.
                 * @memberof ic_nns_common.pb.v1
                 * @interface IProposalId
                 * @property {number|Long|null} [id] ProposalId id
                 */

                /**
                 * Constructs a new ProposalId.
                 * @memberof ic_nns_common.pb.v1
                 * @classdesc Represents a ProposalId.
                 * @implements IProposalId
                 * @constructor
                 * @param {ic_nns_common.pb.v1.IProposalId=} [properties] Properties to set
                 */
                function ProposalId(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ProposalId id.
                 * @member {number|Long} id
                 * @memberof ic_nns_common.pb.v1.ProposalId
                 * @instance
                 */
                ProposalId.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new ProposalId instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_common.pb.v1.ProposalId
                 * @static
                 * @param {ic_nns_common.pb.v1.IProposalId=} [properties] Properties to set
                 * @returns {ic_nns_common.pb.v1.ProposalId} ProposalId instance
                 */
                ProposalId.create = function create(properties) {
                    return new ProposalId(properties);
                };

                /**
                 * Encodes the specified ProposalId message. Does not implicitly {@link ic_nns_common.pb.v1.ProposalId.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_common.pb.v1.ProposalId
                 * @static
                 * @param {ic_nns_common.pb.v1.IProposalId} message ProposalId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProposalId.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.id);
                    return writer;
                };

                /**
                 * Encodes the specified ProposalId message, length delimited. Does not implicitly {@link ic_nns_common.pb.v1.ProposalId.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_common.pb.v1.ProposalId
                 * @static
                 * @param {ic_nns_common.pb.v1.IProposalId} message ProposalId message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ProposalId.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ProposalId message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_common.pb.v1.ProposalId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_common.pb.v1.ProposalId} ProposalId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProposalId.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_common.pb.v1.ProposalId();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ProposalId message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_common.pb.v1.ProposalId
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_common.pb.v1.ProposalId} ProposalId
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ProposalId.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ProposalId message.
                 * @function verify
                 * @memberof ic_nns_common.pb.v1.ProposalId
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProposalId.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                            return "id: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ProposalId message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_common.pb.v1.ProposalId
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_common.pb.v1.ProposalId} ProposalId
                 */
                ProposalId.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_common.pb.v1.ProposalId)
                        return object;
                    let message = new $root.ic_nns_common.pb.v1.ProposalId();
                    if (object.id != null)
                        if ($util.Long)
                            (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                        else if (typeof object.id === "string")
                            message.id = parseInt(object.id, 10);
                        else if (typeof object.id === "number")
                            message.id = object.id;
                        else if (typeof object.id === "object")
                            message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a ProposalId message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_common.pb.v1.ProposalId
                 * @static
                 * @param {ic_nns_common.pb.v1.ProposalId} message ProposalId
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProposalId.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.id = options.longs === String ? "0" : 0;
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (typeof message.id === "number")
                            object.id = options.longs === String ? String(message.id) : message.id;
                        else
                            object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                    return object;
                };

                /**
                 * Converts this ProposalId to JSON.
                 * @function toJSON
                 * @memberof ic_nns_common.pb.v1.ProposalId
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProposalId.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ProposalId;
            })();

            v1.MethodAuthzInfo = (function() {

                /**
                 * Properties of a MethodAuthzInfo.
                 * @memberof ic_nns_common.pb.v1
                 * @interface IMethodAuthzInfo
                 * @property {string|null} [methodName] MethodAuthzInfo methodName
                 * @property {Array.<Uint8Array>|null} [principalIds] MethodAuthzInfo principalIds
                 */

                /**
                 * Constructs a new MethodAuthzInfo.
                 * @memberof ic_nns_common.pb.v1
                 * @classdesc Represents a MethodAuthzInfo.
                 * @implements IMethodAuthzInfo
                 * @constructor
                 * @param {ic_nns_common.pb.v1.IMethodAuthzInfo=} [properties] Properties to set
                 */
                function MethodAuthzInfo(properties) {
                    this.principalIds = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MethodAuthzInfo methodName.
                 * @member {string} methodName
                 * @memberof ic_nns_common.pb.v1.MethodAuthzInfo
                 * @instance
                 */
                MethodAuthzInfo.prototype.methodName = "";

                /**
                 * MethodAuthzInfo principalIds.
                 * @member {Array.<Uint8Array>} principalIds
                 * @memberof ic_nns_common.pb.v1.MethodAuthzInfo
                 * @instance
                 */
                MethodAuthzInfo.prototype.principalIds = $util.emptyArray;

                /**
                 * Creates a new MethodAuthzInfo instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_common.pb.v1.MethodAuthzInfo
                 * @static
                 * @param {ic_nns_common.pb.v1.IMethodAuthzInfo=} [properties] Properties to set
                 * @returns {ic_nns_common.pb.v1.MethodAuthzInfo} MethodAuthzInfo instance
                 */
                MethodAuthzInfo.create = function create(properties) {
                    return new MethodAuthzInfo(properties);
                };

                /**
                 * Encodes the specified MethodAuthzInfo message. Does not implicitly {@link ic_nns_common.pb.v1.MethodAuthzInfo.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_common.pb.v1.MethodAuthzInfo
                 * @static
                 * @param {ic_nns_common.pb.v1.IMethodAuthzInfo} message MethodAuthzInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodAuthzInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.methodName != null && Object.hasOwnProperty.call(message, "methodName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.methodName);
                    if (message.principalIds != null && message.principalIds.length)
                        for (let i = 0; i < message.principalIds.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.principalIds[i]);
                    return writer;
                };

                /**
                 * Encodes the specified MethodAuthzInfo message, length delimited. Does not implicitly {@link ic_nns_common.pb.v1.MethodAuthzInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_common.pb.v1.MethodAuthzInfo
                 * @static
                 * @param {ic_nns_common.pb.v1.IMethodAuthzInfo} message MethodAuthzInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodAuthzInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MethodAuthzInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_common.pb.v1.MethodAuthzInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_common.pb.v1.MethodAuthzInfo} MethodAuthzInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodAuthzInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_common.pb.v1.MethodAuthzInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.methodName = reader.string();
                            break;
                        case 2:
                            if (!(message.principalIds && message.principalIds.length))
                                message.principalIds = [];
                            message.principalIds.push(reader.bytes());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MethodAuthzInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_common.pb.v1.MethodAuthzInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_common.pb.v1.MethodAuthzInfo} MethodAuthzInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodAuthzInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MethodAuthzInfo message.
                 * @function verify
                 * @memberof ic_nns_common.pb.v1.MethodAuthzInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodAuthzInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.methodName != null && message.hasOwnProperty("methodName"))
                        if (!$util.isString(message.methodName))
                            return "methodName: string expected";
                    if (message.principalIds != null && message.hasOwnProperty("principalIds")) {
                        if (!Array.isArray(message.principalIds))
                            return "principalIds: array expected";
                        for (let i = 0; i < message.principalIds.length; ++i)
                            if (!(message.principalIds[i] && typeof message.principalIds[i].length === "number" || $util.isString(message.principalIds[i])))
                                return "principalIds: buffer[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a MethodAuthzInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_common.pb.v1.MethodAuthzInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_common.pb.v1.MethodAuthzInfo} MethodAuthzInfo
                 */
                MethodAuthzInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_common.pb.v1.MethodAuthzInfo)
                        return object;
                    let message = new $root.ic_nns_common.pb.v1.MethodAuthzInfo();
                    if (object.methodName != null)
                        message.methodName = String(object.methodName);
                    if (object.principalIds) {
                        if (!Array.isArray(object.principalIds))
                            throw TypeError(".ic_nns_common.pb.v1.MethodAuthzInfo.principalIds: array expected");
                        message.principalIds = [];
                        for (let i = 0; i < object.principalIds.length; ++i)
                            if (typeof object.principalIds[i] === "string")
                                $util.base64.decode(object.principalIds[i], message.principalIds[i] = $util.newBuffer($util.base64.length(object.principalIds[i])), 0);
                            else if (object.principalIds[i].length)
                                message.principalIds[i] = object.principalIds[i];
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MethodAuthzInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_common.pb.v1.MethodAuthzInfo
                 * @static
                 * @param {ic_nns_common.pb.v1.MethodAuthzInfo} message MethodAuthzInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodAuthzInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.principalIds = [];
                    if (options.defaults)
                        object.methodName = "";
                    if (message.methodName != null && message.hasOwnProperty("methodName"))
                        object.methodName = message.methodName;
                    if (message.principalIds && message.principalIds.length) {
                        object.principalIds = [];
                        for (let j = 0; j < message.principalIds.length; ++j)
                            object.principalIds[j] = options.bytes === String ? $util.base64.encode(message.principalIds[j], 0, message.principalIds[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.principalIds[j]) : message.principalIds[j];
                    }
                    return object;
                };

                /**
                 * Converts this MethodAuthzInfo to JSON.
                 * @function toJSON
                 * @memberof ic_nns_common.pb.v1.MethodAuthzInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodAuthzInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MethodAuthzInfo;
            })();

            v1.CanisterAuthzInfo = (function() {

                /**
                 * Properties of a CanisterAuthzInfo.
                 * @memberof ic_nns_common.pb.v1
                 * @interface ICanisterAuthzInfo
                 * @property {Array.<ic_nns_common.pb.v1.IMethodAuthzInfo>|null} [methodsAuthz] CanisterAuthzInfo methodsAuthz
                 */

                /**
                 * Constructs a new CanisterAuthzInfo.
                 * @memberof ic_nns_common.pb.v1
                 * @classdesc Represents a CanisterAuthzInfo.
                 * @implements ICanisterAuthzInfo
                 * @constructor
                 * @param {ic_nns_common.pb.v1.ICanisterAuthzInfo=} [properties] Properties to set
                 */
                function CanisterAuthzInfo(properties) {
                    this.methodsAuthz = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CanisterAuthzInfo methodsAuthz.
                 * @member {Array.<ic_nns_common.pb.v1.IMethodAuthzInfo>} methodsAuthz
                 * @memberof ic_nns_common.pb.v1.CanisterAuthzInfo
                 * @instance
                 */
                CanisterAuthzInfo.prototype.methodsAuthz = $util.emptyArray;

                /**
                 * Creates a new CanisterAuthzInfo instance using the specified properties.
                 * @function create
                 * @memberof ic_nns_common.pb.v1.CanisterAuthzInfo
                 * @static
                 * @param {ic_nns_common.pb.v1.ICanisterAuthzInfo=} [properties] Properties to set
                 * @returns {ic_nns_common.pb.v1.CanisterAuthzInfo} CanisterAuthzInfo instance
                 */
                CanisterAuthzInfo.create = function create(properties) {
                    return new CanisterAuthzInfo(properties);
                };

                /**
                 * Encodes the specified CanisterAuthzInfo message. Does not implicitly {@link ic_nns_common.pb.v1.CanisterAuthzInfo.verify|verify} messages.
                 * @function encode
                 * @memberof ic_nns_common.pb.v1.CanisterAuthzInfo
                 * @static
                 * @param {ic_nns_common.pb.v1.ICanisterAuthzInfo} message CanisterAuthzInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CanisterAuthzInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.methodsAuthz != null && message.methodsAuthz.length)
                        for (let i = 0; i < message.methodsAuthz.length; ++i)
                            $root.ic_nns_common.pb.v1.MethodAuthzInfo.encode(message.methodsAuthz[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CanisterAuthzInfo message, length delimited. Does not implicitly {@link ic_nns_common.pb.v1.CanisterAuthzInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ic_nns_common.pb.v1.CanisterAuthzInfo
                 * @static
                 * @param {ic_nns_common.pb.v1.ICanisterAuthzInfo} message CanisterAuthzInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CanisterAuthzInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CanisterAuthzInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof ic_nns_common.pb.v1.CanisterAuthzInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ic_nns_common.pb.v1.CanisterAuthzInfo} CanisterAuthzInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CanisterAuthzInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ic_nns_common.pb.v1.CanisterAuthzInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.methodsAuthz && message.methodsAuthz.length))
                                message.methodsAuthz = [];
                            message.methodsAuthz.push($root.ic_nns_common.pb.v1.MethodAuthzInfo.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CanisterAuthzInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ic_nns_common.pb.v1.CanisterAuthzInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ic_nns_common.pb.v1.CanisterAuthzInfo} CanisterAuthzInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CanisterAuthzInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CanisterAuthzInfo message.
                 * @function verify
                 * @memberof ic_nns_common.pb.v1.CanisterAuthzInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CanisterAuthzInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.methodsAuthz != null && message.hasOwnProperty("methodsAuthz")) {
                        if (!Array.isArray(message.methodsAuthz))
                            return "methodsAuthz: array expected";
                        for (let i = 0; i < message.methodsAuthz.length; ++i) {
                            let error = $root.ic_nns_common.pb.v1.MethodAuthzInfo.verify(message.methodsAuthz[i]);
                            if (error)
                                return "methodsAuthz." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CanisterAuthzInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ic_nns_common.pb.v1.CanisterAuthzInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ic_nns_common.pb.v1.CanisterAuthzInfo} CanisterAuthzInfo
                 */
                CanisterAuthzInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.ic_nns_common.pb.v1.CanisterAuthzInfo)
                        return object;
                    let message = new $root.ic_nns_common.pb.v1.CanisterAuthzInfo();
                    if (object.methodsAuthz) {
                        if (!Array.isArray(object.methodsAuthz))
                            throw TypeError(".ic_nns_common.pb.v1.CanisterAuthzInfo.methodsAuthz: array expected");
                        message.methodsAuthz = [];
                        for (let i = 0; i < object.methodsAuthz.length; ++i) {
                            if (typeof object.methodsAuthz[i] !== "object")
                                throw TypeError(".ic_nns_common.pb.v1.CanisterAuthzInfo.methodsAuthz: object expected");
                            message.methodsAuthz[i] = $root.ic_nns_common.pb.v1.MethodAuthzInfo.fromObject(object.methodsAuthz[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CanisterAuthzInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ic_nns_common.pb.v1.CanisterAuthzInfo
                 * @static
                 * @param {ic_nns_common.pb.v1.CanisterAuthzInfo} message CanisterAuthzInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CanisterAuthzInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.methodsAuthz = [];
                    if (message.methodsAuthz && message.methodsAuthz.length) {
                        object.methodsAuthz = [];
                        for (let j = 0; j < message.methodsAuthz.length; ++j)
                            object.methodsAuthz[j] = $root.ic_nns_common.pb.v1.MethodAuthzInfo.toObject(message.methodsAuthz[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this CanisterAuthzInfo to JSON.
                 * @function toJSON
                 * @memberof ic_nns_common.pb.v1.CanisterAuthzInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CanisterAuthzInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CanisterAuthzInfo;
            })();

            return v1;
        })();

        return pb;
    })();

    return ic_nns_common;
})();

export { $root as default };
